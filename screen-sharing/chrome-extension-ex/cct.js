(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["cct"] = factory();
	else
		root["cct"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 254);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(47);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["Log"] = Log;
/* harmony export (immutable) */ __webpack_exports__["setLog"] = setLog;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_utils__ = __webpack_require__(13);






var _logFunctions, _logColors;




/**
 * A log interface that is exposed via the singleton `cct.log`.
 *
 * Log messages are sent using one of the five log functions, one for each log level:
 * {@link Log#error}, {@link Log#warning}, {@link Log#info}, {@link Log#debug}, {@link Log#verbose}.
 *
 * Each message is sent to a log category, which is identified by a string. The log level
 * of each category can be set separately, allowing heigher or lower log levels to be
 * set for specific categories.
 *
 * The log messages that don't get filtered out because of their level are forwarded
 * to the log handler for that log level. The default log handlers will use the built-in
 * `console` functions to print the category in square brackets followed by the message.
 *
 * @example <caption>Show all messages and in color, except for own events</caption>
 * cct.log.setLogLevel('own-events', cct.log.NONE);
 * cct.log.setLogLevel(cct.log.VERBOSE);
 * cct.log.color = true;
 *
 * @example <caption>Logging an info message in the gizmo category</caption>
 * cct.log.info('gizmo', 'widget initialized');
 *
 * @abstract
 * @class Log
 */
function Log() {
  this._defaultLogLevel = this.WARNING;
  this._categoryLevels = {};
  this._logHandlers = {};
}

/**
 * @callback LogHandlerFunction
 *
 * @param {number} mask - The log level mask of the message.
 * @param {string} category - The message category.
 * @param {string} message - The log message.
 */

/**
 * Sets the log handler for one or more log levels. The handler will be called whenever
 * anything is logged that doesn't get filtered because of it's log level.
 *
 * Setting a log handler will replace the default log handler for that log level.
 *
 * @example <caption>Setting log handler for multiple levels</caption>
 * log.setLogHandler(log.ERROR|log.WARNING, function (mask, category, ...args) {
 *     ...
 * });
 *
 * @param {number} [levels=ALL] - A mask that describles which log levels the handler
 *  should be applied to. If omitted the handler will be used for all log levels.
 * @param {LogHandlerFunction} handler - The log handler that will be called.
 */
Log.prototype.setLogHandler = function (levels, handler) {
  if (arguments.length <= 1) {
    handler = levels;
    levels = this.ALL;
  }
  if (typeof levels !== 'number') {
    throw new TypeError('Log.setLogHandler: levels must be a number');
  }
  if (typeof handler !== 'function' && handler) {
    throw new TypeError('Log.setLogHandler: handler must be a function');
  }
  this.levels.forEach(function (level, index) {
    if (1 << index & levels) {
      this._logHandlers[level] = handler;
    }
  }.bind(this));
};

/**
 * Sets the log level either globally, or for a specific category.
 * The log handler will only be called for messages whose log level is
 * equal or lower than the log level for that category.
 *
 * The log level of any category is equal to the specific log level that has
 * been set for that category, and if none has been set, the gobal log level.
 *
 * @param {string} [category] - Optional log category to set the level of.
 *  If this is excluded, the global log level will be set instead.
 * @param {number} level - The new log level.
 */
Log.prototype.setLogLevel = function (category, level) {
  if (arguments.length <= 1) {
    level = category;
    if (typeof level !== 'number') {
      throw new TypeError('Log.setLogLevel: level must be a number');
    }
    this._defaultLogLevel = level;
  } else {
    if (typeof category !== 'string') {
      throw new TypeError('Log.setLogLevel: category must be a string');
    }
    if (typeof level !== 'number') {
      throw new TypeError('Log.setLogLevel: level must be a number');
    }
    this._categoryLevels[category] = level;
  }
};

function createLogFunction(level, mask) {
  return function (category, message) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('log.' + level, 'category', category);
    var logLevel = 0;
    if (typeof category !== 'string') {
      throw new TypeError('Log.' + level + ': category has to be a string');
    }
    if (category in this._categoryLevels) {
      logLevel = this._categoryLevels[category];
    } else {
      logLevel = this._defaultLogLevel;
    }
    if (logLevel < mask) {
      return;
    }
    if (typeof message === 'string') {
      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('log.' + level, 'message', message);
    } else {
      var object = message;
      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].object('log.' + level, 'object', object);

      var _args = args,
          _args2 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default()(_args),
          objectMessage = _args2[0],
          objectArgs = _args2.slice(1);

      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('log.' + level, 'object message', objectMessage);

      message = object + ' ' + objectMessage;
      args = objectArgs;
    }
    var handler = this._logHandlers[level];
    if (handler) {
      handler.call.apply(handler, [this, mask, category, message].concat(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toConsumableArray___default()(args)));
    }
  };
}

/**
 * An array of the names of all log levels, in lowercase.
 * @type {string[]}
 */
Log.prototype.levels = ['error', 'warning', 'info', 'debug', 'verbose'];

Log.prototype.levels.forEach(function (level, index) {
  var mask = 1 << index;
  Log.prototype[level.toUpperCase()] = mask;
  Log.prototype[level] = createLogFunction(level, mask);
});

/**
 * The error log function. Will call the error log handler if the log
 * level of the given category is set to error or higher.
 * @function Log#error
 * @param {string} category - The category of this log message
 * @param {...*} args - The rest of the arguments to pass to the log handler
 */
/**
 * The warning log function. Will call the warning log handler if the log
 * level of the given category is set to warning or higher.
 * @function Log#warning
 * @param {string} category - The category of this log message
 * @param {...*} args - The rest of the arguments to pass to the log handler
 */
/**
 * The info log function. Will call the info log handler if the log
 * level of the given category is set to info or higher.
 * @function Log#info
 * @param {string} category - The category of this log message
 * @param {...*} args - The rest of the arguments to pass to the log handler
 */
/**
 * The debug log function. Will call the debug log handler if the log
 * level of the given category is set to debug or higher.
 * @function Log#debug
 * @param {string} category - The category of this log message
 * @param {...*} args - The rest of the arguments to pass to the log handler
 */
/**
 * The verbose log function. Will call the verbose log handler if the log
 * level of the given category is set to verbose or higher.
 * @function Log#verbose
 * @param {string} category - The category of this log message
 * @param {...*} args - The rest of the arguments to pass to the log handler
 */

/**
 * Log level representing no logging at all.
 * @member {number} Log#NONE
 * @readonly
 */
/**
 * Error level.
 * @member {number} Log#ERROR
 * @readonly
 */
/**
 * Warning level.
 * @member {number} Log#WARNING
 * @readonly
 */
/**
 * Info level.
 * @member {number} Log#INFO
 * @readonly
 */
/**
 * Debug level.
 * @member {number} Log#DEBUG
 * @readonly
 */
/**
 * Verbose level.
 * @member {number} Log#VERBOSE
 * @readonly
 */
/**
 * Log level representing a mask of all log levels.
 * @member {number} Log#ALL
 * @readonly
 */

Log.prototype.NONE = 0;
Log.prototype.ALL = Log.prototype.levels.reduce(function (mask, ignored, index) {
  return mask | 1 << index;
}, 0);

var log = new Log();

/* harmony default export */ __webpack_exports__["default"] = (log);

function setLog(_log) {
  log = _log;
}

/**
 * Whether or not the default log handler should use color to represent log levels.
 * @member {boolean} Log#color
 */

var logFunctions = (_logFunctions = {}, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logFunctions, log.ERROR, (console.error || console.log).bind(console)), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logFunctions, log.WARNING, (console.warn || console.log).bind(console)), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logFunctions, log.INFO, (console.info || console.log).bind(console)), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logFunctions, log.DEBUG, (console.debug || console.log).bind(console)), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logFunctions, log.VERBOSE, console.log.bind(console)), _logFunctions);
var logColors = (_logColors = {}, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logColors, log.ERROR, '#F74333'), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logColors, log.WARNING, '#F79743'), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logColors, log.INFO, '#3343F7'), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logColors, log.DEBUG, '#43C733'), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_logColors, log.VERBOSE, '#F743F7'), _logColors);

function defaultLogHandler(level, category, message) {
  var _logFunctions$level;

  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }

  (_logFunctions$level = logFunctions[level]).call.apply(_logFunctions$level, [console, '[' + category + '] ' + message].concat(args));
}

function colorLogHandler(level, category, message) {
  for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
    args[_key3 - 3] = arguments[_key3];
  }

  if (this.color) {
    var _logFunctions$level2;

    (_logFunctions$level2 = logFunctions[level]).call.apply(_logFunctions$level2, [console, '%c[' + category + ']%c ' + message].concat(['color: ' + logColors[level], 'color:'], args));
  } else {
    var _logFunctions$level3;

    (_logFunctions$level3 = logFunctions[level]).call.apply(_logFunctions$level3, [console, '[' + category + '] ' + message].concat(args));
  }
}

log.color = false;
log.colors = logColors;

var defaultHandler;

if (__WEBPACK_IMPORTED_MODULE_4_common_utils__["isChrome"] || __WEBPACK_IMPORTED_MODULE_4_common_utils__["isFirefox"]) {
  defaultHandler = colorLogHandler;
} else {
  defaultHandler = defaultLogHandler;
}

log.setLogHandler(log.ALL, defaultHandler);
log.defaultHandler = defaultHandler;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(53)('wks')
  , uid        = __webpack_require__(37)
  , Symbol     = __webpack_require__(5).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(5)
  , core      = __webpack_require__(0)
  , ctx       = __webpack_require__(18)
  , hide      = __webpack_require__(16)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(101), __esModule: true };

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(14)
  , IE8_DOM_DEFINE = __webpack_require__(70)
  , toPrimitive    = __webpack_require__(55)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(11) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(96);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(62);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(33);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(33);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(21)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);



function optArgCheck(prop) {
  return function (context, name, value, extra) {
    if (value !== undefined && value !== null) {
      try {
        this[prop](context, name, value, extra);
      } catch (e) {
        e.message += ' if present';
        throw e;
      }
    }
    return value;
  };
}

var argCheck = {
  count: function count(context, requiredCount, actualCount) {
    if (requiredCount > actualCount) {
      throw new TypeError(context + ' requires at least' + requiredCount + ' arguments');
    }
  },
  error: function error(context, name, criteria) {
    if ((typeof context === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(context)) === 'object') {
      context = context.constructor && context.constructor.name || 'Unknown';
      context += ' constructor';
    }
    throw new TypeError(context + ': argument \'' + name + '\' must ' + criteria);
  },
  optObject: optArgCheck('object'),
  object: function object(context, name, value) {
    if ((typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(value)) !== 'object') {
      this.error(context, name, 'be an object');
    } else if (value === null) {
      this.error(context, name, 'be an object, not null');
    } else if (Array.isArray(value)) {
      this.error(context, name, 'be an object, not an array');
    } else if (value instanceof RegExp) {
      this.error(context, name, 'be an object, not a RegExp instance');
    }
    return value;
  },
  optInstance: optArgCheck('instance'),
  instance: function instance(context, name, value, constructor) {
    if (!constructor) {
      throw new Error('Failed instance argument check for ' + name + ' in ' + context + ', constructor is ' + constructor + '.');
    }
    if (Array.isArray(constructor)) {
      var atLeastOneMatch = constructor.some(function (constructor) {
        return value instanceof constructor;
      });
      if (!atLeastOneMatch) {
        var names = constructor.map(function (constructor) {
          return constructor.name;
        }).join(', ');
        this.error(context, name, 'be an instance of any of ' + names);
      }
    } else if (!(value instanceof constructor)) {
      this.error(context, name, 'be an instance of ' + constructor.name);
    }
    return value;
  },

  optFunc: optArgCheck('func'),
  func: function func(context, name, value) {
    if (typeof value !== 'function') {
      this.error(context, name, 'be a function');
    }
    return value;
  },
  optArray: optArgCheck('array'),
  array: function array(context, name, value) {
    if (!Array.isArray(value)) {
      this.error(context, name, 'be an array');
    }
    return value;
  },
  optString: optArgCheck('string'),
  string: function string(context, name, value) {
    if (typeof value !== 'string') {
      this.error(context, name, 'be a string');
    } else if (value === '') {
      this.error(context, name, 'not be an empty string');
    }
    return value;
  },
  optStringOrEmpty: optArgCheck('string'),
  stringOrEmpty: function stringOrEmpty(context, name, value) {
    if (typeof value !== 'string') {
      this.error(context, name, 'be a string');
    }
    return value;
  },
  optValues: optArgCheck('values'),
  values: function values(context, name, value, _values) {
    if (_values.indexOf(value) === -1) {
      this.error(context, name, 'be one of ' + _values.join(', '));
    }
    return value;
  },
  optNumber: optArgCheck('number'),
  number: function number(context, name, value) {
    if (isNaN(value)) {
      this.error(context, name, 'not be NaN');
    } else if (!isFinite(value)) {
      this.error(context, name, 'not be Infinite');
    } else if (typeof value !== 'number') {
      this.error(context, name, 'be a number');
    }
    return value;
  },
  optBoolean: optArgCheck('boolean'),
  boolean: function boolean(context, name, value) {
    if (typeof value !== 'boolean') {
      this.error(context, name, 'be a boolean');
    }
    return value;
  },
  options: function options(context, name, value) {
    this.object(context, name, value);
    return new OptionsArgChecker(context, name, value);
  },
  optOptions: function optOptions(context, name, value) {
    if (value !== undefined) {
      try {
        return this.options(context, name, value);
      } catch (e) {
        e.message += ' if present';
        throw e;
      }
    }
    return new OptionsArgChecker(0, 0, 0, true);
  }
};

/* harmony default export */ __webpack_exports__["a"] = (argCheck);

function OptionsArgChecker(context, name, value, empty) {
  this.context = context;
  this.name = name;
  this.value = value;
  this.empty = empty;
}

function optOptionsArgCheck(type) {
  return function (prop, extra) {
    if (!this.empty && prop in this.value) {
      if (this.value[prop] !== undefined && this.value[prop] !== null) {
        try {
          this[type](prop, extra);
        } catch (e) {
          e.message += ' if present';
          throw e;
        }
      }
    }
    return this;
  };
}

OptionsArgChecker.prototype = {
  optObject: optOptionsArgCheck('object'),
  object: function object(prop) {
    if (!this.empty) {
      argCheck.object(this.context, this.name + '.' + prop, this.value[prop]);
    }
    return this;
  },
  optInstance: optOptionsArgCheck('instance'),
  instance: function instance(prop, constructor) {
    if (!this.empty) {
      argCheck.instance(this.context, this.name + '.' + prop, this.value[prop], constructor);
    }
    return this;
  },
  optFunc: optOptionsArgCheck('func'),
  func: function func(prop) {
    if (!this.empty) {
      argCheck.func(this.context, this.name + '.' + prop, this.value[prop]);
    }
    return this;
  },
  optArray: optOptionsArgCheck('array'),
  array: function array(prop) {
    if (!this.empty) {
      argCheck.array(this.context, this.name + '.' + prop, this.value[prop]);
    }
    return this;
  },
  optString: optOptionsArgCheck('string'),
  string: function string(prop) {
    if (!this.empty) {
      argCheck.string(this.context, this.name + '.' + prop, this.value[prop]);
    }
    return this;
  },
  optStringOrEmpty: optOptionsArgCheck('stringOrEmpty'),
  stringOrEmpty: function stringOrEmpty(prop) {
    if (!this.empty) {
      argCheck.stringOrEmpty(this.context, this.name + '.' + prop, this.value[prop]);
    }
    return this;
  },
  optValues: optOptionsArgCheck('values'),
  values: function values(prop, _values2) {
    if (!this.empty) {
      argCheck.values(this.context, this.name + '.' + prop, this.value[prop], _values2);
    }
    return this;
  },
  optNumber: optOptionsArgCheck('number'),
  number: function number(prop) {
    if (!this.empty) {
      argCheck.number(this.context, this.name + '.' + prop, this.value[prop]);
    }
    return this;
  },
  optBoolean: optOptionsArgCheck('boolean'),
  boolean: function boolean(prop) {
    if (!this.empty) {
      argCheck.boolean(this.context, this.name + '.' + prop, this.value[prop]);
    }
    return this;
  }
};

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["find"] = find;
/* harmony export (immutable) */ __webpack_exports__["fill"] = fill;
/* harmony export (immutable) */ __webpack_exports__["filter"] = filter;
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;
/* harmony export (immutable) */ __webpack_exports__["map"] = map;
/* harmony export (immutable) */ __webpack_exports__["mapValues"] = mapValues;
/* harmony export (immutable) */ __webpack_exports__["values"] = values;
/* harmony export (immutable) */ __webpack_exports__["diff"] = diff;
/* harmony export (immutable) */ __webpack_exports__["toArray"] = toArray;
/* harmony export (immutable) */ __webpack_exports__["hiddenProp"] = hiddenProp;
/* harmony export (immutable) */ __webpack_exports__["prop"] = prop;
/* harmony export (immutable) */ __webpack_exports__["getter"] = getter;
/* harmony export (immutable) */ __webpack_exports__["range"] = range;
/* harmony export (immutable) */ __webpack_exports__["defer"] = defer;
/* harmony export (immutable) */ __webpack_exports__["shallowCopy"] = shallowCopy;
/* harmony export (immutable) */ __webpack_exports__["assign"] = assign;
/* harmony export (immutable) */ __webpack_exports__["wait"] = wait;
/* harmony export (immutable) */ __webpack_exports__["randomString"] = randomString;
/* harmony export (immutable) */ __webpack_exports__["arrayBufferSha1IfSupported"] = arrayBufferSha1IfSupported;
/* harmony export (immutable) */ __webpack_exports__["base64ToUtf8"] = base64ToUtf8;
/* harmony export (immutable) */ __webpack_exports__["utf8ToBase64"] = utf8ToBase64;
/* harmony export (immutable) */ __webpack_exports__["urlSafeBase64ToUtf8"] = urlSafeBase64ToUtf8;
/* harmony export (immutable) */ __webpack_exports__["utf8ToUrlSafeBase64"] = utf8ToUrlSafeBase64;
/* harmony export (immutable) */ __webpack_exports__["binaryStringToArrayBuffer"] = binaryStringToArrayBuffer;
/* harmony export (immutable) */ __webpack_exports__["unicodeStringToArrayBuffer"] = unicodeStringToArrayBuffer;
/* harmony export (immutable) */ __webpack_exports__["arrayBufferToBinaryString"] = arrayBufferToBinaryString;
/* harmony export (immutable) */ __webpack_exports__["arrayBufferToUnicodeString"] = arrayBufferToUnicodeString;
/* harmony export (immutable) */ __webpack_exports__["parseDataUri"] = parseDataUri;
/* harmony export (immutable) */ __webpack_exports__["blobToArrayBuffer"] = blobToArrayBuffer;
/* harmony export (immutable) */ __webpack_exports__["bufferToFile"] = bufferToFile;
/* harmony export (immutable) */ __webpack_exports__["bufferToHex"] = bufferToHex;
/* harmony export (immutable) */ __webpack_exports__["hexToBuffer"] = hexToBuffer;
/* harmony export (immutable) */ __webpack_exports__["concatenateArrayBuffers"] = concatenateArrayBuffers;
/* harmony export (immutable) */ __webpack_exports__["noVendor"] = noVendor;
/* harmony export (immutable) */ __webpack_exports__["registerInstance"] = registerInstance;
/* harmony export (immutable) */ __webpack_exports__["unregisterInstance"] = unregisterInstance;
/* harmony export (immutable) */ __webpack_exports__["priv"] = priv;
/* harmony export (immutable) */ __webpack_exports__["assertPriv"] = assertPriv;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFirefox", function() { return isFirefox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isChrome", function() { return isChrome; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return browser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIE", function() { return isIE; });
/* harmony export (immutable) */ __webpack_exports__["isObject"] = isObject;
/* harmony export (immutable) */ __webpack_exports__["notInNode"] = notInNode;
/* harmony export (immutable) */ __webpack_exports__["maybeConvertStringToNumber"] = maybeConvertStringToNumber;
/* harmony export (immutable) */ __webpack_exports__["getStringByteLength"] = getStringByteLength;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReadOnlyMap", function() { return ReadOnlyMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReadOnlySet", function() { return ReadOnlySet; });
/* harmony export (immutable) */ __webpack_exports__["createTimedBuffer"] = createTimedBuffer;
/* harmony export (immutable) */ __webpack_exports__["errorForwarder"] = errorForwarder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_typeof__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_core_js_object_create__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_define_property__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_define_property___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_define_property__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_babel_runtime_core_js_object_keys__);















function find(collection, func, thisArg) {
  for (var key in collection) {
    if (collection.hasOwnProperty(key)) {
      if (func.call(thisArg, collection[key], key, collection)) {
        return collection[key];
      }
    }
  }
  return null;
}

function fill(array) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  var len = array.length | 0;

  for (var i = 0; i < len; i += 1) {
    array[i] = value;
  }

  return array;
}

function filter(collection, func, thisArg) {
  var arr = [];
  for (var key in collection) {
    if (collection.hasOwnProperty(key)) {
      if (func.call(thisArg, collection[key], key, collection)) {
        arr.push(collection[key]);
      }
    }
  }
  return arr;
}

function forEach(collection, func, thisArg) {
  for (var key in collection) {
    if (collection.hasOwnProperty(key)) {
      func.call(thisArg, collection[key], key, collection);
    }
  }
}

function map(collection, func, thisArg) {
  var arr = [];
  for (var key in collection) {
    if (collection.hasOwnProperty(key)) {
      arr.push(func.call(thisArg, collection[key], key, collection));
    }
  }
  return arr;
}

function mapValues(collection, func, thisArg) {
  var obj = {};
  for (var key in collection) {
    if (collection.hasOwnProperty(key)) {
      obj[key] = func.call(thisArg, collection[key], key, collection);
    }
  }
  return obj;
}

function values(collection) {
  if (!collection) {
    return [];
  }
  if (Array.isArray(collection)) {
    throw new TypeError('tried to call utils.values() on array');
  }
  return __WEBPACK_IMPORTED_MODULE_12_babel_runtime_core_js_object_keys___default()(collection).map(function (key) {
    return collection[key];
  });
}

function diff(collection1, collection2) {
  var set1 = new __WEBPACK_IMPORTED_MODULE_11_babel_runtime_core_js_set___default.a(collection1);
  var set2 = new __WEBPACK_IMPORTED_MODULE_11_babel_runtime_core_js_set___default.a(collection2);
  var added = [];
  var removed = [];
  set1.forEach(function (element) {
    if (!set2.has(element)) {
      removed.push(element);
    }
  });
  set2.forEach(function (element) {
    if (!set1.has(element)) {
      added.push(element);
    }
  });
  return [added, removed];
}

function toArray(arrayLike) {
  var arr = [];
  for (var i = 0; i < arrayLike.length; i += 1) {
    arr[i] = arrayLike[i];
  }
  return arr;
}

function hiddenProp(obj, name, value) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_define_property___default()(obj, name, {
    enumerable: false,
    configurable: true,
    writable: false,
    value: value
  });
}

function prop(obj, name, func) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_define_property___default()(obj, name, {
    enumerable: true,
    configurable: false,
    writable: false,
    value: func
  });
}

function getter(obj, name, func) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_define_property___default()(obj, name, {
    enumerable: true,
    configurable: false,
    get: func
  });
}

function range(from, to, step) {
  if (arguments.length === 1) {
    to = from;
    from = 0;
    step = 1;
  } else if (arguments.length === 2) {
    step = 1;
  }
  var arr = [];
  for (var i = from; i < to; i += step) {
    arr.push(i);
  }
  return arr;
}

function defer() {
  var deferred = {};
  deferred.promise = new __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

function shallowCopy(obj, keys) {
  if (!obj) {
    return null;
  }
  var result = {};
  var key;
  if (keys) {
    for (var index in keys) {
      key = keys[index];
      result[key] = obj[key];
    }
  } else {
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        result[key] = obj[key];
      }
    }
  }
  return result;
}

function assign(obj, other, keys) {
  if (!obj) {
    return null;
  }
  if (!other) {
    return obj;
  }
  var key;
  if (keys) {
    for (var index in keys) {
      key = keys[index];
      obj[key] = other[key];
    }
  } else {
    for (key in other) {
      if (other.hasOwnProperty(key)) {
        obj[key] = other[key];
      }
    }
  }
  return obj;
}

function wait(time) {
  return function () {
    var args = arguments;
    return new __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_promise___default.a(function (resolve) {
      setTimeout(function () {
        resolve.apply(null, args);
      }, time);
    });
  };
}

function randomString(size) {
  var array = null;
  var now;
  var i;
  var crypto = noVendor(globalObject, 'crypto');
  if (false) {
    array = require('crypto').randomBytes(size);
  } else if (crypto && window.Uint8Array) {
    array = new window.Uint8Array(size);
    crypto.getRandomValues(array);
  } else {
    now = new Date().getTime();
    array = [];
    for (i = 0; i < size; i += 1) {
      array[i] = Math.random() * now & 255;
    }
  }

  var rawString = String.fromCharCode.apply(null, array);
  var base64String = utf8ToBase64(rawString);
  return base64String.replace(/\-_/g, '').slice(0, size);
}

function arrayBufferSha1IfSupported(arrayBuffer) {
  var subtleCrypto = window.crypto && window.crypto.subtle;
  if (subtleCrypto && subtleCrypto.digest) {
    return subtleCrypto.digest('SHA-1', arrayBuffer);
  }
  return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_promise___default.a.resolve(null);
}

function base64ToUtf8(base64) {
  if (false) {
    /* global global */
    return global.Buffer.from(base64, 'base64').toString('utf8');
  } else {
    return atob(base64);
  }
}

function utf8ToBase64(utf8) {
  if (false) {
    /* global global */
    return global.Buffer.from(utf8, 'utf8').toString('base64');
  } else {
    return btoa(utf8);
  }
}

function urlSafeBase64ToUtf8(urlSafeBase64) {
  return base64ToUtf8(urlSafeBase64.replace(/[-_]/g, charFromUrlSafeBase64));
}

function utf8ToUrlSafeBase64(utf8) {
  return utf8ToBase64(utf8).replace(/[+/=]/g, charToUrlSafeBase64);
}

function charToUrlSafeBase64(char) {
  switch (char) {
    case '+':
      return '-';
    case '/':
      return '_';
  }
  return '';
}

function charFromUrlSafeBase64(char) {
  switch (char) {
    case '-':
      return '+';
    case '_':
      return '/';
  }
  return '';
}

function binaryStringToArrayBuffer(binaryString) {
  var buffer = new ArrayBuffer(binaryString.length);
  var view = new Uint8Array(buffer);
  var length = binaryString.length;
  for (var i = 0; i < length; i += 1) {
    view[i] = binaryString.charCodeAt(i);
  }
  return buffer;
}

function unicodeStringToArrayBuffer(unicodeString) {
  var buffer = new ArrayBuffer(unicodeString.length * 2);
  var view = new Uint16Array(buffer);
  var length = unicodeString.length;
  for (var i = 0; i < length; i += 1) {
    view[i] = unicodeString.charCodeAt(i);
  }
  return buffer;
}

function bufferViewToString(view) {
  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0x1000;

  var length = view.length;
  var result = '';
  for (var i = 0; i < length; i += chunkSize) {
    result += String.fromCharCode.apply(null, view.subarray(i, i + chunkSize));
  }
  return result;
}

function arrayBufferToBinaryString(buffer) {
  var view = new Uint8Array(buffer.buffer || buffer, buffer.byteOffset, buffer.byteLength);
  return bufferViewToString(view);
}

function arrayBufferToUnicodeString(buffer) {
  var view = new Uint16Array(buffer.buffer || buffer, buffer.byteOffset, buffer.byteLength >> 1);
  return bufferViewToString(view);
}

function parseDataUri(dataUri) {
  var split = dataUri.split(/:|;|,/g);
  if (split[0] !== 'data') {
    throw new Error('invalid data uri: ' + dataUri.slice(0, 100));
  }
  if (split[2] !== 'base64') {
    throw new Error('invalid data uri: ' + dataUri.slice(0, 100));
  }
  return {
    mimeType: split[1],
    binaryString: base64ToUtf8(split[3])
  };
}

function blobToArrayBuffer(blob) {
  var reader = new FileReader();
  return new __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(blob);
  });
}

function bufferToFile(buffer, fileName, mimeType) {
  var file = new Blob([buffer], {
    type: mimeType
  });
  file.name = fileName;
  file.lastModifiedDate = new Date();
  return file;
}

function bufferToHex(buffer) {
  var view = new Uint8Array(buffer);
  return Array.prototype.map.call(view, function (x) {
    return ('00' + x.toString(16)).slice(-2);
  }).join('');
}

function hexToBuffer(hex) {
  if (hex.length % 2 !== 0) {
    throw new TypeError('hexToBuffer: hex length must be even');
  }
  var buffer = new Uint8Array(hex.length / 2);
  for (var i = 0; hex.substr(i, 2); i += 2) {
    buffer[i / 2] = parseInt(hex.substr(i, 2), 16);
  }
  return buffer;
}

function concatenateArrayBuffers(buffers) {
  var totalLength = 0;
  for (var index in buffers) {
    totalLength += buffers[index].byteLength;
  }

  var result = new Uint8Array(totalLength);
  var offset = 0;
  for (var _index in buffers) {
    var view = new Uint8Array(buffers[_index]);
    result.set(view, offset);
    offset += view.byteLength;
  }

  return result;
}

function noVendor(obj, name) {
  var upper = name[0].toUpperCase() + name.slice(1);
  var unprefixed = obj[name] || obj['moz' + upper] || obj['webkit' + upper] || obj['ms' + upper];
  if (!unprefixed) {
    return null;
  }
  if (typeof unprefixed === 'function') {
    return unprefixed.bind(obj);
  } else {
    return unprefixed;
  }
}

var globalObject;
if (false) {
  /* global global */
  globalObject = global;
} else {
  globalObject = window;
}

if (globalObject) {
  globalObject.__C3_SDK_INSTANCES__ = {
    listeners: new __WEBPACK_IMPORTED_MODULE_11_babel_runtime_core_js_set___default.a(),
    addListener: function addListener(listener) {
      this.listeners.add(listener);
    },
    removeListener: function removeListener(listener) {
      this.listeners.delete(listener);
    }
  };
}

function registerInstance(collectionName, instance) {
  if (globalObject) {
    var collection = globalObject.__C3_SDK_INSTANCES__[collectionName];
    if (!collection) {
      globalObject.__C3_SDK_INSTANCES__[collectionName] = [instance];
    } else if (collection.indexOf(instance) === -1) {
      collection.push(instance);
    }
    globalObject.__C3_SDK_INSTANCES__.listeners.forEach(function (listener) {
      listener('added', collectionName, instance);
    });
  }
}

function unregisterInstance(collectionName, instance) {
  if (globalObject) {
    var collection = globalObject.__C3_SDK_INSTANCES__[collectionName];
    var index = collection.indexOf(instance);
    if (index !== -1) {
      collection.splice(index, 1);
    }
    globalObject.__C3_SDK_INSTANCES__.listeners.forEach(function (listener) {
      listener('removed', collectionName, instance);
    });
  }
}

function priv(constructor) {
  var args = [priv];
  var len = arguments.length;
  for (var i = 1; i < len; i += 1) {
    args[i] = arguments[i];
  }
  var instance = __WEBPACK_IMPORTED_MODULE_8_babel_runtime_core_js_object_create___default()(constructor.prototype);
  constructor.apply(instance, args);
  return instance;
}

function assertPriv(name, providedPriv) {
  if (priv !== providedPriv) {
    throw new TypeError(name + ': cannot be used as a constructor');
  }
}

var isFirefox = /firefox/i.test(typeof navigator !== 'undefined' && navigator.userAgent);
var isGoogle = /google inc/i.test(typeof navigator !== 'undefined' && navigator.vendor);
var isChrome = isGoogle && /chrome/i.test(typeof navigator !== 'undefined' && navigator.userAgent);
var browser = isChrome ? 'chrome' : isFirefox ? 'firefox' : 'other';
// Internet Explorer 6-11
var isIE = /* @cc_on!@*/false || !!globalObject.document && !!globalObject.document.documentMode;

function isObject(obj) {
  return (typeof obj === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_typeof___default()(obj)) === 'object' && obj !== null && !Array.isArray(obj) && !(obj instanceof RegExp);
}

function notInNode(thing) {
  if (false) {
    throw new TypeError(thing + ' is not available in NodeJS');
  }
}

function maybeConvertStringToNumber(string) {
  if (!isNaN(string)) {
    if (Number(string) % 1 === 0) {
      return parseInt(string);
    }
    return parseFloat(string);
  }
  return string;
}

function getStringByteLength(string) {
  var bytes = string.length;
  for (var i = string.length - 1; i >= 0; i -= 1) {
    var charCode = string.charCodeAt(i);
    if (charCode > 0x7f && charCode <= 0x7ff) {
      bytes += 1;
    } else if (charCode > 0x7ff && charCode <= 0xffff) {
      bytes += 2;
    }if (charCode >= 0xDC00 && charCode <= 0xDFFF) {
      // trailing surrogate
      i -= 1;
    }
  }
  return bytes;
}

/**
 * A read-only version of the built-in Map class.
 *
 * @class ReadOnlyMap
 */
var ReadOnlyMap = function (_Map) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(ReadOnlyMap, _Map);

  function ReadOnlyMap() {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, ReadOnlyMap);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ReadOnlyMap.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ReadOnlyMap)).call(this));

    if (arguments.length) {
      throw new TypeError('ReadOnlyMap does not support constructor arguments');
    }
    return _this;
  }

  /**
   * The number of entries in the map.
   *
   * @member {number} ReadOnlyMap#size
   */

  /**
   * Provides a way to iterate through all the entries in this map. Each entry is represented
   * by an array with two elements, were the first element is the key and the second is the value.
   *
   * @function ReadOnlyMap#entries
   * @returns {Iterator<Array<*>>} - An iterator of all entries in this map.
   */

  /**
   * Provited a way to iterate though all the keys in this map.
   *
   * @function ReadOnlyMap#keys
   * @returns {Iterator<*>} - An iterator of all keys in this map.
   */

  /**
   * Provited a way to iterate though all the values in this map.
   *
   * @function ReadOnlyMap#values
   * @returns {Iterator<*>} - An iterator of all values in this map.
   */

  /**
   * Returns the value for the given key.
   *
   * @function ReadOnlyMap#get
   * @param {*} key - The key of the value to retreive.
   * @returns {*} The value, if it exists, `undefined` otherwise
   */

  /**
   * Returns true if the map has an entry for the given key.
   *
   * @function ReadOnlyMap#has
   * @param {*} key - The key to look for.
   */

  /**
   * Synchronously calls an interator function once for each entry in the map.
   *
   * Errors thrown inside the iterator function will cancel the iteration
   *
   * @function ReadOnlyMap#forEach
   * @param {ReadOnlyMapForEachCallback} func - The iterator function.
   * @param {*} [thisArg] - The value to use as `this` inside the iterator function.
   */

  /**
   * The iterator function passed to {@link ReadOnlyMap#forEach}.
   *
   * @callback ReadOnlyMapForEachCallback
   * @param {*} key - The key of the current entry.
   * @param {*} value - The value of the current entry.
   * @param {ReadOnlyMap} map - The map itself.
   */

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(ReadOnlyMap, [{
    key: 'set',
    value: function set() {
      throw new TypeError('Map is read-only');
    }
  }, {
    key: 'delete',
    value: function _delete() {
      throw new TypeError('Map is read-only');
    }
  }, {
    key: 'clear',
    value: function clear() {
      throw new TypeError('Map is read-only');
    }

    /* private */

  }, {
    key: '_set',
    value: function _set(key, value) {
      return __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default()(ReadOnlyMap.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ReadOnlyMap.prototype), 'set', this).call(this, key, value);
    }
  }, {
    key: '_delete',
    value: function _delete(key) {
      return __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default()(ReadOnlyMap.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ReadOnlyMap.prototype), 'delete', this).call(this, key);
    }
  }, {
    key: '_clear',
    value: function _clear() {
      return __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default()(ReadOnlyMap.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ReadOnlyMap.prototype), 'clear', this).call(this);
    }
  }]);

  return ReadOnlyMap;
}(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a);

var ReadOnlySet = function (_Set2) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(ReadOnlySet, _Set2);

  function ReadOnlySet() {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, ReadOnlySet);

    var _this2 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ReadOnlySet.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ReadOnlySet)).call(this));

    if (arguments.length) {
      throw new TypeError('ReadOnlySet does not support constructor arguments');
    }
    return _this2;
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(ReadOnlySet, [{
    key: 'add',
    value: function add() {
      throw new TypeError('Set is read-only');
    }
  }, {
    key: 'delete',
    value: function _delete() {
      throw new TypeError('Set is read-only');
    }
  }, {
    key: 'clear',
    value: function clear() {
      throw new TypeError('Set is read-only');
    }
  }, {
    key: '_add',
    value: function _add(value) {
      return __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default()(ReadOnlySet.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ReadOnlySet.prototype), 'add', this).call(this, value);
    }
  }, {
    key: '_delete',
    value: function _delete(value) {
      return __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default()(ReadOnlySet.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ReadOnlySet.prototype), 'delete', this).call(this, value);
    }
  }, {
    key: '_clear',
    value: function _clear() {
      return __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default()(ReadOnlySet.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ReadOnlySet.prototype), 'clear', this).call(this);
    }
  }]);

  return ReadOnlySet;
}(__WEBPACK_IMPORTED_MODULE_11_babel_runtime_core_js_set___default.a);

function createTimedBuffer(time, callback) {
  var args = [];
  var timeout = 0;
  return function (arg) {
    args.push(arg);
    if (!timeout) {
      timeout = setTimeout(onTimeout, time);
    }
    function onTimeout() {
      timeout = 0;
      try {
        callback(args);
      } catch (error) {
        console.error('error in timed buffer callback: ' + error);
      }
      args = [];
    }
  };
}

function errorForwarder(handler, location) {
  return function (error) {
    if (!location) {
      handler(error);
    } else {
      var newError = new Error('Error in ' + location + ': ' + error.message);
      newError.reason = error;
      handler(newError);
    }
  };
}

/**
 * Types that can be serialized as JSON.
 *
 * This is identical to the parameters that can be passed to the built-in `JSON.stringify`.
 * Circular references are not allowed, and `toJSON` methods will be used.
 *
 * @typedef JsonTypes {string|number|boolean|null|Array<JsonTypes>|Object<JsonTypes>}
 */

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(17);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(67)
  , defined = __webpack_require__(34);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(8)
  , createDesc = __webpack_require__(27);
module.exports = __webpack_require__(11) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(63);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 19 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 20 */,
/* 21 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(136), __esModule: true };

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(117)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(49)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(77)
  , enumBugKeys = __webpack_require__(48);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(34);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(8).f
  , has = __webpack_require__(19)
  , TAG = __webpack_require__(4)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(120);
var global        = __webpack_require__(5)
  , hide          = __webpack_require__(16)
  , Iterators     = __webpack_require__(24)
  , TO_STRING_TAG = __webpack_require__(4)('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

/***/ }),
/* 30 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(79);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(134), __esModule: true };

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _iterator = __webpack_require__(94);

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = __webpack_require__(87);

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};

/***/ }),
/* 34 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(14)
  , dPs         = __webpack_require__(95)
  , enumBugKeys = __webpack_require__(48)
  , IE_PROTO    = __webpack_require__(52)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(60)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(83).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(54)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 37 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_core_js_object_assign__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_core_js_object_assign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_core_js_object_assign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_object_get_own_property_names__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_object_get_own_property_names___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_object_get_own_property_names__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_create__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_common_argCheck__ = __webpack_require__(12);
















var DEFAULT_LISTENER_LIMIT = 10;
function LEAK_MESSAGE(limit) {
  return 'Listener leak: added more than ' + limit + ' listeners for a single event.  This limit can be changed' + ' by setting the LISTENER_LIMIT property on the emitter object.';
}

/**
 * @mixin EventEmitter
 */
var emitterPrototype = function () {
  var Base = EmitterMixin(null);
  var emitter = __WEBPACK_IMPORTED_MODULE_10_babel_runtime_core_js_object_create___default()(null);
  __WEBPACK_IMPORTED_MODULE_9_babel_runtime_core_js_object_get_own_property_names___default()(Base.prototype).forEach(function (name) {
    if (name !== 'constructor') {
      emitter[name] = Base.prototype[name];
    }
  });
  return emitter;
}();

function EmitterMixin() {
  var superclass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

  if (arguments.length === 0) {
    return __WEBPACK_IMPORTED_MODULE_8_babel_runtime_core_js_object_assign___default()(this, emitterPrototype);
  }

  return function (_superclass) {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default()(_class, _superclass);

    function _class() {
      __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, _class);

      return __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default()(this, (_class.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(_class)).apply(this, arguments));
    }

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(_class, [{
      key: '_listeners',
      value: function _listeners() {
        if (!this.__listeners) {
          this.__listeners = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default.a();
        }
        return this.__listeners;
      }
      /**
       * Adds a new listener for an event. All listeners will be called in the order in
       * which they were added. Adding an already added listener is not an error and will
       * result in the listener being called multiple times.
       *
       * @function EventEmitter#on
       * @param {eventType} eventType - The event to listen for.
       * @param {Function} listener - A function that will be called whenever the event is emitted.
       * @returns {EventEmitter} Itself, to allow chained calls.
       */

    }, {
      key: 'on',
      value: function on(eventType, listener) {
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].count('EventEmitter.on', 2, arguments.length);
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('EventEmitter.on', 'eventType', eventType);
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].func('EventEmitter.on', 'listener', listener);
        var listeners = this._listeners().get(eventType);

        var deprecationMessage = this.constructor._deprecatedEvents && this.constructor._deprecatedEvents[eventType];
        if (deprecationMessage) {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].warning('deprecated', deprecationMessage('on'));
        }

        if (!listeners) {
          listeners = [];
          this._listeners().set(eventType, listeners);
        }
        var element = {
          remaining: -1,
          func: listener
        };
        if (listeners.iterating) {
          if (!listeners.pending) {
            listeners.pending = [];
          }
          listeners.pending.push(element);
        } else {
          listeners.push(element);
        }
        var limit = this.LISTENER_LIMIT;
        limit = typeof limit === 'number' ? limit : DEFAULT_LISTENER_LIMIT;
        if (listeners.length > limit) {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].warning('emitter', LEAK_MESSAGE(limit), this);
        }
        return this;
      }

      /**
       * Works like {@link EventEmitter#on on}, but the listener is at most called once, and then removed.
       * If no callback is passed, a promise will be returned instead.
       *
       * @function EventEmitter#once
       * @param {eventType} eventType - The event to listen for.
       * @param {Function} [listener=null] - A function that will be called whenever the event is emitted.
       * @returns {EventEmitter|Promise} Itself, or a promise if no callback was passed.
       */

    }, {
      key: 'once',
      value: function once(eventType, listener) {
        var _this2 = this;

        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].count('EventEmitter.once', 1, arguments.length);
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('EventEmitter.once', 'eventType', eventType);
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].optFunc('EventEmitter.once', 'listener', listener);

        var deprecationMessage = this.constructor._deprecatedEvents && this.constructor._deprecatedEvents[eventType];
        if (deprecationMessage) {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].warning('deprecated', deprecationMessage('once'));
        }

        if (listener) {
          var newListeners = (this._listeners().get(eventType) || []).concat({
            remaining: 1,
            func: listener
          });
          this._listeners().set(eventType, newListeners);
          var listenerCount = this._listeners().get(eventType).length;
          var limit = this.LISTENER_LIMIT;
          limit = typeof limit === 'number' ? limit : DEFAULT_LISTENER_LIMIT;
          if (listenerCount > limit) {
            __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].warning('emitter', LEAK_MESSAGE(limit), this);
          }
          return this;
        } else {
          return new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a(function (resolve) {
            var newListeners = (_this2._listeners().get(eventType) || []).concat({
              remaining: 1,
              func: resolve
            });
            _this2._listeners().set(eventType, newListeners);
          });
        }
      }

      /**
       * Removes a listener associated with an event. At most one listener is removed, if the
       * same listener has been added multiple times, only the first listener is removed.
       *
       * @function EventEmitter#off
       * @param {eventType} eventType - The event type from which to remove the listener(s).
       * @param {Function} [listener] - The listener that should be removed. If omitted,
       * all listeners for the event type are removed.
       * @returns {EventEmitter} Itself, to allow chained calls.
       */

    }, {
      key: 'off',
      value: function off(eventType, listener) {
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].count('EventEmitter.off', 1, arguments.length);
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('EventEmitter.off', 'eventType', eventType);
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].func('EventEmitter.off', 'listener', listener);

        var deprecationMessage = this.constructor._deprecatedEvents && this.constructor._deprecatedEvents[eventType];
        if (deprecationMessage) {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].warning('deprecated', deprecationMessage('off'));
        }

        var listeners;
        var i;
        listeners = this._listeners().get(eventType);
        if (listeners) {
          for (i = 0; i < listeners.length; i += 1) {
            if (listeners[i].func === listener) {
              if (listeners.iterating) {
                if (listeners[i].remaining === 0) {
                  continue;
                }
                listeners[i].remaining = 0;
              } else {
                listeners.splice(i, 1);
              }
              return this;
            }
          }
        }
        return this;
      }
    }, {
      key: '_clearListeners',
      value: function _clearListeners(eventType) {
        if (eventType) {
          this._listeners().delete(eventType);
        } else {
          this._listeners().clear();
        }
      }

      /**
       * @function EventEmitter#_getListeners
       * @private
       * @param {eventType} eventType - The event type to fetch the listeners for.
       * @returns {EventEmitter} All listeners for the given event type.
       */

    }, {
      key: '_getListeners',
      value: function _getListeners(eventType) {
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].count('EventEmitter.listeners', 1, arguments.length);
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('EventEmitter.listeners', 'eventType', eventType);
        return (this._listeners().get(eventType) || []).filter(function (obj) {
          return obj.remaining;
        }).map(function (obj) {
          return obj.func;
        });
      }

      // eventType, args...

    }, {
      key: '_emit',
      value: function _emit(arg) {
        var eventType = arg.eventType || arg;
        var defaultHandler = arg.defaultHandler;
        var listeners = this._listeners().get(eventType);
        if (!listeners && !defaultHandler) {
          return;
        }

        var args = [];
        var i;
        for (i = 1; i < arguments.length; i += 1) {
          args[i - 1] = arguments[i];
        }

        if (!listeners) {
          defaultHandler.apply(this, args);
          return;
        }
        var called = false;

        listeners.iterating = true;
        for (i = 0; i < listeners.length; i += 1) {
          var listener = listeners[i];
          if (listener.remaining !== 0) {
            if (listener.remaining > 0) {
              listener.remaining -= 1;
            }
            try {
              listener.func.apply(this, args);
              called = true;
            } catch (error) {
              __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].error('emitter', 'Error in event listener, ' + error + ' ' + (error.stack ? error.stack + '\n' : ''));
            }
          }
        }
        listeners.iterating = false;

        for (i = listeners.length - 1; i >= 0; i -= 1) {
          if (listeners[i].remaining === 0) {
            listeners.splice(i, 1);
          }
        }

        if (listeners.pending) {
          listeners.push.apply(listeners, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(listeners.pending));
          delete listeners.pending;
        }

        if (!called && defaultHandler) {
          defaultHandler.apply(this, args);
        }
      }
    }]);

    return _class;
  }(superclass);
}

/* harmony default export */ __webpack_exports__["a"] = (EmitterMixin);

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(154);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(151);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var ctx         = __webpack_require__(18)
  , call        = __webpack_require__(73)
  , isArrayIter = __webpack_require__(71)
  , anObject    = __webpack_require__(14)
  , toLength    = __webpack_require__(36)
  , getIterFn   = __webpack_require__(65)
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = true;

/***/ }),
/* 42 */
/***/ (function(module, exports) {



/***/ }),
/* 43 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(30)
  , TAG = __webpack_require__(4)('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(103), __esModule: true };

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(6)
  , core    = __webpack_require__(0)
  , fails   = __webpack_require__(21);
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(99), __esModule: true };

/***/ }),
/* 48 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(41)
  , $export        = __webpack_require__(6)
  , redefine       = __webpack_require__(78)
  , hide           = __webpack_require__(16)
  , has            = __webpack_require__(19)
  , Iterators      = __webpack_require__(24)
  , $iterCreate    = __webpack_require__(114)
  , setToStringTag = __webpack_require__(28)
  , getPrototypeOf = __webpack_require__(76)
  , ITERATOR       = __webpack_require__(4)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(37)('meta')
  , isObject = __webpack_require__(17)
  , has      = __webpack_require__(19)
  , setDesc  = __webpack_require__(8).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(21)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(43)
  , createDesc     = __webpack_require__(27)
  , toIObject      = __webpack_require__(15)
  , toPrimitive    = __webpack_require__(55)
  , has            = __webpack_require__(19)
  , IE8_DOM_DEFINE = __webpack_require__(70)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(11) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(53)('keys')
  , uid    = __webpack_require__(37);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(5)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 54 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(17);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(5)
  , core           = __webpack_require__(0)
  , LIBRARY        = __webpack_require__(41)
  , wksExt         = __webpack_require__(57)
  , defineProperty = __webpack_require__(8).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(4);

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(148), __esModule: true };

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(17)
  , document = __webpack_require__(5).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(16);
module.exports = function(target, src, safe){
  for(var key in src){
    if(safe && target[key])target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(98), __esModule: true };

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(135), __esModule: true };

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(44)
  , ITERATOR  = __webpack_require__(4)('iterator')
  , Iterators = __webpack_require__(24);
module.exports = __webpack_require__(0).getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebRtcPlugin", function() { return isWebRtcPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaStream", function() { return MediaStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
/* harmony export (immutable) */ __webpack_exports__["isMediaStream"] = isMediaStream;
/* harmony export (immutable) */ __webpack_exports__["webRtcReady"] = webRtcReady;
/* harmony export (immutable) */ __webpack_exports__["addPeerConnectionStream"] = addPeerConnectionStream;
/* harmony export (immutable) */ __webpack_exports__["removePeerConnectionStream"] = removePeerConnectionStream;
/* harmony export (immutable) */ __webpack_exports__["BinaryTree"] = BinaryTree;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "audioContextUtil", function() { return audioContextUtil; });
/* harmony export (immutable) */ __webpack_exports__["getMediaStreamId"] = getMediaStreamId;
/* harmony export (immutable) */ __webpack_exports__["streamDiff"] = streamDiff;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_exports_loader_AdapterJS_adapterjs__ = __webpack_require__(204);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_exports_loader_AdapterJS_adapterjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_exports_loader_AdapterJS_adapterjs__);
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "AdapterJS", function() { return __WEBPACK_IMPORTED_MODULE_5_exports_loader_AdapterJS_adapterjs___default.a; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_utils__ = __webpack_require__(13);













/**
 * @typedef {'signaling'|'connecting'|'connected'|'reconnecting'|'closed'} PeerConnectionState
 *
 * A string representing the connection state of a peer connection.
 *
 * - `'signaling'` - The connection is in the signaling state, e.i. waiting for offer or answer.
 * - `'connecting'` - The signaling has been completed and the connection is being set up.
 * - `'connected'` - Connected to the peer.
 * - `'reconnecting'` - The connection has been temporarily lost but might recover.
 * - `'closed'` - The container of the connection has been closed, i.e. the conference, call, etc.
 */

var isWebRtcPlugin = window.webrtcDetectedType === 'plugin';

var MediaStream = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["noVendor"])(window, 'MediaStream');
var AudioContext = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["noVendor"])(window, 'AudioContext');

function isMediaStream(stream) {
  if (!stream) {
    return false;
  }
  if (MediaStream) {
    return stream instanceof MediaStream;
  } else {
    return stream.id && stream.addTrack && stream.getTracks;
  }
}

/**
 * A function that returns a promise that is resolved once WebRTC is ready to be used on the page.
 * The promise is always resolved to the first argument passed to the function, so it can
 * be transparently added to a promise `.then()` chain.
 *
 * It is only necessary to wait when using a browser plugin to enable WebRTC,
 * but it is good practice to call this function and make sure the promise is
 * resolved before doing anything WebRTC related, including creating media sources.
 *
 * @example
 * login()
 *   .then(cct.webRtcReady)
 *   .then(setupCall)
 *
 * @function cct.webRtcReady
 * @param {*} [ret] - The value that should be returned.
 * @returns {Promise} A promise that is resolved to the value of the
 *     ret argument once WebRTC is ready.
 */
function webRtcReady(ret) {
  return new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default.a(function (resolve) {
    if (__WEBPACK_IMPORTED_MODULE_5_exports_loader_AdapterJS_adapterjs___default.a) {
      __WEBPACK_IMPORTED_MODULE_5_exports_loader_AdapterJS_adapterjs___default.a.webRTCReady(function () {
        resolve(ret);
      });
    } else {
      resolve(ret);
    }
  });
}

function addPeerConnectionStream(peerConnection, stream) {
  if (__WEBPACK_IMPORTED_MODULE_7_common_utils__["isFirefox"]) {
    var removeSet = peerConnection._streamsPendingRemoval;
    if (removeSet && removeSet.has(stream)) {
      removeSet.delete(stream);
    }
  }
  peerConnection.addStream(stream);
}

var ALLOWED_REMOVE_STATES = ['stable', 'closed'];

function waitForStableState(peerConnection, callback) {
  function onState() {
    var state = peerConnection.signalingState;
    if (ALLOWED_REMOVE_STATES.indexOf(state) !== -1) {
      peerConnection.removeEventListener('signalingstate', onState);
      callback();
    }
  }
  peerConnection.addEventListener('signalingstate', onState);
}

function removeAllTracks(peerConnection, tracks) {
  tracks.forEach(function (track) {
    var sender = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["find"])(peerConnection.getSenders(), function (sender) {
      return sender.track === track;
    });
    if (sender) {
      peerConnection.removeTrack(sender);
    } else {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].debug('webrtc-utils', 'Failed to remove track \'' + track + '\' form peer connection, no sender found.');
    }
  });
}

function removePeerConnectionStream(peerConnection, stream) {
  var state = peerConnection.signalingState;
  if (__WEBPACK_IMPORTED_MODULE_7_common_utils__["isFirefox"] && ALLOWED_REMOVE_STATES.indexOf(state) === -1) {
    __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].info('webrtc-utils', "delaying removeTrack since we're not in a stable state");
    var removeSet = peerConnection._streamsPendingRemoval;
    if (!removeSet) {
      removeSet = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default.a();
      peerConnection._streamsPendingRemoval = removeSet;
      waitForStableState(peerConnection, function () {
        var removeSet = peerConnection._streamsPendingRemoval;
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].info('webrtc-utils', 'stable state reached, removing streams: ' + removeSet);
        removeSet.forEach(function (stream) {
          return removePeerConnectionStream(peerConnection, stream);
        });
      });
    }
    removeSet.add(stream);
    return;
  }
  if (peerConnection.removeStream) {
    try {
      peerConnection.removeStream(stream);
    } catch (error) {
      if (error.name === 'NotSupportedError') {
        // Workaround for FireFox
        removeAllTracks(peerConnection, stream.getTracks());
      } else {
        throw error;
      }
    }
  } else {
    removeAllTracks(peerConnection, stream.getTracks());
  }
}

function BinaryTree(nodes) {
  this.nodes = nodes || [];
}

BinaryTree.prototype = {
  constructor: BinaryTree,
  tag: 'binary-tree',
  toString: function toString() {
    return 'binaryTree{nodes=' + this.nodes + '}';
  },

  root: function root() {
    return this.nodes[0];
  },
  parent: function parent(child) {
    var childIndex = this.nodes.indexOf(child);
    var parentIndex = Math.floor((childIndex - 1) / 2);
    return this.nodes[parentIndex];
  },
  left: function left(parent) {
    var parentIndex = this.nodes.indexOf(parent);
    var childIndex = 2 * parentIndex + 1;
    return this.nodes[childIndex];
  },
  right: function right(parent) {
    var parentIndex = this.nodes.indexOf(parent);
    var childIndex = 2 * parentIndex + 2;
    return this.nodes[childIndex];
  }
};

AudioContextUtil.MAX_REFERENCES = 32;

function AudioContextUtil() {
  this._references = 0;
  this._context = null;
}

AudioContextUtil.prototype = {
  constructor: AudioContextUtil,
  tag: 'audio-context-util',
  toString: function toString() {
    return 'audio-context-util{references=' + this._references + ', context=' + this._context + '}';
  },
  get: function get() {
    this._references += 1;
    if (this._references > AudioContextUtil.MAX_REFERENCES) {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].warning(this.tag, 'Too many audioContext references, possible leak.');
    }
    if (!this._context) {
      this._context = new AudioContext();
    }
    return this._context;
  },
  release: function release() {
    if (this._references === 0) {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(this.tag, 'audioContext was dereferenced too many times.');
      return;
    } else if (this._references === 1) {
      this._context.close();
      this._context = null;
    }
    this._references -= 1;
  }
};

var audioContextUtil = new AudioContextUtil();

function getMediaStreamId(stream) {
  if (stream._blobId && stream._blobId.indexOf('MediaStream_') === 0) {
    // Only present in Cordova MediaStreams
    // MediaStreams in Cordova have a weird id where the first half is the same for
    // remote streams, while the second half is unique.
    // An example ID is '0E6CFB41-27A7-4028-9E06-02206E3C5118-6A849356-4C8F-4D93-A438-8329888D0E03'
    // Where '0E6CFB41-27A7-4028-9E06-02206E3C5118' is the bit we want to use
    // We've seen other formats as well though, like base64-uuid, as opposed to the above uuid-uuid
    // To protect agains changes to the Cordova plugin we handle a few different cases below
    var fullId = stream.id;
    var split = fullId.split('-');
    if (split.length === 2) {
      return split[0];
    } else if (split.length === 6) {
      return split[0];
    } else if (split.length === 10) {
      return split.slice(0, 5).join('-');
    } else {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].warning('media-streamid', 'unexpected cordova media stream id: ' + stream.id);
      return stream.id;
    }
  } else {
    return stream.id;
  }
}

function collectStreams(streams, stream) {
  var id = getMediaStreamId(stream);
  streams[id] = stream;
  return streams;
}

function streamDiff(streams1, streams2) {
  var streamMap1 = [].concat(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default()(streams1)).reduce(collectStreams, {});
  var streamMap2 = [].concat(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default()(streams2)).reduce(collectStreams, {});
  var streamIds1 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys___default()(streamMap1);
  var streamIds2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys___default()(streamMap2);

  var _diff = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["diff"])(streamIds1, streamIds2),
      _diff2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_diff, 2),
      addedIds = _diff2[0],
      removedIds = _diff2[1];

  var addedStreams = addedIds.map(function (id) {
    return streamMap2[id];
  });
  var removedStreams = removedIds.map(function (id) {
    return streamMap1[id];
  });
  return [addedStreams, removedStreams];
}

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(30);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 68 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _getPrototypeOf = __webpack_require__(7);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = __webpack_require__(93);

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(11) && !__webpack_require__(21)(function(){
  return Object.defineProperty(__webpack_require__(60)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators  = __webpack_require__(24)
  , ITERATOR   = __webpack_require__(4)('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(30);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(14);
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(77)
  , hiddenKeys = __webpack_require__(48).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(19)
  , toObject    = __webpack_require__(26)
  , IE_PROTO    = __webpack_require__(52)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(19)
  , toIObject    = __webpack_require__(15)
  , arrayIndexOf = __webpack_require__(108)(false)
  , IE_PROTO     = __webpack_require__(52)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(16);

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(97), __esModule: true };

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP          = __webpack_require__(8).f
  , create      = __webpack_require__(35)
  , redefineAll = __webpack_require__(61)
  , ctx         = __webpack_require__(18)
  , anInstance  = __webpack_require__(59)
  , defined     = __webpack_require__(34)
  , forOf       = __webpack_require__(40)
  , $iterDefine = __webpack_require__(49)
  , step        = __webpack_require__(74)
  , setSpecies  = __webpack_require__(85)
  , DESCRIPTORS = __webpack_require__(11)
  , fastKey     = __webpack_require__(50).fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(44)
  , from    = __webpack_require__(107);
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global         = __webpack_require__(5)
  , $export        = __webpack_require__(6)
  , meta           = __webpack_require__(50)
  , fails          = __webpack_require__(21)
  , hide           = __webpack_require__(16)
  , redefineAll    = __webpack_require__(61)
  , forOf          = __webpack_require__(40)
  , anInstance     = __webpack_require__(59)
  , isObject       = __webpack_require__(17)
  , setToStringTag = __webpack_require__(28)
  , dP             = __webpack_require__(8).f
  , each           = __webpack_require__(109)(0)
  , DESCRIPTORS    = __webpack_require__(11);

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function(target, iterable){
      anInstance(target, C, NAME, '_c');
      target._c = new Base;
      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
        anInstance(this, C, KEY);
        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    if('size' in proto)dP(C.prototype, 'size', {
      get: function(){
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5).document && document.documentElement;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR     = __webpack_require__(4)('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global      = __webpack_require__(5)
  , core        = __webpack_require__(0)
  , dP          = __webpack_require__(8)
  , DESCRIPTORS = __webpack_require__(11)
  , SPECIES     = __webpack_require__(4)('species');

module.exports = function(KEY){
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return InputMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return OutputMap; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_get__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_media_mediaNodeInput__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_media_mediaNodeOutput__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_media_common__ = __webpack_require__(92);

















var TAG = 'media-node';

/**
 * @typedef {MediaNodeOutput|Object} MediaNodeConnectSource
 *
 * A set of types that a can connect to {@link MediaNode}s or {@link MediaNodeInput}s.
 *
 * The types are the same as the ones that can be passed to {@link MediaNodeOutput#resolve}.
 */

/**
 * @typedef {MediaNodeInput|external:HTMLMediaElement|Object} MediaNodeConnectTarget
 *
 * A set of types that a {@link MediaNode} or {@link MediaNodeOutput} can be connected to.
 *
 * The types are the same as the ones that can be passed to {@link MediaNodeInput#resolve},
 * with the addition of {@link external:HTMLMediaElement}.
 *
 * If an HTML element is passed when connecting, an {@link HtmlSink} will be created and used
 * as the target. When disconnecting, all targets that are {@link HtmlSink}s which are rendering
 * to the given HTML element will be disconnected. This way the same HTML element can be passed
 * to connect and disconnect without any hassle.
 */

/**
 * A base class that all pure media nodes inherit from.
 *
 * Classes inheriting from {@link MediaNode} are plain nodes with input and output ports directly attached.
 *
 * A media node has zero or more input and output ports, which can be connected to other nodes.
 * Media nodes are always connected from one output port to one input port, using the connect
 * method of either the output port or the media node.
 *
 * When using the connect method of a media node, the output port to be used is resolved by
 * recursively looking up the output property of the media node. The same method is used when
 * a media node is used as the target for a connection, but in that case an input port is looked
 * up via the input property.
 *
 * Because the input and output property lookups are recursive, it is easy to create simple container
 * nodes that have a number of internal media nodes, and then expose input and output ports as
 * properties.
 *
 * As an example, we might have `cameraSource` and `blurFilter`, which both inherit from
 * {@link MediaNode}. The source has one output port, while the filter has one input and one ouput.
 * We can connect these two together using `cameraSource.output.connect(blurFilter.input)`. This is
 * a bit verbose, but because the connect method will look up the input and output properties, we
 * can just use `cameraSource.connect(blurFilter)` instead. The connect method is made available
 * to the camera source class using {@link MediaSource.connectMixin}.
 *
 * Let's say we now want to create a `BlurredCameraSource` class, which reuses the nodes from the
 * above example. The ES6 class declaration would be
 * `class BlurredCameraSource extends MediaSource.connectMixin()`. The mixin adds the connect and
 * disconnect methods for convenience. In the constructor, we can now create our camera source and
 * blur filter, connect them together, and simply expose the ouput property of the `blurFilter`
 * using `this.output = blurFilter.output`. Since the output lookup is recursive, we can call the
 * connect method of our `blurredCameraSource` directly, but the output port of the blurFilter will
 * in the end be what is actually connected.
 *
 * @class MediaNode
 */

var MediaNode = function () {
  function MediaNode() {
    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, MediaNode);

    this[__WEBPACK_IMPORTED_MODULE_12_media_common__["a" /* inputs */]] = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default.a();
    this[__WEBPACK_IMPORTED_MODULE_12_media_common__["b" /* outputs */]] = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default.a();
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(MediaNode, [{
    key: 'toString',
    value: function toString() {
      var name = this.constructor.name;
      var camelName = void 0;
      if (!name) {
        camelName = '_mediaNode';
      } else {
        camelName = name[0].toLowerCase() + name.slice(1);
      }

      return camelName + '{io=' + this[__WEBPACK_IMPORTED_MODULE_12_media_common__["a" /* inputs */]].size + '/' + this[__WEBPACK_IMPORTED_MODULE_12_media_common__["b" /* outputs */]].size + '}';
    }

    // Public methods

    /**
     * Connect two media nodes or ports together. Both the input and the output will be resolved
     * using the respective resolve methods.
     *
     * Usually adding the {@link MediaNode.connectMixin} to the source class is more convenient and clearer than using
     * these methods.
     *
     * @example <caption>Connecting a DeviceSource to a MuteFilter.</caption>
     * // Passing in MediaNodes
     * MediaNode.connect(deviceSource, muteFilter)
     *
     * // Explicitly passing in inputs and outputs, will result in the same connection as above.
     * MediaNode.connect(deviceSource.output, muteFilter.input)
     *
     * @param  {MediaNodeConnectSource} output - The source ouput or node.
     * @param  {MediaNodeConnectTarget} input - The target input, node, or element.
     */

  }, {
    key: __WEBPACK_IMPORTED_MODULE_12_media_common__["c" /* mediaNodeSpecies */],


    // Private

    get: function get() {
      return true;
    }
  }], [{
    key: 'connect',
    value: function connect(output, input) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].object(output.constructor.name + '.connect', 'output', output);
      if (!(input instanceof HTMLElement)) {
        __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].object(output.constructor.name + '.connect', 'input', input);
      }
      output = __WEBPACK_IMPORTED_MODULE_11_media_mediaNodeOutput__["a" /* default */].resolve(output);
      output.connect(input);
    }

    /**
     * Disconnect two media nodes or ports. Both the input and the output will be resolved
     * using the respective resolve methods.
     *
     * @param  {MediaNodeConnectSource} output - The source ouput or node.
     * @param  {MediaNodeConnectTarget} input - The target input, node, or element.
     */

  }, {
    key: 'disconnect',
    value: function disconnect(output, input) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].object(output.constructor.name + '.connect', 'output', output);
      if (!(input instanceof HTMLElement)) {
        __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].optObject(output.constructor.name + '.connect', 'input', input);
      }
      output = __WEBPACK_IMPORTED_MODULE_11_media_mediaNodeOutput__["a" /* default */].resolve(output);
      output.disconnect(input);
    }

    /**
     * A mixin that adds the connect and disconnect methods from {@link MediaNode} as member methods.
     *
     * @mixin ConnectMixin
     */

    /**
     * Connect the node to a target. Each output can be connected to multiple targets.
     *
     * @function ConnectMixin#connect
     * @param  {MediaNodeConnectTarget} input - The target input, node, or element.
     */

    /**
     * Disconnect the node from a target.
     *
     * If no target is specified, all targets will be disconnected.
     *
     * @function ConnectMixin#disconnect
     * @param {MediaNodeConnectTarget} [target] - The target to disconnect from.
     */

    /**
     * A mixin that adds the connect and disconnect methods to a class.
     *
     * @example <caption>Usage with ES6 classes.</caption>
     * // Without superclass
     * class MyClass extends MediaNode.connectMixin() {
     * }
     *
     * // With a superclass
     * class MyClass extends MediaNode.connectMixin(MySuperClass) {
     * }
     *
     * @param {class} [superclass] - The superclass to extend, if no class is given a class with only the
     *   mixin applied is returned.
     * @returns {class} A new class extended with the connect and disconnect methods.
     */

  }, {
    key: 'connectMixin',
    value: function connectMixin() {
      var superclass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

      return function (_superclass) {
        __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ConnectableNode, _superclass);

        function ConnectableNode() {
          __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, ConnectableNode);

          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConnectableNode.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ConnectableNode)).apply(this, arguments));
        }

        __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(ConnectableNode, [{
          key: 'connect',
          value: function connect(target) {
            MediaNode.connect(this, target);
          }
        }, {
          key: 'disconnect',
          value: function disconnect(target) {
            MediaNode.disconnect(this, target);
          }
        }]);

        return ConnectableNode;
      }(superclass);
    }
  }]);

  return MediaNode;
}();

/**
 * A base class for input and output maps.
 *
 * @class PortMap
 * @abstract
 * @extends ReadOnlyMap
 */


/* harmony default export */ __webpack_exports__["a"] = (MediaNode);

var PortMap = function (_ReadOnlyMap) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(PortMap, _ReadOnlyMap);

  function PortMap(_ref) {
    var parent = _ref.parent,
        portConstructor = _ref.portConstructor,
        onStream = _ref.onStream,
        onCreate = _ref.onCreate,
        onDetach = _ref.onDetach;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, PortMap);

    var _this2 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (PortMap.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(PortMap)).call(this));

    __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].object(_this2.constructor.name + ' constructor', 'parent', parent);
    __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].func(_this2.constructor.name + ' constructor', 'portConstructor', portConstructor);
    _this2._parent = parent;
    _this2._portConstructor = portConstructor;
    _this2._onStream = onStream;
    _this2._onCreate = onCreate;
    _this2._onDetach = onDetach;
    return _this2;
  }

  /**
   * Gets the input for the given key. If the input doesn't exist, it is created.
   *
   * @param {string} key - The name of the port.
   * @returns {MediaNodeInput|MediaNodeOutput} An existing or newly created port.
   */


  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(PortMap, [{
    key: 'get',
    value: function get(key) {
      var _this3 = this;

      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].string(this.constructor.name + '.get', 'key', key);
      var port = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_get___default()(PortMap.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(PortMap.prototype), 'get', this).call(this, key);
      if (!port) {
        try {
          var options = {
            name: key,
            parent: this._parent
          };
          if (this._onStream) {
            options.onStream = function (stream, oldStream) {
              return _this3._onStream(key, stream, oldStream);
            };
          }
          port = new this._portConstructor(options);
        } catch (constructorError) {
          var error = new Error('Error thrown in ' + this._portConstructor.name + ' constructor, ' + constructorError);
          error.reason = constructorError;
          throw error;
        }
        __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_get___default()(PortMap.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(PortMap.prototype), '_set', this).call(this, key, port);
        if (this._onCreate) {
          try {
            this._onCreate(port);
          } catch (error) {
            __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'Error thrown in ' + this.constructor.name + '.onCreate: ' + error);
          }
        }
      }
      return port;
    }

    /**
     * Removes and detaches the input or output with the given name.
     *
     * @param {string} key - The name of the port.
     * @returns {boolean} True if the was a port to delete.
     */

  }, {
    key: 'delete',
    value: function _delete(key) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].string(this.constructor.name + '.delete', 'key', key);
      var port = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_get___default()(PortMap.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(PortMap.prototype), 'get', this).call(this, key);
      if (port) {
        __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_get___default()(PortMap.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(PortMap.prototype), '_delete', this).call(this, key);
        port.detach();
        if (this._onDetach) {
          try {
            this._onDetach(port);
          } catch (error) {
            __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'Error thrown in ' + this.constructor.name + '.onDetach: ' + error);
          }
        }
        return true;
      }
      return false;
    }

    /**
     * Removes and detaches all the ports in the map.
     */

  }, {
    key: 'clear',
    value: function clear() {
      var _this4 = this;

      __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_get___default()(PortMap.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(PortMap.prototype), 'forEach', this).call(this, function (_, key) {
        _this4.delete(key);
      });
    }
  }]);

  return PortMap;
}(__WEBPACK_IMPORTED_MODULE_9_common_utils__["ReadOnlyMap"]);

/**
 * A callback that is called when the stream of any of the inputs is updated.
 *
 * @callback InputMap~OnStreamCallback
 * @param {string} key - The key for the input port of the updated stream.
 * @param {?MediaStream} stream - The new media stream.
 * @param {?MediaStream} oldStream - The old media stream.
 */

/**
 * A callback for when a new input is created.
 *
 * @callback InputMap~OnCreateCallback
 * @param {MediaNodeInput} input - The input that was created.
 */

/**
 * A callback for when an input is detached.
 *
 * @callback InputMap~OnDetachCallback
 * @param {MediaNodeInput} input - The input that was detached.
 */

/**
 * A map of inputs for a media node. This allows for a node to have multiple named inputs.
 *
 * @class InputMap
 * @extends PortMap
 * @param {Object} options - Options object.
 * @param {MediaNode} options.parent - The parent media node.
 * @param {class} [options.inputConstructor=MediaNodeInput] - The constructor of the inputs in this map.
 *   Must be `MediaNodeInput`, or a subclass.
 * @param {InputMap~OnStreamCallback} onStream - Callback for when any of the inputs streams are updated.
 * @param {InputMap~OnCreateCallback} onCreate - Callback for when a new port is created.
 * @param {InputMap~OnDetachCallback} onDetach - Callback for when a new port is detached and removed.
 */


var InputMap = function (_PortMap) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(InputMap, _PortMap);

  function InputMap(_ref2) {
    var _ref2$inputConstructo = _ref2.inputConstructor,
        inputConstructor = _ref2$inputConstructo === undefined ? __WEBPACK_IMPORTED_MODULE_10_media_mediaNodeInput__["a" /* default */] : _ref2$inputConstructo,
        parent = _ref2.parent,
        onStream = _ref2.onStream,
        onCreate = _ref2.onCreate,
        onDetach = _ref2.onDetach;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, InputMap);

    __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].optFunc('InputMap constructor', 'onStream', onStream);
    if (!onStream) {
      onStream = function onStream() {
        return parent.onStream.apply(parent, arguments);
      };
    }
    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (InputMap.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(InputMap)).call(this, { portConstructor: inputConstructor, parent: parent, onStream: onStream, onCreate: onCreate, onDetach: onDetach }));
  }

  return InputMap;
}(PortMap);

/**
 * A callback for when a new output is created.
 *
 * @callback OutputMap~OnCreateCallback
 * @param {MediaNodeInput} output - The output that was created.
 */

/**
 * A callback for when an output is detached.
 *
 * @callback OutputMap~OnDetachCallback
 * @param {MediaNodeInput} output - The output that was detached.
 */

/**
 * A map of ouputs for a media node. This allows for a node to have multiple named ouputs.
 *
 * @class OutputMap
 * @extends PortMap
 * @param {Object} options - Options object.
 * @param {MediaNode} options.parent - The parent media node.
 * @param {class} [options.outputConstructor=MediaNodeOutput] - The constructor of the outputs in this map.
 *   Must be `MediaNodeOutput`, or a subclass.
 * @param {OutputMap~OnCreateCallback} onCreate - Callback for when a new port is created.
 * @param {OutputMap~OnDetachCallback} onDetach - Callback for when a new port is detached and removed.
 */
var OutputMap = function (_PortMap2) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(OutputMap, _PortMap2);

  function OutputMap(_ref3) {
    var _ref3$outputConstruct = _ref3.outputConstructor,
        outputConstructor = _ref3$outputConstruct === undefined ? __WEBPACK_IMPORTED_MODULE_11_media_mediaNodeOutput__["a" /* default */] : _ref3$outputConstruct,
        parent = _ref3.parent,
        onCreate = _ref3.onCreate,
        onDetach = _ref3.onDetach;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, OutputMap);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (OutputMap.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(OutputMap)).call(this, { portConstructor: outputConstructor, parent: parent, onCreate: onCreate, onDetach: onDetach }));
  }

  return OutputMap;
}(PortMap);

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(104), __esModule: true };

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(47);

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _from = __webpack_require__(79);

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  return Array.isArray(arr) ? arr : (0, _from2.default)(arr);
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var ctx                = __webpack_require__(18)
  , invoke             = __webpack_require__(137)
  , html               = __webpack_require__(83)
  , cel                = __webpack_require__(60)
  , global             = __webpack_require__(5)
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(__webpack_require__(30)(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(15)
  , gOPN      = __webpack_require__(75).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return mediaNodeSpecies; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return inputs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return outputs; });
/* harmony export (immutable) */ __webpack_exports__["d"] = isMediaNode;
/* harmony export (immutable) */ __webpack_exports__["e"] = doesntSupportPlugin;
/* unused harmony export OverconstrainedError */
/* harmony export (immutable) */ __webpack_exports__["f"] = getUserMedia;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_symbol__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_symbol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_symbol__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_queue__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_errors__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_webrtc_utils__ = __webpack_require__(66);













var mediaNodeSpecies = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_symbol___default()('media-node');
var inputs = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_symbol___default()('inputs');
var outputs = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_symbol___default()('outputs');

/**
 * Checks whether a given object is a media node.
 *
 * @param {Object} obj - An object to test.
 * @returns {boolean} True if the object is a media node, false otherwise.
 */
function isMediaNode(obj) {
  return !!(obj && obj[mediaNodeSpecies]);
}

function doesntSupportPlugin(instance) {
  if (__WEBPACK_IMPORTED_MODULE_8_webrtc_utils__["isWebRtcPlugin"]) {
    throw new Error(instance.constructor.name + ' is not supported when using a WebRTC plugin');
  }
}

/**
 * The constraints of the performed action could not be satisfied, e.g. the requested
 * video frame rate could not be delivered.
 *
 * @class OverconstrainedError
 * @extends CctError
 */
var OverconstrainedError = function (_CctError) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(OverconstrainedError, _CctError);

  function OverconstrainedError() {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, OverconstrainedError);

    return __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (OverconstrainedError.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(OverconstrainedError)).apply(this, arguments));
  }

  return OverconstrainedError;
}(__WEBPACK_IMPORTED_MODULE_7_common_errors__["a" /* default */]);
OverconstrainedError.errorName = 'OverconstrainedError';

var gumQueue = new __WEBPACK_IMPORTED_MODULE_6_common_queue__["a" /* default */]();

// Browsers are inconsistent in what errors are thrown when mic/camera access is denied.
// PermissionDeniedError is thrown by Chrome and the plugin
// SecurityError is from Firefox 48
// NotAllowedError is from Firefox 50 Developer edition and onward
var NOT_ALLOWED_ERRORS = ['SecurityError', 'NotAllowedError', 'PermissionDeniedError', 'PermissionDismissedError'];
var NOT_FOUND_ERRORS = ['NotFoundError', 'DevicesNotFoundError'];
var OVERCONSTRAINED_ERRORS = ['OverconstrainedError', 'ConstraintNotSatisfiedError'];

function getUserMedia(constraints) {
  if (!navigator.getUserMedia) {
    return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject(new Error('no getUserMedia found'));
  }

  return gumQueue.push(function () {
    return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
      return navigator.getUserMedia(constraints, function (stream) {
        if (stream) {
          resolve(stream);
        } else {
          reject(new __WEBPACK_IMPORTED_MODULE_7_common_errors__["b" /* NotFoundError */]('Received a null media stream'));
        }
      }, function (gumError) {
        var error;
        if (NOT_ALLOWED_ERRORS.indexOf(gumError.name) !== -1) {
          // According to spec, denying the gum request should lead to a NotAllowedError
          error = new __WEBPACK_IMPORTED_MODULE_7_common_errors__["c" /* NotAllowedError */](gumError.message);
        } else if (OVERCONSTRAINED_ERRORS.indexOf(gumError.name) !== -1) {
          // According to spec, constraint errors should lead to an OverconstrainedError
          var message = gumError.message;
          if (!message) {
            if (gumError.constraint) {
              message = 'media constraint \'' + gumError.constraint + '\' could not be satisfied';
            } else {
              message = 'media constraints could not be satisfied';
            }
          }
          error = new OverconstrainedError(message);
        } else if (NOT_FOUND_ERRORS.indexOf(gumError.name) !== -1) {
          // According to spec, not found errors should lead to a NotFoundError
          error = new __WEBPACK_IMPORTED_MODULE_7_common_errors__["b" /* NotFoundError */](gumError.message);
        } else {
          error = new __WEBPACK_IMPORTED_MODULE_7_common_errors__["d" /* UnknownError */](gumError.message);
        }
        error.reason = gumError;
        reject(error);
      });
    });
  });
}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(100), __esModule: true };

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(105), __esModule: true };

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(8)
  , anObject = __webpack_require__(14)
  , getKeys  = __webpack_require__(25);

module.exports = __webpack_require__(11) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(102), __esModule: true };

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(23);
__webpack_require__(119);
module.exports = __webpack_require__(0).Array.from;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(121);
var $Object = __webpack_require__(0).Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(122);
var $Object = __webpack_require__(0).Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(123);
var $Object = __webpack_require__(0).Object;
module.exports = function getOwnPropertyDescriptor(it, key){
  return $Object.getOwnPropertyDescriptor(it, key);
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(124);
module.exports = __webpack_require__(0).Object.getPrototypeOf;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(125);
module.exports = __webpack_require__(0).Object.setPrototypeOf;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42);
__webpack_require__(23);
__webpack_require__(29);
__webpack_require__(126);
__webpack_require__(128);
module.exports = __webpack_require__(0).Set;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(127);
__webpack_require__(42);
__webpack_require__(129);
__webpack_require__(130);
module.exports = __webpack_require__(0).Symbol;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(23);
__webpack_require__(29);
module.exports = __webpack_require__(57).f('iterator');

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = function(){ /* empty */ };

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(40);

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(15)
  , toLength  = __webpack_require__(36)
  , toIndex   = __webpack_require__(118);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = __webpack_require__(18)
  , IObject  = __webpack_require__(67)
  , toObject = __webpack_require__(26)
  , toLength = __webpack_require__(36)
  , asc      = __webpack_require__(111);
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(17)
  , isArray  = __webpack_require__(72)
  , SPECIES  = __webpack_require__(4)('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(110);

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(8)
  , createDesc      = __webpack_require__(27);

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(25)
  , gOPS    = __webpack_require__(68)
  , pIE     = __webpack_require__(43);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(35)
  , descriptor     = __webpack_require__(27)
  , setToStringTag = __webpack_require__(28)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(16)(IteratorPrototype, __webpack_require__(4)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(25)
  , toIObject = __webpack_require__(15);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(17)
  , anObject = __webpack_require__(14);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(18)(Function.call, __webpack_require__(51).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(54)
  , defined   = __webpack_require__(34);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(54)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx            = __webpack_require__(18)
  , $export        = __webpack_require__(6)
  , toObject       = __webpack_require__(26)
  , call           = __webpack_require__(73)
  , isArrayIter    = __webpack_require__(71)
  , toLength       = __webpack_require__(36)
  , createProperty = __webpack_require__(112)
  , getIterFn      = __webpack_require__(65);

$export($export.S + $export.F * !__webpack_require__(84)(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(106)
  , step             = __webpack_require__(74)
  , Iterators        = __webpack_require__(24)
  , toIObject        = __webpack_require__(15);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(49)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(6)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(35)});

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(6);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(11), 'Object', {defineProperty: __webpack_require__(8).f});

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = __webpack_require__(15)
  , $getOwnPropertyDescriptor = __webpack_require__(51).f;

__webpack_require__(46)('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = __webpack_require__(26)
  , $getPrototypeOf = __webpack_require__(76);

__webpack_require__(46)('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(6);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(116).set});

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(80);

// 23.2 Set Objects
module.exports = __webpack_require__(82)('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(5)
  , has            = __webpack_require__(19)
  , DESCRIPTORS    = __webpack_require__(11)
  , $export        = __webpack_require__(6)
  , redefine       = __webpack_require__(78)
  , META           = __webpack_require__(50).KEY
  , $fails         = __webpack_require__(21)
  , shared         = __webpack_require__(53)
  , setToStringTag = __webpack_require__(28)
  , uid            = __webpack_require__(37)
  , wks            = __webpack_require__(4)
  , wksExt         = __webpack_require__(57)
  , wksDefine      = __webpack_require__(56)
  , keyOf          = __webpack_require__(115)
  , enumKeys       = __webpack_require__(113)
  , isArray        = __webpack_require__(72)
  , anObject       = __webpack_require__(14)
  , toIObject      = __webpack_require__(15)
  , toPrimitive    = __webpack_require__(55)
  , createDesc     = __webpack_require__(27)
  , _create        = __webpack_require__(35)
  , gOPNExt        = __webpack_require__(91)
  , $GOPD          = __webpack_require__(51)
  , $DP            = __webpack_require__(8)
  , $keys          = __webpack_require__(25)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(75).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(43).f  = $propertyIsEnumerable;
  __webpack_require__(68).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(41)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(16)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(6);

$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(81)('Set')});

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(56)('asyncIterator');

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(56)('observable');

/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_media_common__ = __webpack_require__(92);










var TAG = 'media-node-input';

/**
 * @callback MediaNodeInput~OnStreamCallback
 * @param {?MediaStream} stream - The current media stream, or null.
 * @param {?MediaStream} oldStream - The previous media stream, or null.
 */

/**
 * A class which represents an input of a {@link MediaNode}. Outputs are connected to
 * inputs in order to forward media streams.
 *
 * This class should only be used within the implementation of {@link MediaNode}s. While it
 * is possible to attach inputs to an existing media node, it should be avoided. Use an additional
 * media node to implement the desired behaviour instead, such as a {@link Passthrough}.
 *
 * @class MediaNodeInput
 * @param {Object} options - Options object.
 * @param {string} options.name - The name of the output, should be 'default' for single inputs.
 * @param {MediaNode} options.parent - The parent media node.
 * @param {MediaNodeInput~OnStreamCallback} options.parent - A callback that will be called whenever
 * the stream of this media node changes.
 */

var MediaNodeInput = function () {
  function MediaNodeInput(_ref) {
    var name = _ref.name,
        parent = _ref.parent,
        onStream = _ref.onStream;

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, MediaNodeInput);

    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('MediaNodeInput constructor', 'name', name);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_media_common__["d" /* isMediaNode */])(parent)) {
      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('MediaNodeInput constructor', 'parent', 'be a MediaNode');
    }
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].func('MediaNodeInput constructor', 'onStream', onStream);
    this._name = name;
    this._parent = parent;
    this._onStream = onStream;
    this._output = null;
    this._stream = null;

    this._parent[__WEBPACK_IMPORTED_MODULE_5_media_common__["a" /* inputs */]].add(this);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(MediaNodeInput, [{
    key: 'toString',
    value: function toString() {
      return 'mediaNodeInput{name=' + this.name + ',parent=' + this._parent + '}';
    }

    /**
     * Resolves the input of a target. If the lookup fails, an error will be thrown.
     *
     * Inputs are resolved as follows, starting with a target:
     *   1. If the current target is a {@link MediaNodeInput} instance, stop and return the target.
     *   2. If the target is an object, set the new target to the `input` property of the target, and start over.
     *   3. Throw error.
     *
     * If a circular input object structure is encountered, an error will be thrown.
     *
     * @param {MediaNodeInput|Object} target - The target to resolve the input of.
     * @returns {MediaNodeInput} The resolved input.
     */

  }, {
    key: 'detach',


    /**
     * Detaches the input from it's parent and removes any connection. Use this to clean up inputs
     * in media nodes with dynamic inputs, such as a media mixer. After this method has been called
     * the input can no longer be used.
     *
     * This method is internal and should only be called by the implementation of the parent media node.
     */
    value: function detach() {
      if (this._target) {
        this._target.disconnect(this);
      }
      this._parent[__WEBPACK_IMPORTED_MODULE_5_media_common__["a" /* inputs */]].delete(this);
      this._parent = null;
    }
  }, {
    key: '_disconnect',
    value: function _disconnect(target) {
      if (this.target !== target) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'invalid input disconnect state, expected target ' + target + ' but was ' + this.target);
      }
      this._target = null;
      this._setStream(null);
    }
  }, {
    key: '_setStream',
    value: function _setStream(stream) {
      if (this._stream === stream) {
        return;
      }
      var oldStream = this._stream;
      this._stream = stream;
      try {
        this._onStream(stream, oldStream);
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'Error thrown in onStream: ' + error);
      }
    }
  }, {
    key: 'name',


    /**
     * The name of this input. This is only meaningful for inputs that belong to media nodes with
     * multiple inputs.
     *
     * Any input that belong to one of the base media node implementations, such as {@link MediaSink},
     * will have the name `'default'`.
     *
     * @readonly
     * @member {string} MediaNodeInput#name
     */
    get: function get() {
      return this._name;
    }

    /**
     * The current target of this input.
     *
     * The input will always be set to the {@link MediaNodeOutput} that the input is connected to,
     * and not the media node that the connect might have been called on.
     *
     * @readonly
     * @member {ReadOnlySet<MediaNodeInput>} MediaNodeInput#target
     */

  }, {
    key: 'target',
    get: function get() {
      return this._target;
    }

    /**
     * The inputs's current media stream, or null.
     *
     * @readonly
     * @member {MediaStream} MediaNodeInput#stream
     */

  }, {
    key: 'stream',
    get: function get() {
      return this._stream;
    }
  }], [{
    key: 'resolve',
    value: function resolve(target) {
      var chain = [target];
      for (;;) {
        if (target instanceof MediaNodeInput) {
          return target;
        } else if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["isObject"])(target)) {
          throw new TypeError('failed to resolve input of ' + (chain[0] && chain[0].constructor.name) + ', ' + 'input must be a MediaNodeInput or have an input property');
        } else if ('input' in target) {
          try {
            target = target.input;
          } catch (error) {
            throw new TypeError('failed to resolve input of ' + chain[0].constructor.name + ', ' + ('getting input property of ' + target + ' threw error: ' + error.message));
          }
          if (chain.indexOf(target) !== -1) {
            throw new TypeError('failed to resolve input of ' + chain[0].constructor.name + ', ' + 'encountered loop in input property chain');
          }
          chain.push(target);
        } else {
          throw new TypeError('failed to resolve input of ' + chain[0].constructor.name + ', ' + (target.constructor.name + ' does not have an input property'));
        }
      }
    }
  }]);

  return MediaNodeInput;
}();

/* harmony default export */ __webpack_exports__["a"] = (MediaNodeInput);

/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ConfigurationData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Members; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return Votes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_argCheck__ = __webpack_require__(12);













var Configuration = function () {
  function Configuration() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        ownId = _ref.ownId;

    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, Configuration);

    this._ownId = __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].string(this, 'ownId', ownId);
    this._members = new Members();
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(Configuration, [{
    key: 'toString',
    value: function toString() {
      return 'config{members=' + [].concat(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default()(this._members)).join(',') + '}';
    }
  }, {
    key: 'createMembersChange',
    value: function createMembersChange(newMembers) {
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].instance('Configuration.createMembersChange', 'newMembers', newMembers, Members);
      return new ConfigurationData(newMembers);
    }
  }, {
    key: 'get',
    value: function get() {
      return new ConfigurationData(this._members);
    }
  }, {
    key: 'set',
    value: function set(data) {
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].instance('Configuration.set', 'data', data, ConfigurationData);
      this._members = data.members;
    }

    // for each server, including self

  }, {
    key: 'forEach',
    value: function forEach(func, thisArg) {
      this.members.forEach(func, thisArg);
    }

    // for each peer in the cluster

  }, {
    key: 'forEachPeer',
    value: function forEachPeer(func, thisArg) {
      var _this = this;

      this.members.forEach(function (peerId) {
        if (peerId !== _this._ownId) {
          func.call(_this.members, peerId);
        }
      }, thisArg);
    }
  }, {
    key: 'hasMajority',
    value: function hasMajority(grantedVotes) {
      return this._members.hasMajority(grantedVotes);
    }
  }, {
    key: 'getMajorityIndex',
    value: function getMajorityIndex(matchIndices) {
      return this._members.getMajorityIndex(matchIndices);
    }
  }, {
    key: 'ownId',
    get: function get() {
      return this._ownId;
    }
  }, {
    key: 'members',
    get: function get() {
      return new Members(this._members);
    }
  }]);

  return Configuration;
}();

/* harmony default export */ __webpack_exports__["a"] = (Configuration);


var ConfigurationData = function () {
  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(ConfigurationData, null, [{
    key: 'parse',
    value: function parse(data) {
      var _argCheck$object = __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].object(this, 'data', data),
          members = _argCheck$object.members;

      return new ConfigurationData(new Members(members));
    }
  }]);

  function ConfigurationData(members) {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, ConfigurationData);

    __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].instance(this, 'members', members, Members);
    this._members = members;
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(ConfigurationData, [{
    key: 'toString',
    value: function toString() {
      return 'configData{members=' + [].concat(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default()(this._members)).join(',') + '}';
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      // Only polyfilled sets serialize to arrays, so be explicit
      return { members: [].concat(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default()(this._members)) };
    }
  }, {
    key: 'includes',
    value: function includes(id) {
      if (this._members.has(id)) {
        return true;
      }
      return false;
    }
  }, {
    key: 'members',
    get: function get() {
      return this._members;
    }
  }]);

  return ConfigurationData;
}();

var Members = function (_Set) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(Members, _Set);

  function Members() {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, Members);

    return __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Members.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(Members)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(Members, [{
    key: 'voteCount',
    value: function voteCount(grantedVotes /* Set */) {
      var voteCount = 0;
      this.forEach(function (id) {
        if (grantedVotes.has(id)) {
          voteCount += 1;
        }
      });
      return voteCount;
    }
  }, {
    key: 'hasMajority',
    value: function hasMajority(grantedVotes /* Set */) {
      var voteCount = this.voteCount(grantedVotes);
      return voteCount >= this.majorityCount;
    }

    // Finds the greatest log index that a majority is guaranteed to have received

  }, {
    key: 'getMajorityIndex',
    value: function getMajorityIndex(matchIndices /* {[clientId]: matchIndex} */) {
      var indices = [];
      this.forEach(function (id) {
        if (matchIndices.hasOwnProperty(id)) {
          indices.push(matchIndices[id]);
        } else {
          indices.push(0);
        }
      });
      var majorityPosition = this.majorityIndexPosition;
      if (indices.length === 0 || indices.length < majorityPosition) {
        return 0;
      } else {
        return indices.sort()[majorityPosition - 1];
      }
    }
  }, {
    key: 'majorityCount',
    get: function get() {
      return (this.size / 2 | 0) + 1;
    }
  }, {
    key: 'minorityCount',
    get: function get() {
      return (this.size - 1) / 2 | 0;
    }
  }, {
    key: 'majorityIndexPosition',
    get: function get() {
      return (this.size + 1) / 2 | 0;
    }
  }]);

  return Members;
}(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default.a);

var Votes = function () {
  function Votes(ownId) {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, Votes);

    this._votes = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    if (ownId) {
      this.set(ownId, true);
    }
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(Votes, [{
    key: 'toString',
    value: function toString() {
      return 'votes{' + [].concat(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default()(this._votes)).map(function (_ref2) {
        var _ref3 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_ref2, 2),
            peerId = _ref3[0],
            granted = _ref3[1];

        return granted ? '>' + peerId + '<' : peerId;
      }) + '}';
    }
  }, {
    key: 'set',
    value: function set(peerId, granted) {
      return this._votes.set(peerId, granted);
    }
  }, {
    key: 'has',
    value: function has(peerId) {
      return this._votes.has(peerId);
    }
  }, {
    key: 'grantedVotes',
    get: function get() {
      var voters = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default.a();
      this._votes.forEach(function (granted, peerId) {
        if (granted) {
          voters.add(peerId);
        }
      });
      return voters;
    }
  }]);

  return Votes;
}();

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ConfigurationEntry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return OpEntry; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__ = __webpack_require__(132);














var TAG = 'raft';

var RaftLogEntry = function () {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(RaftLogEntry, null, [{
    key: 'parse',
    value: function parse(json, index) {
      // configuration entries have 2 elements, op entries have 3
      if (json.length === 2) {
        var _json = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default()(json, 2),
            term = _json[0],
            data = _json[1];

        return new ConfigurationEntry({ term: term, index: index, data: __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["b" /* ConfigurationData */].parse(data) });
      } else if (json.length === 4) {
        var _json2 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default()(json, 4),
            _term = _json2[0],
            id = _json2[1],
            op = _json2[2],
            args = _json2[3];

        return new OpEntry({ term: _term, index: index, id: id, op: op, args: args });
      } else {
        throw new TypeError('Failed to parse log entry data, invalid length: ' + json.length);
      }
    }
  }]);

  function RaftLogEntry(_ref) {
    var term = _ref.term,
        index = _ref.index;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, RaftLogEntry);

    if (this.constructor === RaftLogEntry) {
      throw new TypeError('RaftLogEntry should not by constructed directly');
    }
    this._term = term;
    this._index = index;
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(RaftLogEntry, [{
    key: 'term',
    get: function get() {
      return this._term;
    }
  }, {
    key: 'index',
    get: function get() {
      return this._index;
    }
  }]);

  return RaftLogEntry;
}();

/* harmony default export */ __webpack_exports__["c"] = (RaftLogEntry);


var ConfigurationEntry = function (_RaftLogEntry) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ConfigurationEntry, _RaftLogEntry);

  function ConfigurationEntry(_ref2) {
    var term = _ref2.term,
        index = _ref2.index,
        data = _ref2.data;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, ConfigurationEntry);

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConfigurationEntry.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ConfigurationEntry)).call(this, { term: term, index: index }));

    __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].instance(_this, 'data', data, __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["b" /* ConfigurationData */]);
    _this._data = data;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(ConfigurationEntry, [{
    key: 'toString',
    value: function toString() {
      return 'config{t=' + this.term + ',i=' + this.index + ',' + this.data + '}';
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return [this.term, this.data];
    }
  }, {
    key: 'data',
    get: function get() {
      return this._data;
    }
  }]);

  return ConfigurationEntry;
}(RaftLogEntry);

var OP = {
  noop: 0,
  set: 1,
  append: 2
};

var opNames = {
  0: 'noop',
  1: 'set',
  2: 'append'
};

var OpEntry = function (_RaftLogEntry2) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(OpEntry, _RaftLogEntry2);

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(OpEntry, null, [{
    key: 'idSize',
    get: function get() {
      return 8;
    }
  }]);

  function OpEntry(_ref3) {
    var term = _ref3.term,
        index = _ref3.index,
        _ref3$id = _ref3.id,
        id = _ref3$id === undefined ? 0 : _ref3$id,
        op = _ref3.op,
        _ref3$args = _ref3.args,
        args = _ref3$args === undefined ? [] : _ref3$args;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, OpEntry);

    var _this2 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (OpEntry.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(OpEntry)).call(this, { term: term, index: index }));

    _this2._id = id;
    _this2._op = op;
    _this2._args = args;
    return _this2;
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(OpEntry, [{
    key: 'toString',
    value: function toString() {
      var name = opNames[this.op];
      var args = this.args.join(',');
      var shortId = this.id ? this.id.slice(0, 4) : '<no>';
      return 'op{id=' + shortId + ',t=' + this.term + ',i=' + this.index + ',' + name + ',[' + args + ']}';
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return [this.term, this.id, this.op, this.args];
    }
  }, {
    key: 'apply',
    value: function apply(state) {
      if (this[this.op]) {
        __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, 'applying ' + this);
        return this[this.op].apply(this, [state].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(this.args)));
      } else {
        throw new TypeError('Failed to apply OpEntry, unknown op code: \'' + this.op + '\'');
      }
    }

    // methods for each op to modify state, args are passed in as parameters 2+
    // If the state is modified it should always be returned, and the other way around.

  }, {
    key: OP.noop,
    value: function value(state) {}
  }, {
    key: OP.set,
    value: function value(state, key, _value) {
      if (typeof key !== 'string') {
        throw new TypeError('Invalid OpEntry, set key must be a string');
      }
      if (typeof _value === 'undefined') {
        delete state[key];
      }
      state[key] = _value;
      return state;
    }
  }, {
    key: OP.append,
    value: function value(state, key, _value2) {
      if (typeof key !== 'string') {
        throw new TypeError('Invalid OpEntry, append key must be a string');
      }
      if (typeof _value2 === 'undefined') {
        return;
      }
      if (state[key]) {
        state[key].push(_value2);
      } else {
        state[key] = [_value2];
      }
      return state;
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'op',
    get: function get() {
      return this._op;
    }
  }, {
    key: 'args',
    get: function get() {
      return this._args;
    }
  }]);

  return OpEntry;
}(RaftLogEntry);

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42);
__webpack_require__(23);
__webpack_require__(29);
__webpack_require__(140);
__webpack_require__(143);
module.exports = __webpack_require__(0).Map;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(141);
module.exports = __webpack_require__(0).Object.keys;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42);
__webpack_require__(23);
__webpack_require__(29);
__webpack_require__(142);
module.exports = __webpack_require__(0).Promise;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(5)
  , macrotask = __webpack_require__(90).set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = __webpack_require__(30)(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = __webpack_require__(14)
  , aFunction = __webpack_require__(63)
  , SPECIES   = __webpack_require__(4)('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(80);

// 23.1 Map Objects
module.exports = __webpack_require__(82)('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(26)
  , $keys    = __webpack_require__(25);

__webpack_require__(46)('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY            = __webpack_require__(41)
  , global             = __webpack_require__(5)
  , ctx                = __webpack_require__(18)
  , classof            = __webpack_require__(44)
  , $export            = __webpack_require__(6)
  , isObject           = __webpack_require__(17)
  , aFunction          = __webpack_require__(63)
  , anInstance         = __webpack_require__(59)
  , forOf              = __webpack_require__(40)
  , speciesConstructor = __webpack_require__(139)
  , task               = __webpack_require__(90).set
  , microtask          = __webpack_require__(138)()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[__webpack_require__(4)('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(61)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
__webpack_require__(28)($Promise, PROMISE);
__webpack_require__(85)(PROMISE);
Wrapper = __webpack_require__(0)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(84)(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(6);

$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(81)('Map')});

/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_mediaNodeOutput__ = __webpack_require__(149);










/**
 * A base class for media nodes with a single output and no input. Typically used to represent nodes
 * that generate streams, or as a base for nodes with multiple inputs.
 *
 * The subclass should call the `setStream` method to update the output stream.
 *
 * @class MediaSource
 * @extends MediaNode
 * @extends ConnectMixin
 */

var MediaSource = function (_MediaNode$connectMix) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(MediaSource, _MediaNode$connectMix);

  function MediaSource() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, MediaSource);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (MediaSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(MediaSource)).call(this));

    _this._output = new __WEBPACK_IMPORTED_MODULE_6_media_mediaNodeOutput__["a" /* default */]({
      name: 'default',
      parent: _this
    });
    return _this;
  }

  /**
   * The current output stream.
   *
   * @readonly
   * @member {MediaStream} MediaSource#stream
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(MediaSource, [{
    key: 'setStream',


    /**
     * Sets the current output stream.
     *
     * This should only be called by the subclass implementation, not from outside the media node.
     *
     * @param {?MediaStream} stream - The new output stream, or null.
     */
    value: function setStream(stream) {
      this._output.setStream(stream);
    }
  }, {
    key: 'stream',
    get: function get() {
      return this._output.stream;
    }

    /**
     * The output.
     *
     * @readonly
     * @member {MediaNodeOutput} MediaSource#output
     */

  }, {
    key: 'output',
    get: function get() {
      return this._output;
    }
  }]);

  return MediaSource;
}(__WEBPACK_IMPORTED_MODULE_5_media_mediaNode__["a" /* default */].connectMixin(__WEBPACK_IMPORTED_MODULE_5_media_mediaNode__["a" /* default */]));

/* harmony default export */ __webpack_exports__["a"] = (MediaSource);

/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = CctError;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return NotAllowedError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return NotFoundError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return UnknownError; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_create__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_create___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_create__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_define_properties__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_define_properties__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_argCheck__ = __webpack_require__(12);










/**
 * Base class for all custom errors in the library.
 *
 * The main purpose of this class is to provide a cross-browser way to
 * subclass errors and have proper stack traces.
 *
 * It is safe to subclass this error in a babel environment, as opposed
 * to subclassing the `Error` builtin.
 *
 * The static `errorName` property is used to determine the default name
 * for instances of each subclass. The property is used to avoid problems
 * minification and should be set by all subclasses.
 *
 * @class CctError
 * @extends Error
 *
 * @example
 * class MyError extends CctError {
 *   constructor() {
 *     super('This is my error')
 *   }
 * }
 * MyError.errorName = 'MyError'
 */

// Need to do some trickery here to allow subclassing later on
// http://stackoverflow.com/questions/33870684
function CctError(message) {
  __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].stringOrEmpty('CctError constructor', 'message', message);
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_define_properties___default()(this, {
    message: {
      configurable: true,
      enumerable: true,
      value: message
    }
  });
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    var stack = new Error(message).stack;
    // IE11 does not initialize 'Error.stack' until the object is thrown.
    if (!stack) {
      try {
        throw new Error();
      } catch (e) {
        stack = e.stack;
      }
    }
    Object.defineProperty(this, 'stack', {
      configurable: true,
      enumerable: false,
      value: stack
    });
  }
}
CctError.errorName = 'CctError';

CctError.prototype = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_object_create___default()(Error.prototype, {
  constructor: { value: CctError },

  /**
   * The name of the error. Will always be set to the name of the class
   * unless something else is indicated.
   *
   * @readonly
   * @member {string} CctError#name
   */
  name: {
    get: function get() {
      return this.constructor.errorName;
    }
  },

  /**
   * Error objects are by default JSON serialized as `{"name":<name>,"message":<message>}`
   *
   * @method CctError#toJson
   * @returns {Object} - JSON representation of the error.
   */
  toJSON: {
    value: function value() {
      return {
        name: this.name,
        message: this.message
      };
    }
  },
  toString: {
    value: function value() {
      return this.name + ': ' + this.message;
    }
  }
});

/**
 * The requested action could not be performed because it is not allowed, e.g. the
 * authenticated user doesn't have enough power level, or a user media request was denied.
 *
 * Actions that are not allowed because the user has a guest account result in a
 * {@link GuestAccessError} instead of this.
 *
 * @class NotAllowedError
 * @extends CctError
 */
var NotAllowedError = function (_CctError) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(NotAllowedError, _CctError);

  function NotAllowedError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, NotAllowedError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (NotAllowedError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(NotAllowedError)).apply(this, arguments));
  }

  return NotAllowedError;
}(CctError);
NotAllowedError.errorName = 'NotAllowedError';

/**
 * The requested resource could not be found, e.g. when looking up a room by alias
 * or requesting a media source.
 *
 * @class NotFoundError
 * @extends CctError
 */
var NotFoundError = function (_CctError2) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(NotFoundError, _CctError2);

  function NotFoundError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, NotFoundError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (NotFoundError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(NotFoundError)).apply(this, arguments));
  }

  return NotFoundError;
}(CctError);
NotFoundError.errorName = 'NotFoundError';

/**
 * The cause of the error could not be determined. Seeing this error is in itself an error
 * because the real error reason should always be possible to determine.
 *
 * @class UnknownError
 * @extends CctError
 */
var UnknownError = function (_CctError3) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(UnknownError, _CctError3);

  function UnknownError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, UnknownError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (UnknownError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(UnknownError)).apply(this, arguments));
  }

  return UnknownError;
}(CctError);
UnknownError.errorName = 'UnknownError';

/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_symbol__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_symbol___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_symbol__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_mediaSink__ = __webpack_require__(153);













var TAG = 'html-sink';

var replacement = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_symbol___default()('sink-replacement');

/**
 * A media sink that renders to a target HTML media element, either `<audio>` or `<video>`.
 *
 * @class HtmlSink
 * @extends MediaSink
 * @param {Object} [options] - Optional options object.
 * @param {external:HTMLMediaElement} target - The target HTML element.
 */

var HtmlSink = function (_MediaSink) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(HtmlSink, _MediaSink);

  function HtmlSink() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$target = _ref.target,
        target = _ref$target === undefined ? null : _ref$target;

    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, HtmlSink);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (HtmlSink.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(HtmlSink)).call(this));

    var bail = 0;
    while (target && target[replacement] && bail < 5) {
      target = target[replacement];
      bail += 1;
    }
    if (bail >= 5) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'HtmlSink got stuck in element replacement loop');
    }
    _this._target = target;
    _this._refreshSink = _this._refreshSink.bind(_this);
    _this._refreshTick = null;
    return _this;
  }

  /**
   * The target HTML element to render to.
   *
   * This can be updated at any time.
   *
   * @member {external:HTMLMediaElement} HtmlSink#target
   */


  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(HtmlSink, [{
    key: '_hasTarget',
    value: function _hasTarget(target) {
      if (this._target === target) {
        return true;
      } else if (this._target === target[replacement]) {
        return true;
      }
      return false;
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'onStream',
    value: function onStream(stream, oldStream) {
      var _this2 = this;

      if (oldStream) {
        if (oldStream.removeEventListener) {
          oldStream.removeEventListener('addtrack', this._refreshSink);
          oldStream.removeEventListener('removetrack', this._refreshSink);
        } else {
          oldStream.detachEvent('addtrack', this._refreshSink);
          oldStream.detachEvent('removetrack', this._refreshSink);
        }
      }
      if (stream) {
        if (stream.addEventListener) {
          stream.addEventListener('addtrack', this._refreshSink);
          stream.addEventListener('removetrack', this._refreshSink);
        } else {
          stream.attachEvent('addtrack', this._refreshSink);
          stream.attachEvent('removetrack', this._refreshSink);
        }
      }
      if (!this._refreshTick) {
        this._refreshTick = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject().catch(function () {
          _this2._refreshTick = null;
          if (_this2.stream !== oldStream) {
            _this2._refreshSink();
          }
        });
      }
    }
  }, {
    key: '_cleanup',
    value: function _cleanup() {
      if (this._target && this._target instanceof HTMLMediaElement) {
        if (this._target.srcObject) {
          this._target.srcObject = null;
        } else if (this._target.src) {
          this._target.src = '';
        }
      } else {
        this._target = window.attachMediaStream(this._target, null);
      }
    }
  }, {
    key: '_assign',
    value: function _assign() {
      if (this.stream) {
        try {
          var originalElement = this._target;
          this._target = window.attachMediaStream(this._target, this.stream);
          if (originalElement instanceof HTMLMediaElement) {
            originalElement[replacement] = this._target;
          }
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'Error when assigning html sink stream: ' + error);
        }
        try {
          var result = this._target.play();
          if (result && result.catch) {
            result.catch(function (error) {
              __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, 'Failed to play stream, ' + error);
            });
          }
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'Error when playing html sink stream: ' + error);
        }
      }
    }
  }, {
    key: '_refreshSink',
    value: function _refreshSink() {
      if (this._target) {
        this._cleanup();
        this._assign();
      }
    }
  }, {
    key: 'target',
    get: function get() {
      return this._target;
    },
    set: function set(target) {
      if (this._target) {
        this._cleanup();
      }
      this._target = target || null;
      if (target) {
        this._assign();
      }
    }
  }]);

  return HtmlSink;
}(__WEBPACK_IMPORTED_MODULE_8_media_mediaSink__["a" /* default */]);

/* harmony default export */ __webpack_exports__["default"] = (HtmlSink);

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return AppendEntriesRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return AppendEntriesResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return RequestVoteRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return RequestVoteResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return PreVoteRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return PreVoteResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return SnapshotRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return SnapshotResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return StateOpRequest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return StateOpResponse; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_toArray__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_toArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_toArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_conference_raftLogEntry__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_conference_meshTopology__ = __webpack_require__(152);
















var RaftMessage = function () {
  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(RaftMessage, null, [{
    key: 'parse',
    value: function parse(body) {
      if (!Array.isArray(body)) {
        throw new TypeError('RaftMessage body must be an array');
      }

      var _body = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_toArray___default()(body),
          id = _body[0],
          params = _body.slice(1);

      var MessageConstructor = messageConstructors[id];
      if (!MessageConstructor) {
        throw new TypeError('Failed to parse invalid raft message, unknown id: ' + id);
      }
      return new (Function.prototype.bind.apply(MessageConstructor, [null].concat(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray___default()(params))))();
    }
  }]);

  function RaftMessage(term) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, RaftMessage);

    this._term = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(this, 'term', term);
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(RaftMessage, [{
    key: 'toJSON',
    value: function toJSON() {
      return [this.constructor.id].concat(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray___default()(this.params));
    }
  }, {
    key: 'term',
    get: function get() {
      return this._term;
    }
  }, {
    key: 'isRequest',
    get: function get() {
      return !(this.constructor.id & 1);
    }
  }]);

  return RaftMessage;
}();

/* harmony default export */ __webpack_exports__["a"] = (RaftMessage);


var AppendEntriesRequest = function (_RaftMessage) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(AppendEntriesRequest, _RaftMessage);

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(AppendEntriesRequest, null, [{
    key: 'create',
    value: function create(_ref) {
      var term = _ref.term,
          topologyIndex = _ref.topologyIndex,
          prevIndex = _ref.prevIndex,
          prevTerm = _ref.prevTerm,
          commitIndex = _ref.commitIndex,
          entries = _ref.entries;

      return new AppendEntriesRequest(term, topologyIndex, prevIndex, prevTerm, commitIndex, entries);
    }
  }]);

  function AppendEntriesRequest(term, topologyIndex, prevIndex, prevTerm, commitIndex, entries) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, AppendEntriesRequest);

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AppendEntriesRequest.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(AppendEntriesRequest)).call(this, term));

    _this._topologyIndex = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this, 'topologyIndex', topologyIndex);
    _this._prevIndex = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this, 'prevIndex', prevIndex);
    _this._prevTerm = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this, 'prevTerm', prevTerm);
    _this._commitIndex = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this, 'commitIndex', commitIndex);
    _this._entries = entries.map(function (entry, index) {
      var entryIndex = _this._prevIndex + index + 1;
      entry = entry instanceof __WEBPACK_IMPORTED_MODULE_10_conference_raftLogEntry__["c" /* default */] ? entry : __WEBPACK_IMPORTED_MODULE_10_conference_raftLogEntry__["c" /* default */].parse(entry, entryIndex);
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this, 'entry.term', entry.term);
      return entry;
    });
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(AppendEntriesRequest, [{
    key: 'toString',
    value: function toString() {
      return 'appendRequest{' + ('term=' + this.term + ',ti=' + this._topologyIndex + ',') + ('pi=' + this._prevIndex + ',pt=' + this._prevTerm + ',') + ('ci=' + this._commitIndex + ',es=[' + this._entries + ']}');
    }
  }, {
    key: 'response',
    value: function response() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _options$term = options.term,
          term = _options$term === undefined ? this._term : _options$term,
          _options$success = options.success,
          success = _options$success === undefined ? false : _options$success,
          _options$needSnapshot = options.needSnapshot,
          needSnapshot = _options$needSnapshot === undefined ? false : _options$needSnapshot,
          meshTopology = options.meshTopology,
          _options$matchIndex = options.matchIndex,
          matchIndex = _options$matchIndex === undefined ? this._prevIndex - 1 : _options$matchIndex;


      var localTopologyInfo = meshTopology && meshTopology.localTopologyInfo;
      var topologyInfo = null;
      var topologyIndex = localTopologyInfo && localTopologyInfo.topologyIndex;
      if (topologyIndex > this.topologyIndex) {
        topologyInfo = localTopologyInfo;
      }
      var volume = localTopologyInfo ? localTopologyInfo.volume : 0;

      var flag = APPEND_ENTRIES_RESPONSE_FLAG_SUCCESS;
      if (!success) {
        flag = APPEND_ENTRIES_RESPONSE_FLAG_FAILURE;
      }
      if (needSnapshot) {
        flag = APPEND_ENTRIES_RESPONSE_FLAG_NEED_SNAPSHOT;
      }

      return new AppendEntriesResponse(term, flag, topologyIndex, topologyInfo, volume, matchIndex);
    }
  }, {
    key: 'params',
    get: function get() {
      return [this._term, this._topologyIndex, this._prevIndex, this._prevTerm, this._commitIndex, this._entries];
    }

    // topologyIndex is an addition to the Raft algorithm. The purpose is for the leader
    // to get a complete view of the topology of the cluster, while keeping network use low.
    // Each member will send information about their active connections in the AppendEntries
    // response, but only if the received topology index is lower than their own one.
    //
    // Followers will increment their topologyIndex whenever a significant change is made to
    // their active connections, e.g. added and removed connections, as well as changes in
    // latency or bandwidth. The initial implementation will only take added and removed
    // connections into account, and use a timeout to make sure relatively up-to-date network
    // information is transmitted. The downside is that it will require slightly more bandwidth,
    // and that bit changes in network characteristics won't be detected as quickly by the leader.
    //
    // Just like terms and log indices, the topology index is an integer that is always
    // incremented during normal operation. The follower increments it as discussed above
    // and the leader increments their topologyIndex as updates are received from the follower.
    // Just like the matchIndex the leader keeps track of the remote topologyIndex separately
    // for each cluster member.
    //
    // New leaders will use a topologyIndex of 0 in the first appendEntries request sent to
    // all members when they get elected, and the followers will then always respond with their
    // current connection state and topologyIndex.

  }, {
    key: 'topologyIndex',
    get: function get() {
      return this._topologyIndex;
    }
  }, {
    key: 'prevIndex',
    get: function get() {
      return this._prevIndex;
    }
  }, {
    key: 'prevTerm',
    get: function get() {
      return this._prevTerm;
    }
  }, {
    key: 'commitIndex',
    get: function get() {
      return this._commitIndex;
    }
  }, {
    key: 'entries',
    get: function get() {
      return this._entries;
    }
  }]);

  return AppendEntriesRequest;
}(RaftMessage);

var APPEND_ENTRIES_RESPONSE_FLAG_SUCCESS = 0;
var APPEND_ENTRIES_RESPONSE_FLAG_FAILURE = 1;
var APPEND_ENTRIES_RESPONSE_FLAG_NEED_SNAPSHOT = 2;

var AppendEntriesResponse = function (_RaftMessage2) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(AppendEntriesResponse, _RaftMessage2);

  function AppendEntriesResponse(term, flag) {
    var topologyIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
    var topologyInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var volume = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var matchIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;

    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, AppendEntriesResponse);

    var _this2 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AppendEntriesResponse.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(AppendEntriesResponse)).call(this, term));

    _this2._flag = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this2, 'flag', flag);
    _this2._topologyIndex = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this2, 'topologyIndex', topologyIndex);
    _this2._matchIndex = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this2, 'matchIndex', matchIndex);
    if (topologyInfo) {
      _this2._topologyInfo = __WEBPACK_IMPORTED_MODULE_11_conference_meshTopology__["b" /* PeerTopologyInfo */].parseUpdate(topologyInfo);
    } else {
      _this2._topologyInfo = null;
    }
    _this2._volume = volume;
    return _this2;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(AppendEntriesResponse, [{
    key: 'toString',
    value: function toString() {
      var topologyInfo = null;
      if (this._topologyInfo) {
        topologyInfo = 'topologyInfo{power=' + this._topologyInfo.power + ',' + this._topologyInfo.links + '}';
      }
      return 'appendResponse{' + ('term=' + this.term + ',flag=' + this._flag + ',mi=' + this._matchIndex + ',v=' + this._volume + ',') + ('ti=' + this._topologyIndex + ',' + topologyInfo + '}');
    }
  }, {
    key: 'params',
    get: function get() {
      return [this._term, this._flag, this._topologyIndex, this._topologyInfo || 0, this._volume || 0, this._matchIndex];
    }
  }, {
    key: 'success',
    get: function get() {
      return this._flag === APPEND_ENTRIES_RESPONSE_FLAG_SUCCESS;
    }
  }, {
    key: 'needSnapshot',
    get: function get() {
      return this._flag === APPEND_ENTRIES_RESPONSE_FLAG_NEED_SNAPSHOT;
    }
  }, {
    key: 'topologyIndex',
    get: function get() {
      return this._topologyIndex;
    }
  }, {
    key: 'topologyInfo',
    get: function get() {
      return this._topologyInfo;
    }
  }, {
    key: 'matchIndex',
    get: function get() {
      return this._matchIndex;
    }
  }, {
    key: 'volume',
    get: function get() {
      return this._volume;
    }
  }]);

  return AppendEntriesResponse;
}(RaftMessage);

var RequestVoteRequest = function (_RaftMessage3) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(RequestVoteRequest, _RaftMessage3);

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(RequestVoteRequest, null, [{
    key: 'create',
    value: function create(_ref2) {
      var term = _ref2.term,
          lastLogTerm = _ref2.lastLogTerm,
          lastLogIndex = _ref2.lastLogIndex;

      return new RequestVoteRequest(term, lastLogTerm, lastLogIndex);
    }
  }]);

  function RequestVoteRequest(term, lastLogTerm, lastLogIndex) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, RequestVoteRequest);

    var _this3 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (RequestVoteRequest.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(RequestVoteRequest)).call(this, term));

    _this3._lastLogTerm = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this3, 'lastLogTerm', lastLogTerm);
    _this3._lastLogIndex = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this3, 'lastLogIndex', lastLogIndex);
    return _this3;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(RequestVoteRequest, [{
    key: 'toString',
    value: function toString() {
      return 'voteRequest{term=' + this.term + '}';
    }
  }, {
    key: 'compareLog',
    value: function compareLog(other) {
      var lastLogTerm = other.lastLogTerm;

      if (this.lastLogTerm !== lastLogTerm) {
        return this.lastLogTerm - lastLogTerm;
      } else {
        return this.lastLogIndex - other.lastLogIndex;
      }
    }
  }, {
    key: 'response',
    value: function response(_ref3) {
      var _ref3$granted = _ref3.granted,
          granted = _ref3$granted === undefined ? false : _ref3$granted;

      return new RequestVoteResponse(this._term, granted);
    }
  }, {
    key: 'params',
    get: function get() {
      return [this._term, this._lastLogTerm, this._lastLogIndex];
    }
  }, {
    key: 'lastLogTerm',
    get: function get() {
      return this._lastLogTerm;
    }
  }, {
    key: 'lastLogIndex',
    get: function get() {
      return this._lastLogIndex;
    }
  }]);

  return RequestVoteRequest;
}(RaftMessage);

var RequestVoteResponse = function (_RaftMessage4) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(RequestVoteResponse, _RaftMessage4);

  function RequestVoteResponse(term, granted) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, RequestVoteResponse);

    var _this4 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (RequestVoteResponse.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(RequestVoteResponse)).call(this, term));

    _this4._granted = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].boolean(_this4, 'granted', granted);
    return _this4;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(RequestVoteResponse, [{
    key: 'toString',
    value: function toString() {
      return 'voteResponse{term=' + this.term + ',granted=' + this.granted + '}';
    }
  }, {
    key: 'params',
    get: function get() {
      return [this._term, this._granted];
    }
  }, {
    key: 'granted',
    get: function get() {
      return this._granted;
    }
  }]);

  return RequestVoteResponse;
}(RaftMessage);

// PreVote RPC is an extension for the Raft algorithm that lets low-population
// clusters find a leader faster, and prevents many cases of leader flip-flopping.
//
// The implementation is based on the suggested modifications in
// "Three modifications for the Raft consensus algorithm" by Henrik Ingo
// http://openlife.cc/system/files/3-modifications-for-Raft-consensus.pdf
var PreVoteRequest = function (_RequestVoteRequest) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(PreVoteRequest, _RequestVoteRequest);

  function PreVoteRequest() {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, PreVoteRequest);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (PreVoteRequest.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(PreVoteRequest)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(PreVoteRequest, [{
    key: 'toString',
    value: function toString() {
      return 'preVoteRequest{term=' + this.term + '}';
    }
  }, {
    key: 'response',
    value: function response(_ref4) {
      var _ref4$granted = _ref4.granted,
          granted = _ref4$granted === undefined ? false : _ref4$granted;

      return new PreVoteResponse(this._term, granted);
    }
  }], [{
    key: 'create',
    value: function create(_ref5) {
      var term = _ref5.term,
          lastLogTerm = _ref5.lastLogTerm,
          lastLogIndex = _ref5.lastLogIndex;

      return new PreVoteRequest(term, lastLogTerm, lastLogIndex);
    }
  }]);

  return PreVoteRequest;
}(RequestVoteRequest);

var PreVoteResponse = function (_RequestVoteResponse) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(PreVoteResponse, _RequestVoteResponse);

  function PreVoteResponse() {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, PreVoteResponse);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (PreVoteResponse.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(PreVoteResponse)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(PreVoteResponse, [{
    key: 'toString',
    value: function toString() {
      return 'preVoteResponse{term=' + this.term + ',granted=' + this.granted + '}';
    }
  }]);

  return PreVoteResponse;
}(RequestVoteResponse);

var SnapshotRequest = function (_RaftMessage5) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(SnapshotRequest, _RaftMessage5);

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(SnapshotRequest, null, [{
    key: 'create',
    value: function create(_ref6) {
      var term = _ref6.term,
          lastTerm = _ref6.lastTerm,
          lastIndex = _ref6.lastIndex,
          configuration = _ref6.configuration,
          state = _ref6.state;

      return new SnapshotRequest(term, lastTerm, lastIndex, configuration, state);
    }
  }]);

  function SnapshotRequest(term, lastTerm, lastIndex, configuration, state) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, SnapshotRequest);

    var _this7 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (SnapshotRequest.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(SnapshotRequest)).call(this, term));

    _this7._lastTerm = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this7, 'lastTerm', lastTerm);
    _this7._lastIndex = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this7, 'lastIndex', lastIndex);
    if (!(configuration instanceof __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["b" /* ConfigurationData */])) {
      configuration = __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["b" /* ConfigurationData */].parse(configuration);
    }
    _this7._configuration = configuration;
    _this7._state = state;
    return _this7;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(SnapshotRequest, [{
    key: 'toString',
    value: function toString() {
      return 'snapshotRequest{term=' + this.term + ',li=' + this.lastIndex + ',lt=' + this.lastTerm + (',' + this.configuration + ',' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.state) + '}');
    }
  }, {
    key: 'response',
    value: function response() {
      return new SnapshotResponse(this._term, this._lastTerm, this._lastIndex);
    }
  }, {
    key: 'params',
    get: function get() {
      return [this._term, this._lastTerm, this._lastIndex, this._configuration, this._state];
    }
  }, {
    key: 'lastTerm',
    get: function get() {
      return this._lastTerm;
    }
  }, {
    key: 'lastIndex',
    get: function get() {
      return this._lastIndex;
    }
  }, {
    key: 'configuration',
    get: function get() {
      return this._configuration;
    }
  }, {
    key: 'state',
    get: function get() {
      return this._state;
    }
  }]);

  return SnapshotRequest;
}(RaftMessage);

var SnapshotResponse = function (_RaftMessage6) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(SnapshotResponse, _RaftMessage6);

  function SnapshotResponse(term, lastTerm, lastIndex) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, SnapshotResponse);

    var _this8 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (SnapshotResponse.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(SnapshotResponse)).call(this, term));

    _this8._lastTerm = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this8, 'lastTerm', lastTerm);
    _this8._lastIndex = __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number(_this8, 'lastIndex', lastIndex);
    return _this8;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(SnapshotResponse, [{
    key: 'toString',
    value: function toString() {
      return 'snapshotResponse{term=' + this.term + ',li=' + this.lastIndex + ',lt=' + this.lastTerm + '}';
    }
  }, {
    key: 'params',
    get: function get() {
      return [this._term, this._lastTerm, this._lastIndex];
    }
  }, {
    key: 'lastTerm',
    get: function get() {
      return this._lastTerm;
    }
  }, {
    key: 'lastIndex',
    get: function get() {
      return this._lastIndex;
    }
  }]);

  return SnapshotResponse;
}(RaftMessage);

var StateOpRequest = function (_RaftMessage7) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(StateOpRequest, _RaftMessage7);

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(StateOpRequest, null, [{
    key: 'create',
    value: function create(_ref7) {
      var id = _ref7.id,
          op = _ref7.op,
          args = _ref7.args;

      return new StateOpRequest(id, op, args);
    }
  }]);

  function StateOpRequest(id, op, args) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, StateOpRequest);

    var _this9 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StateOpRequest.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(StateOpRequest)).call(this, 0));

    _this9._id = id;
    _this9._op = op;
    _this9._args = args;
    return _this9;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(StateOpRequest, [{
    key: 'toString',
    value: function toString() {
      return 'stateOpRequest{id=' + this._id + ',op=' + this._op + ',args=' + this._args + '}';
    }
  }, {
    key: 'response',
    value: function response() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$errorCode = _ref8.errorCode,
          errorCode = _ref8$errorCode === undefined ? 0 : _ref8$errorCode;

      return new StateOpResponse(this._id, errorCode);
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'op',
    get: function get() {
      return this._op;
    }
  }, {
    key: 'args',
    get: function get() {
      return this._args;
    }
  }, {
    key: 'params',
    get: function get() {
      return [this._id, this._op, this._args];
    }
  }]);

  return StateOpRequest;
}(RaftMessage);

var StateOpResponse = function (_RaftMessage8) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(StateOpResponse, _RaftMessage8);

  function StateOpResponse(id, errorCode) {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, StateOpResponse);

    var _this10 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StateOpResponse.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(StateOpResponse)).call(this, 0));

    _this10._id = id;
    _this10._errorCode = errorCode;
    return _this10;
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(StateOpResponse, [{
    key: 'toString',
    value: function toString() {
      return 'stateOpResponse{id=' + this._id + ',errorCode=' + this._errorCode + '}';
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'errorCode',
    get: function get() {
      return this._errorCode;
    }
  }, {
    key: 'params',
    get: function get() {
      return [this._id, this._errorCode];
    }
  }]);

  return StateOpResponse;
}(RaftMessage);
StateOpResponse.NOT_LEADER = 1;

AppendEntriesRequest.id = 2;
AppendEntriesResponse.id = 3;
RequestVoteRequest.id = 4;
RequestVoteResponse.id = 5;
PreVoteRequest.id = 6;
PreVoteResponse.id = 7;
SnapshotRequest.id = 8;
SnapshotResponse.id = 9;
StateOpRequest.id = 10;
StateOpResponse.id = 11;

var messageConstructors = {
  2: AppendEntriesRequest,
  3: AppendEntriesResponse,
  4: RequestVoteRequest,
  5: RequestVoteResponse,
  6: PreVoteRequest,
  7: PreVoteResponse,
  8: SnapshotRequest,
  9: SnapshotResponse,
  10: StateOpRequest,
  11: StateOpResponse
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

var core  = __webpack_require__(0)
  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_common__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__ = __webpack_require__(131);













var TAG = 'media-node-output';

/**
 * A class which represents an output of a {@link MediaNode}. Outputs are connected to
 * inputs in order to forward media streams.
 *
 * This class should only be used within the implementation of {@link MediaNode}s. While it
 * is possible to attach outputs to an existing media node, it should be avoided. Use an additional
 * media node to implement the desired behaviour instead, such as a {@link Passthrough}.
 *
 * @class MediaNodeOutput
 * @param {Object} options - Options object.
 * @param {string} options.name - The name of the output, should be 'default' for single outputs.
 * @param {MediaNode} options.parent - The parent media node.
 */

var MediaNodeOutput = function () {
  function MediaNodeOutput(_ref) {
    var name = _ref.name,
        parent = _ref.parent;

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, MediaNodeOutput);

    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('MediaNodeInput constructor', 'name', name);
    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_media_common__["d" /* isMediaNode */])(parent)) {
      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('MediaNodeInput constructor', 'parent', 'be a MediaNode');
    }
    this._name = name;
    this._parent = parent;
    this._targets = new __WEBPACK_IMPORTED_MODULE_4_common_utils__["ReadOnlySet"]();
    this._stream = null;

    this._parent[__WEBPACK_IMPORTED_MODULE_6_media_common__["b" /* outputs */]].add(this);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(MediaNodeOutput, [{
    key: 'toString',
    value: function toString() {
      return 'mediaNodeOutput{name=' + this.name + ',parent=' + this._parent + ',targets=' + this._targets.size + '}}';
    }

    /**
     * Resolves the output of a target. If the lookup fails, an error will be thrown.
     *
     * Outputs are resolved as follows, starting with a target:
     *   1. If the current target is a {@link MediaNodeOutput} instance, stop and return the target.
     *   2. If the target is an object, set the new target to the `output` property of the target, and start over.
     *   3. Throw error.
     *
     * If a circular output object structure is encountered, an error will be thrown.
     *
     * @param {MediaNodeOutput|Object} target - The target to resolve the output of.
     * @returns {MediaNodeOutput} The resolved output.
     */

  }, {
    key: 'connect',


    /**
     * Connect this output to a target. Each output can be connected to multiple targets.
     *
     * @param {MediaNodeConnectTarget} target - The target to connect the output to.
     */
    value: function connect(target) {
      if (!this._parent) {
        return __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'tried to connect a detached ouput');
      }

      if (target instanceof HTMLElement) {
        // require here to avoid circular dependency
        var HtmlSink = __webpack_require__(146).default;
        var sink = new HtmlSink({ target: target });
        this.connect(sink);
        return;
      }

      target = __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__["a" /* default */].resolve(target);
      __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].info(TAG, 'connecting ' + this + ' to ' + target);
      if (this._targets.has(target)) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].verbose(TAG, 'ignored connect with same target');
        return;
      }
      if (!target._parent) {
        return __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'tried to connect to a detached input');
      }
      if (target._target) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'disconnecting target\'s existing target: ' + target._target);
        target._target.disconnect(target);
      }
      __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'connecting to new target: ' + target);
      this._targets._add(target);
      target._target = this;
      target._setStream(this._stream);
    }

    /**
     * Disconnect this output from a target.
     *
     * If no target is specified, all targets will be disconnected.
     *
     * @param {MediaNodeConnectTarget} [target] - The target to disconnect from.
     */

  }, {
    key: 'disconnect',
    value: function disconnect(target) {
      var _this = this;

      if (!this._parent) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'tried to disconnect a detached ouput');
        return;
      }
      if (this._targets.size === 0) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].warning(TAG, 'tried to disconnect ' + this + ', but it is not connected to anything');
        return;
      }

      if (target instanceof HTMLElement) {
        // Iterate through the targets and find html sinks with the input as target
        this._targets.forEach(function (possibleSinkInput) {
          // require here to avoid circular dependency
          var HtmlSink = __webpack_require__(146).default;
          var isHtmlSink = possibleSinkInput._parent instanceof HtmlSink;
          var sinkHasTargetAsTarget = possibleSinkInput._parent._hasTarget(target);
          if (isHtmlSink && sinkHasTargetAsTarget) {
            _this.disconnect(possibleSinkInput);
          }
        });
      } else if (target) {
        target = __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__["a" /* default */].resolve(target);
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].info(TAG, 'disconnecting ' + this + ' from ' + target);
        if (this._targets._delete(target)) {
          target._target = null;
          target._setStream(null);
        } else {
          throw new Error('failed to disconnect ' + this + ' from ' + target + ', not connected');
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].info(TAG, 'disconnecting ' + this + ' from all ' + this._targets.size + ' targets');
        this._targets.forEach(function (target) {
          __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].info(TAG, 'disconnecting ' + _this + ' from ' + target);
          target._target = null;
          target._setStream(null);
        });
        this._targets._clear();
      }
    }

    /**
     * Sets the current stream of this output.
     *
     * This method is internal and should only be called by the implementation of the parent media node.
     *
     * @param {MediaStream} stream - A media stream, or null.
     */

  }, {
    key: 'setStream',
    value: function setStream(stream) {
      if (!this._parent) {
        return __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'tried to setStream of a detached ouput');
      }
      if (stream === null || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_webrtc_utils__["isMediaStream"])(stream)) {
        this._stream = stream;
        this._targets.forEach(function (target) {
          return target._setStream(stream);
        });
      } else {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('MediaNodeOutput.setStream', 'stream', 'be a MediaStream or null');
      }
    }

    /**
     * Detaches the output from it's parent and removes any connections. Use this to clean up outputs
     * in media nodes with dynamic outputs, such as a media demultiplexer. After this method has been called
     * the input can no longer be used.
     *
     * This method is internal and should only be called by the implementation of the parent media node.
     */

  }, {
    key: 'detach',
    value: function detach() {
      this.disconnect();
      this._parent[__WEBPACK_IMPORTED_MODULE_6_media_common__["b" /* outputs */]].delete(this);
      this._parent = null;
    }
  }, {
    key: 'name',


    /**
     * The name of this output. This is only meaningful for outputs that belong to media nodes with
     * multiple outputs.
     *
     * Any output that belong to one of the base media node implementations, such as {@link MediaSource},
     * will have the name `'default'`.
     *
     * @readonly
     * @member {string} MediaNodeOutput#name
     */
    get: function get() {
      return this._name;
    }

    /**
     * A read-only set of all the current targets of the output.
     *
     * The set will only contain resolved inputs, and not the original targets given to the connect method.
     *
     * @readonly
     * @member {ReadOnlySet<MediaNodeInput>} MediaNodeOutput#targets
     */

  }, {
    key: 'targets',
    get: function get() {
      return this._targets;
    }

    /**
     * The output's current media stream, or null.
     *
     * @readonly
     * @member {MediaStream} MediaNodeOutput#stream
     */

  }, {
    key: 'stream',
    get: function get() {
      return this._stream;
    }
  }], [{
    key: 'resolve',
    value: function resolve(target) {
      var chain = [target];
      for (;;) {
        if (target instanceof MediaNodeOutput) {
          return target;
        } else if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["isObject"])(target)) {
          throw new TypeError('failed to resolve output of ' + (chain[0] && chain[0].constructor.name) + ', ' + 'output must be a MediaNodeOutput or have an output property');
        } else if ('output' in target) {
          try {
            target = target.output;
          } catch (error) {
            throw new TypeError('failed to resolve output of ' + chain[0].constructor.name + ', ' + ('getting output property of ' + target + ' threw error: ' + error.message));
          }
          if (chain.indexOf(target) !== -1) {
            throw new TypeError('failed to resolve output of ' + chain[0].constructor.name + ', ' + 'encountered loop in output property chain');
          }
          chain.push(target);
        } else {
          throw new TypeError('failed to resolve output of ' + chain[0].constructor.name + ', ' + (target.constructor.name + ' does not have an output property'));
        }
      }
    }
  }]);

  return MediaNodeOutput;
}();

/* harmony default export */ __webpack_exports__["a"] = (MediaNodeOutput);

/***/ }),
/* 150 */,
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(155), __esModule: true };

/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LinkInfo; });
/* unused harmony export LinkInfos */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PeerTopologyInfo; });
/* unused harmony export LocalTopologyInfo */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_utils__ = __webpack_require__(13);













var TAG = 'mesh-topology';

var LinkInfo = function () {
  function LinkInfo(_ref) {
    var _ref$rttMs = _ref.rttMs,
        rttMs = _ref$rttMs === undefined ? -1 : _ref$rttMs,
        _ref$bandwidth = _ref.bandwidth,
        bandwidth = _ref$bandwidth === undefined ? -1 : _ref$bandwidth,
        _ref$up = _ref.up,
        up = _ref$up === undefined ? false : _ref$up,
        onUpdate = _ref.onUpdate;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, LinkInfo);

    this._rttMs = __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].number(this, 'rttMs', rttMs);
    this._bandwidth = __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].number(this, 'bandwidth', bandwidth);
    this._up = __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].boolean(this, 'up', up);
    this._onUpdate = onUpdate;
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(LinkInfo, [{
    key: 'update',
    value: function update(info) {
      var _info$rttMs = info.rttMs,
          rttMs = _info$rttMs === undefined ? null : _info$rttMs,
          _info$bandwidth = info.bandwidth,
          bandwidth = _info$bandwidth === undefined ? null : _info$bandwidth,
          _info$up = info.up,
          up = _info$up === undefined ? null : _info$up;

      if (rttMs !== null) {
        this._rttMs = __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].number('LinkInfo.update', 'rttMs', rttMs);
      }
      if (bandwidth !== null) {
        this._bandwidth = __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].number('LinkInfo.update', 'bandwidth', bandwidth);
      }
      var oldUp = this._up;
      if (up !== null) {
        this._up = __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].boolean('LinkInfo.update', 'up', up);
      }
      if (this._onUpdate) {
        var changedUpState = oldUp !== this._up;
        this._onUpdate(changedUpState);
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'link{' + (this._up ? 'up' : 'down') + ',rttMs=' + this._rttMs + ',bw=' + this._bandwidth + '}';
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      if (this._up) {
        return [this._rttMs, this._bandwidth];
      } else {
        return [];
      }
    }
  }, {
    key: 'up',
    get: function get() {
      return this._up;
    }
  }, {
    key: 'rttMs',
    get: function get() {
      return this._rttMs;
    }
  }, {
    key: 'bandwidth',
    get: function get() {
      return this._bandwidth;
    }
  }], [{
    key: 'parse',
    value: function parse(data) {
      if (data.constructor === LinkInfo) {
        return data;
      } else if (Array.isArray(data)) {
        if (!data.length) {
          return new LinkInfo({ up: false });
        }

        var _data = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default()(data, 2),
            rttMs = _data[0],
            bandwidth = _data[1];

        return new LinkInfo({ rttMs: rttMs, bandwidth: bandwidth, up: true });
      } else {
        throw new TypeError('Could not parse link info data, ' + data);
      }
    }
  }]);

  return LinkInfo;
}();

var LinkInfos = function () {
  function LinkInfos() {
    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, LinkInfos);
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(LinkInfos, [{
    key: 'toString',
    value: function toString() {
      var _this = this;

      return 'linkInfos{' + __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_keys___default()(this).map(function (peerId) {
        return peerId + ':' + _this[peerId];
      }).join(',') + '}';
    }
  }], [{
    key: 'parse',
    value: function parse(data) {
      var linkInfos = new LinkInfos();
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["forEach"])(data, function (linkInfo, peerId) {
        linkInfos[peerId] = LinkInfo.parse(linkInfo);
      });
      return linkInfos;
    }
  }]);

  return LinkInfos;
}();

var INDEX_UP_STATE_CHANGE_SIZE = 10;

var PeerTopologyInfo = function () {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(PeerTopologyInfo, null, [{
    key: 'parseUpdate',
    value: function parseUpdate(data) {
      if (!Array.isArray(data)) {
        return data;
      }

      var _data2 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_slicedToArray___default()(data, 2),
          power = _data2[0],
          links = _data2[1];

      return {
        power: power,
        links: LinkInfos.parse(links)
      };
    }
  }]);

  function PeerTopologyInfo(peerId, onChange) {
    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, PeerTopologyInfo);

    this._peerId = peerId;
    this._onChange = onChange;
    this._topologyIndex = 1;

    this._links = new LinkInfos();
    this._power = 1;
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(PeerTopologyInfo, [{
    key: 'toString',
    value: function toString() {
      return 'peerTopologyInfo{peerId=' + this._peerId + ',power=' + this._power + ',' + this._links + '}';
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return [this._power, this._links];
    }
  }, {
    key: '_update',
    value: function _update(_ref2) {
      var topologyInfo = _ref2.topologyInfo,
          topologyIndex = _ref2.topologyIndex,
          volume = _ref2.volume;

      this._volume = volume;
      if (!topologyInfo) {
        return;
      }
      __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].number('PeerTopologyInfo._update', 'topologyIndex', topologyIndex);
      if (topologyIndex < this._topologyIndex) {
        return;
      }
      __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].options('PeerTopologyInfo._update', 'topologyInfo', topologyInfo).number('power').instance('links', LinkInfos);
      this._links = topologyInfo.links;
      this._power = topologyInfo.power;
      var indexChange = topologyIndex - this._topologyIndex;
      this._topologyIndex = topologyIndex;
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].verbose(TAG, this, 'updated peer topology info by ' + indexChange + ' indices');
      this._onChange(indexChange >= INDEX_UP_STATE_CHANGE_SIZE);
    }
  }, {
    key: '_invalidate',
    value: function _invalidate() {
      this._links = null;
      this._onChange = null;
    }
  }, {
    key: 'links',
    get: function get() {
      return this._links;
    }
  }, {
    key: 'power',
    get: function get() {
      return this._power;
    }
  }, {
    key: 'volume',
    get: function get() {
      return this._volume;
    }
  }, {
    key: 'topologyIndex',
    get: function get() {
      return this._topologyIndex;
    }
  }]);

  return PeerTopologyInfo;
}();

var LocalTopologyInfo = function () {
  function LocalTopologyInfo(_ref3) {
    var power = _ref3.power,
        voiceActivityDetector = _ref3.voiceActivityDetector,
        onUpdate = _ref3.onUpdate;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, LocalTopologyInfo);

    this._handleUpdate = this._handleUpdate.bind(this);

    this._links = new LinkInfos();
    this._power = power;
    this._voiceActivityDetector = voiceActivityDetector;
    this._topologyIndex = 1;
    this._onUpdate = onUpdate;
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(LocalTopologyInfo, [{
    key: 'setVoiceActivityDetectorActive',
    value: function setVoiceActivityDetectorActive(active) {
      if (this._voiceActivityDetector) {
        this._voiceActivityDetector.setActive(active);
      }
    }
  }, {
    key: 'addPeer',
    value: function addPeer(peerId) {
      if (this._links.hasOwnProperty(peerId)) {
        throw new Error('LocalTopologyInfo already has a peer with id ' + peerId);
      }
      var linkInfo = new LinkInfo({ onUpdate: this._handleUpdate });
      this._links[peerId] = linkInfo;
      return linkInfo;
    }
  }, {
    key: 'removePeer',
    value: function removePeer(peerId) {
      var linkInfo = this._links[peerId];
      if (!linkInfo) {
        throw new Error('LocalTopologyInfo failed to delete nonexistent peer, ' + peerId);
      }
      delete this._links[peerId];
    }
  }, {
    key: 'toString',
    value: function toString() {
      var infoStrings = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["map"])(this._links, function (linkInfo, peerId) {
        return peerId + ':' + linkInfo;
      });
      return 'localTopology{power=' + this._power + ',' + infoStrings.join(',') + '}';
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return [this._power, this._links];
    }
  }, {
    key: '_handleUpdate',
    value: function _handleUpdate(changedUpState) {
      this._topologyIndex += changedUpState ? INDEX_UP_STATE_CHANGE_SIZE : 1;
      this._onUpdate(changedUpState);
    }
  }, {
    key: '_invalidate',
    value: function _invalidate() {}
  }, {
    key: 'links',
    get: function get() {
      return this._links;
    }
  }, {
    key: 'power',
    get: function get() {
      return this._power;
    }
  }, {
    key: 'topologyIndex',
    get: function get() {
      return this._topologyIndex;
    }
  }, {
    key: 'volume',
    get: function get() {
      if (this._voiceActivityDetector) {
        return this._voiceActivityDetector.volume;
      } else {
        return 0;
      }
    }
  }]);

  return LocalTopologyInfo;
}();

var MeshTopology = function () {
  function MeshTopology(_ref4) {
    var ownId = _ref4.ownId,
        _ref4$power = _ref4.power,
        power = _ref4$power === undefined ? 1 : _ref4$power,
        _ref4$voiceActivityDe = _ref4.voiceActivityDetector,
        voiceActivityDetector = _ref4$voiceActivityDe === undefined ? null : _ref4$voiceActivityDe;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, MeshTopology);

    this._onChange = this._onChange.bind(this);

    this._localTopologyInfo = new LocalTopologyInfo({
      power: power,
      voiceActivityDetector: voiceActivityDetector,
      onUpdate: this._onLocalTopologyUpdate.bind(this)
    });
    this._topologyInfos = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default.a();
    this._changeListeners = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set___default.a();
    this._ownId = ownId;
    this._active = false;
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(MeshTopology, [{
    key: 'toString',
    value: function toString() {
      if (this._topologyInfos.size === 0) {
        return 'meshTopology{ownId=' + this._ownId + ',' + this._localTopologyInfo + '}';
      }
      return 'meshTopology{ownId=' + this._ownId + ',' + [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(this._topologyInfos.values())).join(',') + '}';
    }
  }, {
    key: 'activate',


    // The mesh topology instance is only active when in the leader state
    // Being active means that it is possible to add, remove, and update peer link info,
    // and that changes will be signaled through the change listener
    value: function activate() {
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, 'activating ' + this);
      this._active = true;
      this._topologyInfos.clear();
      this._topologyInfos.set(this._ownId, this._localTopologyInfo);
      this._onChange(true);
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, 'deactivating ' + this);
      this._active = false;
      this._topologyInfos.forEach(function (peerTopologyInfo) {
        return peerTopologyInfo._invalidate();
      });
      this._topologyInfos.clear();
      this._onChange(true);
    }
  }, {
    key: 'invalidate',
    value: function invalidate() {
      this._changeListeners.clear();
      this.deactivate(); // change listeners will not be called, since we cleared them
      this._changeListeners = null;
      this._ownId = null;
      this._localTopologyInfo._invalidate();
      this._localTopologyInfo = null;
      this._topologyInfos = null;
    }
  }, {
    key: 'addClient',
    value: function addClient(peerId) {
      if (!this._active) {
        throw new Error('Tried to add client while MeshTopology was deactivated');
      }
      if (this._topologyInfos.has(peerId)) {
        throw new Error('Tried to add existing client to MeshTopology');
      }
      var peerTopologyInfo = new PeerTopologyInfo(peerId, this._onChange);
      this._topologyInfos.set(peerId, peerTopologyInfo);
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'adding client: ' + peerId + ',  ' + peerTopologyInfo);
      this._onChange(false); // links will be added later
      return peerTopologyInfo;
    }
  }, {
    key: 'removeClient',
    value: function removeClient(peerId) {
      if (!this._active) {
        throw new Error('Tried to remove client while MeshTopology was deactivated');
      }
      if (!this._topologyInfos.has(peerId)) {
        throw new Error('Tried to remove missing client from MeshTopology');
      }
      this._topologyInfos.delete(peerId);
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'removed client: ' + peerId);
      this._onChange(true);
    }
  }, {
    key: 'addChangeListener',
    value: function addChangeListener(listener) {
      this._changeListeners.add(listener);
    }
  }, {
    key: 'removeChangeListener',
    value: function removeChangeListener(listener) {
      this._changeListeners.delete(listener);
    }
  }, {
    key: '_onChange',
    value: function _onChange(changedUpState) {
      var _this2 = this;

      this._changeListeners.forEach(function (listener) {
        return listener(_this2, changedUpState);
      });
    }
  }, {
    key: '_onLocalTopologyUpdate',
    value: function _onLocalTopologyUpdate(changedUpState) {
      this._onChange(changedUpState);
    }
  }, {
    key: 'topologyInfos',
    get: function get() {
      return this._topologyInfos;
    }
  }, {
    key: 'localTopologyInfo',
    get: function get() {
      return this._localTopologyInfo;
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    }
  }]);

  return MeshTopology;
}();

/* harmony default export */ __webpack_exports__["c"] = (MeshTopology);

/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__ = __webpack_require__(131);












var TAG = 'media-input';

/**
 * A base class for media nodes with a single input and no output. Typically used to render
 * the stream, or as a base for nodes with multiple outputs.
 *
 * The subclass should override the `onStream` method.
 *
 * @class MediaSink
 * @extends MediaNode
 */

var MediaSink = function (_MediaNode) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(MediaSink, _MediaNode);

  function MediaSink() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, MediaSink);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (MediaSink.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(MediaSink)).call(this));

    _this._input = new __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__["a" /* default */]({
      name: 'default',
      parent: _this,
      onStream: function onStream(stream, oldStream) {
        return _this.onStream(stream, oldStream);
      }
    });
    return _this;
  }

  /**
   * The current input stream.
   *
   * @readonly
   * @member {MediaStream} MediaSink#stream
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(MediaSink, [{
    key: 'onStream',


    /**
     * Abstract method that is called whenever the input stream is updated, this should
     * be overridden by the subclass.
     *
     * This will only ever be called if the stream has changed, been added, or removed,
     * i.e. stream and oldStream will never be equal.
     *
     * The `onStream` method will not be called when the backing tracks of a stream is changed.
     * If the subclass needs to be notified of track updates this has to be done manually using
     * the MediaStream listeners.
     *
     * @abstract
     * @param {?MediaStream} stream - The new media stream, or null.
     * @param {?MediaStream} oldStream - The old media stream, or null.
     */
    value: function onStream(stream, oldStream) {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, this.constructor.name + '.onStream should be overridden');
    }
  }, {
    key: 'stream',
    get: function get() {
      return this._input.stream;
    }

    /**
     * The input.
     *
     * @readonly
     * @member {MediaNodeInput} MediaSink#input
     */

  }, {
    key: 'input',
    get: function get() {
      return this._input;
    }
  }]);

  return MediaSink;
}(__WEBPACK_IMPORTED_MODULE_6_media_mediaNode__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MediaSink);

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(156), __esModule: true };

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(29);
__webpack_require__(23);
module.exports = __webpack_require__(157);

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(29);
__webpack_require__(23);
module.exports = __webpack_require__(158);

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(14)
  , get      = __webpack_require__(65);
module.exports = __webpack_require__(0).getIterator = function(it){
  var iterFn = get(it);
  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(44)
  , ITERATOR  = __webpack_require__(4)('iterator')
  , Iterators = __webpack_require__(24);
module.exports = __webpack_require__(0).isIterable = function(it){
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    || Iterators.hasOwnProperty(classof(O));
};

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return AsyncPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_utils__ = __webpack_require__(13);









var AsyncQueue = function () {
  function AsyncQueue() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, AsyncQueue);

    this._queue = [];
    this._currentTask = null;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(AsyncQueue, [{
    key: 'toString',
    value: function toString() {
      return 'AsyncQueue{executing=' + !!this._currentTask + 'queued=' + this._queue.length + '}';
    }
  }, {
    key: 'push',
    value: function push(factory) {
      var task = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["defer"])();
      task.factory = factory;
      this._queue.push(task);
      if (!this._currentTask) {
        this._poll();
      }
      return task.promise;
    }
  }, {
    key: 'clear',
    value: function clear() {
      if (this._currentTask) {
        this._currentTask.cancelled = true;
        this._currentTask = null;
      }
      this._queue.length = 0;
    }
  }, {
    key: '_poll',
    value: function _poll() {
      if (this._currentTask || !this._queue.length) {
        return;
      }
      var self = this;
      var task = this._currentTask = this._queue.shift();
      if (!task) {
        return;
      }

      var promise = null;
      try {
        promise = task.factory();
      } catch (e) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(this.tag, 'AsyncQueue.process: factory threw error', e, e.stack);
      }
      if (promise) {
        promise.then(function (result) {
          if (task.cancelled) {
            throw new Error('task was cancelled');
          }
          task.resolve(result);
        }).catch(task.reject).then(function () {
          self._currentTask = null;
          self._poll();
        }).catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(self.tag, 'error calling poll after task completion: ', error);
        });
      } else {
        this._currentTask = null;
        this._poll();
      }
    }
  }]);

  return AsyncQueue;
}();

/* harmony default export */ __webpack_exports__["a"] = (AsyncQueue);


AsyncQueue.tag = 'async-queue';

var AsyncPipe = function () {
  function AsyncPipe() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, AsyncPipe);

    this._queue = [];
    this._deferredRead = null;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(AsyncPipe, [{
    key: 'read',
    value: function read() {
      if (!this._queue) {
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject();
      } else if (this._deferredRead) {
        return this._deferredRead.promise;
      } else if (this._queue.length) {
        var item = this._queue.pop();
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve(item);
      } else {
        this._deferredRead = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["defer"])();
        return this._deferredRead.promise;
      }
    }
  }, {
    key: 'write',
    value: function write(message) {
      if (!this._queue) {
        throw new Error('AsyncPipe is closed');
      } else if (!this._deferredRead) {
        this._queue.unshift(message);
      } else {
        this._deferredRead.resolve(message);
        this._deferredRead = null;
      }
    }
  }, {
    key: 'close',
    value: function close() {
      if (!this._queue) {
        throw new Error('AsyncPipe has already been closed');
      }
      if (this._deferredRead) {
        this._deferredRead.reject();
        this._deferredRead = null;
      }
      this._queue.length = 0;
      this._queue = null;
    }
  }]);

  return AsyncPipe;
}();

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_argCheck__ = __webpack_require__(12);






/**
 * A base class for components that can be attached to both {@link Call}s and {@link Conference}s.
 *
 * Subclasses have a number of lifecycle methods that can be overriden to implement actions during
 * various parts of a call or conference.
 *
 * RtcComponents that are attached will be able to interact with other remote components, as long as the
 * components are compatible. An example is two users in a call that both attach a {@link DataShare}
 * component to the same point. The two data shares will then synchronize data, as long as the calls
 * are connected.
 *
 * The purpose of the `label` and `remoteLabel` configuration is to make sure that components are compatible
 * before connecting. A component is compatible with another component if the label is equal to the
 * remote label, or match in the case where the remote label is a RegExp. If components are not compatible
 * they will not be connected, so the peer will not show up in the {@link AttachPoint#peers} collection.
 *
 * @class RtcComponent
 * @abstract
 * @param {Object} config - Configuration object.
 * @param {string} config.label - The label that remote components will be matched against. Only components
 *   with matching labels can interact with each other.
 * @param {string|Regex} [config.remoteLabel] - The expected remote component label, defaults to the own label.
 */

var RtcComponent = function () {
  function RtcComponent(config) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, RtcComponent);

    if (this.constructor === RtcComponent) {
      throw new TypeError('RtcComponent must be subclassed');
    }
    __WEBPACK_IMPORTED_MODULE_2_common_argCheck__["a" /* default */].options('RtcComponent', 'config', config).string('label').optString('remoteLabel');
    var label = config.label,
        _config$remoteLabel = config.remoteLabel,
        remoteLabel = _config$remoteLabel === undefined ? null : _config$remoteLabel;

    this._label = label;
    this._remoteLabel = remoteLabel;
  }

  /**
   * True if the component is currently attached to anything.
   *
   * @readonly
   * @member {boolean} RtcComponent#attached
   */


  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(RtcComponent, [{
    key: 'rtcComponentWillAttach',


    /**
     * A overridable method that is called when the component is about to be attached to something.
     * When this method is called, {@link RtcComponent#attachPoint} will not yet have been set, but
     * the attachment point can be accessed through the parameter.
     *
     * If this method throws an error, the component will fail to attach. The error will be caught and
     * handled by logging an error, but the program flow will continue.
     *
     * This method will always the followed by a call to {@link RtcComponent#rtcComponentWillDetach}.
     *
     * @abstract
     * @param {AttachPoint} attachPoint - The point that the component will be attached to.
     */
    value: function rtcComponentWillAttach(attachPoint) {}

    /**
     * This method is called whenever a peer is added to the {@link AttachPoint#peers} collection of the
     * attach point.
     *
     * Only peers to who we have an active connection and who have mounted a matching component will be
     * visible.
     *
     * This method will always be followed by a call to {@link RtcComponent#rtcComponentDidLosePeer} for
     * the given peer. It will also only ever be called while the component is attached.
     *
     * @abstract
     * @param {RtcPeer} peer - The added peer.
     */

  }, {
    key: 'rtcComponentDidReceivePeer',
    value: function rtcComponentDidReceivePeer(peer) {}

    /**
     * This method is called whenever an update to this component's {@link AttachData} occurs.
     *
     * This method will only be called for active peers, which means that it is always happens after
     * the {@link RtcComponent#rtcComponentDidReceivePeer} call for a peer, and before
     * {@link RtcComponent#rtcComponentDidLosePeer}. It will also only ever be called while the component
     * is attached.
     *
     * @abstract
     * @param {Object} update - An object that describes the update that happened.
     * @param {string} update.key - The key that was updated.
     * @param {JsonTypes} update.value - The new value.
     * @param {JsonTypes} update.oldValue - The old value.
     * @param {string} update.ownerId - The id of the owner, if it was set.
     */

  }, {
    key: 'rtcComponentUpdatedData',
    value: function rtcComponentUpdatedData(_ref) {
      var key = _ref.key,
          value = _ref.value,
          oldValue = _ref.oldValue,
          ownerId = _ref.ownerId;
    }

    /**
     * This method is called whenever a peer opens a data channel. The channel will be ready to use as
     * soon as this method is called.
     *
     * When this method is called the channel will already have been added to the collection returned by
     * {@link RtcPeer#getRemoteChannels}.
     *
     * This method will only be called for active peers, which means that it is always happens after
     * the {@link RtcComponent#rtcComponentDidReceivePeer} call for a peer, and before
     * {@link RtcComponent#rtcComponentDidLosePeer}. It will also only ever be called while the component is attached.
     *
     * @abstract
     * @param {RtcPeer} peer - The peer that created the channel.
     * @param {external:RTCDataChannel} channel - The opened data channel.
     */

  }, {
    key: 'rtcComponentReceivedChannel',
    value: function rtcComponentReceivedChannel(peer, channel) {}

    /**
     * This method is called whenever a peer is removed from the {@link AttachPoint#peers} collection of the
     * attach point.
     *
     * This will happen when the connection to a peer is lost, the peer detaches their component, or when
     * the local component is detached.
     *
     * This method will always preceeded by a call to {@link RtcComponent#rtcComponentDidReceivePeer}
     * for the given peer. It will also only ever be called while the component is attached.
     *
     * @abstract
     * @param {RtcPeer} peer - The peer that was lost.
     */

  }, {
    key: 'rtcComponentDidLosePeer',
    value: function rtcComponentDidLosePeer(peer) {}

    /**
     * Called before the component is detached. Once this method has returned the attachPoint will no longer
     * be valid, and any attempt to call a method on the attach point will throw an error.
     *
     * This method will always the preceeded by a call to {@link RtcComponent#rtcComponentWillAttach}.
     *
     * @abstract
     */

  }, {
    key: 'rtcComponentWillDetach',
    value: function rtcComponentWillDetach() {}
  }, {
    key: '_internalAttach',
    value: function _internalAttach(component) {
      this._attachPoint = component;
    }
  }, {
    key: '_internalDetach',
    value: function _internalDetach() {
      this._attachPoint = null;
    }
  }, {
    key: 'attached',
    get: function get() {
      return !!this._attachPoint;
    }

    /**
     * Returns the current attachment point. This should only be accessed from within the component
     * implementation. An error will be thrown if you try to access this member when the component
     * is not attached.
     *
     * @readonly
     * @member {AttachPoint} RtcComponent#attachPoint
     */

  }, {
    key: 'attachPoint',
    get: function get() {
      if (!this._attachPoint) {
        throw new Error('RtcComponent tried to access attachPoint while not attached.');
      }
      return this._attachPoint;
    },
    set: function set(value) {
      throw new TypeError('RtcComponent.attachPoint is read-only.');
    }
  }]);

  return RtcComponent;
}();

/* harmony default export */ __webpack_exports__["a"] = (RtcComponent);

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ConnectionFailedError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConnectionLostError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ConnectionSignalingError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return ChannelClosedError; });
/* unused harmony export ChannelFailedError */
/* unused harmony export ChannelTimeoutError */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return FileTransferError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return TransferInterruptedError; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_errors__ = __webpack_require__(145);








/**
 * An error that represents a failure to set up a connection. As opposed to the
 * {@link ConnectionLostError}, this error almost always happens when trying to
 * create a new connection.
 *
 * Attempts will be made to set up a new connection, so the
 * {@link ConnectionLostError#times} property is exposed in order to make it
 * easier for applications to decide when to give up.
 *
 * @class ConnectionFailedError
 * @extends CctError
 */
var ConnectionFailedError = function (_CctError) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ConnectionFailedError, _CctError);

  function ConnectionFailedError(times) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ConnectionFailedError);

    var timesStr;
    if (times % 10 === 1) {
      timesStr = times + 'st';
    } else if (times % 10 === 2) {
      timesStr = times + 'nd';
    } else if (times % 10 === 3) {
      timesStr = times + 'rd';
    } else {
      timesStr = times + 'th';
    }

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConnectionFailedError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ConnectionFailedError)).call(this, 'connection failed for the ' + timesStr + ' time'));

    _this.times = times;
    return _this;
  }

  /**
   * The number of times that the connection has failed in a row.
   *
   * @readonly
   * @member {number} ConnectionFailedError#times
   */


  return ConnectionFailedError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
ConnectionFailedError.errorName = 'ConnectionFailedError';

/**
 * An error that indicates that a connection that was set up successfully
 * has now been disconnected.
 *
 * An attempt will be made to restore the connection, but if that attempt fails
 * this error will be replaced with a {@link ConnectionFailedError}.
 *
 * @class ConnectionLostError
 * @extends CctError
 */
var ConnectionLostError = function (_CctError2) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ConnectionLostError, _CctError2);

  function ConnectionLostError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ConnectionLostError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConnectionLostError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ConnectionLostError)).apply(this, arguments));
  }

  return ConnectionLostError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
ConnectionLostError.errorName = 'ConnectionLostError';

/**
 * An error that is represents a signaling failure. This error almost
 * always indicates that there is an incompatability between the endpoints
 * that are being connected, or that the particular way that the connection
 * is being set up is not supported.
 *
 * @class ConnectionSignalingError
 * @extends CctError
 */
var ConnectionSignalingError = function (_CctError3) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ConnectionSignalingError, _CctError3);

  function ConnectionSignalingError(reason) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ConnectionSignalingError);

    var _this3 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConnectionSignalingError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ConnectionSignalingError)).call(this, 'Connection signaling failed, ' + reason));

    _this3.reason = reason;
    return _this3;
  }

  /**
   * The error that caused the signaling failure.
   *
   * @readonly
   * @member {Error} ConnectionSignalingError#reason
   */


  return ConnectionSignalingError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
ConnectionSignalingError.errorName = 'ConnectionSignalingError';

/**
 * The operation failed because the channel was closed.
 *
 * @class ChannelClosedError
 * @extends CctError
 */
var ChannelClosedError = function (_CctError4) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ChannelClosedError, _CctError4);

  function ChannelClosedError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ChannelClosedError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ChannelClosedError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ChannelClosedError)).apply(this, arguments));
  }

  return ChannelClosedError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
ChannelClosedError.errorName = 'ChannelClosedError';

/**
 * The channel failed due to a low-level error.
 *
 * @class ChannelFailedError
 * @extends CctError
 */
var ChannelFailedError = function (_CctError5) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ChannelFailedError, _CctError5);

  function ChannelFailedError(message, reason) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ChannelFailedError);

    var _this5 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ChannelFailedError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ChannelFailedError)).call(this, message));

    _this5.reason = reason;
    return _this5;
  }

  /**
   * The error that caused the failure.
   *
   * @member {Error} ChannelFailedError#reason
   */


  return ChannelFailedError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
ChannelFailedError.errorName = 'ChannelFailedError';

/**
 * The channel operation timed out.
 *
 * @class ChannelTimeoutError
 * @extends CctError
 */
var ChannelTimeoutError = function (_CctError6) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ChannelTimeoutError, _CctError6);

  function ChannelTimeoutError(message, timeoutMs) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ChannelTimeoutError);

    var _this6 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ChannelTimeoutError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ChannelTimeoutError)).call(this, message));

    _this6.timeoutMs = timeoutMs;
    return _this6;
  }

  /**
   * The time limit that was set for the operation, in milliseconds.
   *
   * @member {number} ChannelTimeoutError#timeoutMs
   */


  return ChannelTimeoutError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
ChannelTimeoutError.errorName = 'ChannelTimeoutError';

/**
 * An error that indicates that a file transfer failed because of a protocol
 * error or data corruption.
 *
 * @class FileTransferError
 * @extends CctError
 */
var FileTransferError = function (_CctError7) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(FileTransferError, _CctError7);

  function FileTransferError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, FileTransferError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (FileTransferError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(FileTransferError)).apply(this, arguments));
  }

  return FileTransferError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
FileTransferError.errorName = 'FileTransferError';

/**
 * An error that indicates that the transfer was interrupted either on purpose
 * or because of connection issues.
 *
 * @class TransferInterruptedError
 * @extends CctError
 */
var TransferInterruptedError = function (_CctError8) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(TransferInterruptedError, _CctError8);

  function TransferInterruptedError() {
    var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var downloadedBytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var expectedBytes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, TransferInterruptedError);

    var _this8 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (TransferInterruptedError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(TransferInterruptedError)).call(this, 'Transfer ' + reason + ' after ' + downloadedBytes + ' out of ' + expectedBytes + ' bytes'));

    _this8.reason = reason;
    _this8.downloadedBytes = downloadedBytes;
    _this8.expectedBytes = expectedBytes;
    return _this8;
  }

  /**
   * The reason the interruption happened.
   *
   * @member {string?} TransferInterruptedError#reason
   */

  /**
   * The number of bytes that were downloaded before the interruption.
   *
   * @member {number?} TransferInterruptedError#downloadedBytes
   */

  /**
   * The total number of bytes that was expected to be downloaded.
   *
   * @member {number?} TransferInterruptedError#expectedBytes
   */


  return TransferInterruptedError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
TransferInterruptedError.errorName = 'TransferInterruptedError';

/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sdp_interop__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_sdp_interop___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_sdp_interop__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_webrtc_peerConnectionMonitor__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_media_dummySource__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__ = __webpack_require__(199);

















var TAG = 'peer-connection';

var EVENT_HANDLER_ERROR_TEMPLATE = 'onFUNC is not available, use addEventListener instead';

var IceConfigErrorDetector = function () {
  function IceConfigErrorDetector(iceServers) {
    var _this = this;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, IceConfigErrorDetector);

    this._haveTurn = false;
    this._haveStun = false;
    if (iceServers) {
      iceServers.forEach(function (server) {
        var url = server.urls || server.url;
        if (!url) {
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error('peer-connection', 'ice server has no url: ' + __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(server));
        }
        if (url.indexOf('stun:') === 0) {
          _this._haveStun = true;
        }
        if (url.indexOf('turn:') === 0) {
          _this._haveStun = true;
          _this._haveTurn = true;
        }
      });
    }
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(IceConfigErrorDetector, [{
    key: 'observedCandidate',
    value: function observedCandidate(info) {
      if (info.type !== 'host') {
        this._gotStun = true;
      }
      if (info.type === 'relay') {
        this._gotTurn = true;
      }
    }
  }, {
    key: 'end',
    value: function end(iceConnectionState) {
      // We might not bother gathering candidates with lower priority if we find a good connection
      // early. But if that happens we will have moved on from iceConnectionState 'new'.
      // So we only want to continue the check if we're still in 'new' state.
      if (iceConnectionState !== 'new') {
        return null;
      }
      if (this._haveTurn && !this._gotTurn) {
        var msg = "'iceServers' contained a turn server, but no relay candidates were received." + ' Check the turn server configuration and availability.';
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].warning('peer-connection', msg);
        return 'turn';
      } else if (this._haveStun && !this._gotStun) {
        var _msg = "'iceServers' contained a stun server, but no stun candidates were received." + ' Check the stun server configuration and availability.';
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].warning('peer-connection', _msg);
        return 'stun';
      }
      return null;
    }
  }]);

  return IceConfigErrorDetector;
}();

var PeerConnectionProxy = function () {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(PeerConnectionProxy, null, [{
    key: 'create',
    value: function create(config) {
      config = config || {};
      var statsFormatter = config.statsFormatter;
      var rtcpMuxPolicy = config.rtcpMuxPolicy || 'require';
      var bundlePolicy = config.bundlePolicy || 'max-bundle';
      var iceServers = config.iceServers;
      var iceCandidateFilter = config.iceCandidateFilter;
      if (typeof iceServers === 'string') {
        iceServers = [iceServers];
      } else if (!Array.isArray(iceServers)) {
        iceServers = [];
      }
      iceServers = iceServers.map(function (server) {
        if (typeof server === 'string') {
          return {
            urls: server
          };
        } else {
          return server;
        }
      });
      var pcConfig = { iceServers: iceServers, rtcpMuxPolicy: rtcpMuxPolicy, bundlePolicy: bundlePolicy };
      return new PeerConnectionProxy(pcConfig, statsFormatter, iceCandidateFilter);
    }
  }]);

  function PeerConnectionProxy(pcConfig, statsFormatter, iceCandidateFilter) {
    var _this2 = this;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, PeerConnectionProxy);

    __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].debug(TAG, 'creating peer connection with config:', pcConfig);
    this._pc = new RTCPeerConnection(pcConfig);
    this._iceCandidateFilter = iceCandidateFilter;
    this._eventTarget = new __WEBPACK_IMPORTED_MODULE_7_common_emitter__["a" /* default */]();
    this._id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["randomString"])(30);
    this._interop = new __WEBPACK_IMPORTED_MODULE_5_sdp_interop__["Interop"]();
    this._iceErrorDetector = new IceConfigErrorDetector(pcConfig.iceServers);
    this._firstMid = null;

    this.addEventListener = this.addEventListener.bind(this);
    this.addStream = this.addStream.bind(this);
    this.close = this.close.bind(this);
    this.getLocalStreams = this.getLocalStreams.bind(this);
    this.getRemoteStreams = this.getRemoteStreams.bind(this);
    this.addIceCandidate = this.addIceCandidate.bind(this);
    this._createAnswer = this._createAnswer.bind(this);
    this._createOffer = this._createOffer.bind(this);
    this.getStats = this.getStats.bind(this);
    this._setLocalDescription = this._setLocalDescription.bind(this);
    this._setRemoteDescription = this._setRemoteDescription.bind(this);
    this.removeEventListener = this.removeEventListener.bind(this);
    this.removeStream = this.removeStream.bind(this);
    this.waitForInitialIce = this.waitForInitialIce.bind(this);

    this._pc.oniceconnectionstatechange = function (event) {
      _this2._eventTarget._emit('iceconnectionstatechange', { target: _this2 });
    };

    this._pc.onnegotiationneeded = function (event) {
      _this2._eventTarget._emit('negotiationneeded', { target: _this2 });
    };

    this._pc.onsignalingstatechange = function (event) {
      _this2._eventTarget._emit('signalingstatechange', { target: _this2 });
    };

    this._pc.onaddstream = function (event) {
      _this2._eventTarget._emit('addstream', { target: _this2, stream: event.stream });
    };

    this._pc.onremovestream = function (event) {
      _this2._eventTarget._emit('removestream', { target: _this2, stream: event.stream });
    };

    this._pc.ondatachannel = function (event) {
      var channel = event.channel;

      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].warning('data-channel', "received data channel, which shouldn't happen");
      _this2._eventTarget._emit('datachannel', { target: _this2, channel: channel });
    };

    var deferredIce = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["defer"])();
    this._initialIceComplete = deferredIce.promise;

    this._pc.onicecandidate = function (event) {
      var candidate = event.candidate;

      if (!candidate) {
        _this2._eventTarget._emit('icecandidate', { target: _this2, candidate: candidate });
        if (_this2._iceErrorDetector) {
          if (_this2._iceErrorDetector.end(_this2._pc.iceConnectionState) === 'turn') {
            deferredIce.reject(new Error('No relay candidates received while turn server was configured'));
          }
          _this2._iceErrorDetector = null;
        }
        deferredIce.resolve();
        return;
      }

      var info = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["a" /* parseCandidateInfo */])(candidate.candidate, 'local');
      if (_this2._iceErrorDetector) {
        _this2._iceErrorDetector.observedCandidate(info);
      }

      if (_this2._iceCandidateFilter) {
        try {
          if (!_this2._iceCandidateFilter(info)) {
            __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].debug(TAG, 'ignored candidate due to being filtered out: ' + candidate);
            return;
          }
          setTimeout(function () {
            deferredIce.resolve();
          }, 200);
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'ignoring candidate, error was thrown in candidate filter: ' + error);
          return;
        }
      }

      if (__WEBPACK_IMPORTED_MODULE_8_common_utils__["isFirefox"]) {
        var _ref = candidate.sdpMid.match(/^(audio|video)-[0-9]+$/) || [],
            _ref2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_ref, 2),
            simpleMid = _ref2[1];

        if (simpleMid) {
          candidate.sdpMid = simpleMid;
        }
      }

      _this2._eventTarget._emit('icecandidate', { target: _this2, candidate: candidate });
    };

    if (statsFormatter) {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_webrtc_peerConnectionMonitor__["a" /* default */])(this, statsFormatter);
    }
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(PeerConnectionProxy, [{
    key: 'toString',
    value: function toString() {
      return 'peerConnection{id=' + this._id + '}';
    }
  }, {
    key: 'addEventListener',
    value: function addEventListener(event, listener) {
      return this._eventTarget.on(event, listener);
    }
  }, {
    key: 'removeEventListener',
    value: function removeEventListener(event, listener) {
      return this._eventTarget.off(event, listener);
    }
  }, {
    key: 'addStream',
    value: function addStream(stream) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["addPeerConnectionStream"])(this._pc, stream);
    }
  }, {
    key: 'removeStream',
    value: function removeStream(stream) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["removePeerConnectionStream"])(this._pc, stream);
    }
  }, {
    key: 'getLocalStreams',
    value: function getLocalStreams() {
      var _this3 = this;

      return this._pc.getLocalStreams().filter(function (stream) {
        return stream !== _this3._dummyStream;
      });
    }
  }, {
    key: 'getRemoteStreams',
    value: function getRemoteStreams() {
      return this._pc.getRemoteStreams();
    }
  }, {
    key: 'close',
    value: function close() {
      return this._pc.close();
    }
  }, {
    key: 'waitForInitialIce',
    value: function waitForInitialIce() {
      return this._initialIceComplete;
    }
  }, {
    key: 'performOffer',

    // performOffer, performAnswer, and handleAnswer are high-level versions
    // of the setLocal/RemoteDescription and createOffer/Answer dance.
    // We use higher-level constructs because that allows us to make some assuptions
    // that makes sdp transformations easier and cheaper to do. e.g. we don't need
    // to support using both the description received from setLocalDescription and
    // createOffer/Answer, as well as the localDescription property, and instead just
    // munge the SDP once.
    value: function performOffer(_ref3) {
      var _this4 = this;

      var _ref3$constraints = _ref3.constraints,
          constraints = _ref3$constraints === undefined ? null : _ref3$constraints,
          _ref3$bandwidth = _ref3.bandwidth,
          bandwidth = _ref3$bandwidth === undefined ? null : _ref3$bandwidth,
          _ref3$waitForIce = _ref3.waitForIce,
          waitForIce = _ref3$waitForIce === undefined ? false : _ref3$waitForIce;

      // Chrome 57 introduced a bug that breaks renegotiation of additional media
      // blocks if the initial connection only included data channels. We work around
      // this by adding a dummy stream that forces a video block to be added.
      // Simply setting OfferToCreateVideo/Audio constraints does not work.
      //
      // We used to remove the dummy stream once a real stream is added, but this
      // seems to now break sendonly connections towards Firefox. If the dummy
      // stream is replaced without any incoming connection, all communication seems
      // to break, including data channels.
      // So for now we just keep the dummy stream around until we find a better solution.
      //
      // TODO: A possible workaround is to use constructed MediaStream instances as the
      // streams that are added to the RTCPeerConnections. When adding streams we instead
      // just take the tracks and add those to the existing streams. More importantly
      // we never remove streams from the RTCPeerConnection, just remove the tracks
      // from the stream.
      if (__WEBPACK_IMPORTED_MODULE_8_common_utils__["isChrome"] && this._pc.getLocalStreams().length === 0) {
        var dummy = new __WEBPACK_IMPORTED_MODULE_10_media_dummySource__["a" /* default */]({ video: true, audio: true });
        this.addStream(dummy.stream);
        this._dummyStream = dummy.stream;
      }

      return this._createOffer(constraints).then(function (desc) {
        return _this4._rewriteLocalInputDescription(desc, { bandwidth: bandwidth });
      }).then(function (desc) {
        return _this4._setLocalDescription(desc);
      }).then(function (offer) {
        if (waitForIce) {
          return _this4._initialIceComplete.then(function () {
            return _this4._pc._localDescription;
          });
        } else {
          return offer;
        }
      }).then(function (desc) {
        return _this4._rewriteLocalOutputDescription(desc);
      });
    }
  }, {
    key: 'performAnswer',
    value: function performAnswer(_ref4) {
      var _this5 = this;

      var offer = _ref4.offer,
          _ref4$constraints = _ref4.constraints,
          constraints = _ref4$constraints === undefined ? null : _ref4$constraints,
          _ref4$bandwidth = _ref4.bandwidth,
          bandwidth = _ref4$bandwidth === undefined ? null : _ref4$bandwidth;

      return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve(offer).then(function (desc) {
        return _this5._rewriteRemoteInputDescription(desc);
      }).then(function (desc) {
        return _this5._setRemoteDescription(desc);
      }).then(function () {
        return _this5._createAnswer(constraints);
      }).then(function (desc) {
        return _this5._rewriteLocalInputDescription(desc, { bandwidth: bandwidth });
      }).then(function (desc) {
        return _this5._setLocalDescription(desc);
      }).then(function (desc) {
        return _this5._rewriteLocalOutputDescription(desc);
      });
    }
  }, {
    key: 'handleAnswer',
    value: function handleAnswer(_ref5) {
      var _this6 = this;

      var answer = _ref5.answer;

      return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve(answer).then(function (desc) {
        return _this6._rewriteRemoteInputDescription(desc);
      }).then(function (desc) {
        return _this6._setRemoteDescription(desc);
      });
    }
  }, {
    key: '_rewriteLocalInputDescription',
    value: function _rewriteLocalInputDescription(desc, _ref6) {
      var bandwidth = _ref6.bandwidth;
      var sdp = desc.sdp,
          type = desc.type;


      if (bandwidth) {
        sdp = sdp.replace(/^b=AS:[0-9]+$/gm, 'b=AS:' + bandwidth);
      }

      // TODO: only do this in Chrome 58 & 59
      if (__WEBPACK_IMPORTED_MODULE_8_common_utils__["isChrome"]) {
        sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["b" /* disableSendBandwidthEstimation */])(sdp);
      }

      if (this._iceCandidateFilter) {
        sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["c" /* filterSdpCandidates */])(sdp, this._iceCandidateFilter, 'local');
      }

      sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["d" /* workaroundSdpBundleBug */])(sdp);

      return new RTCSessionDescription({ sdp: sdp, type: type });
    }
  }, {
    key: '_rewriteLocalOutputDescription',
    value: function _rewriteLocalOutputDescription(desc) {
      var sdp = desc.sdp,
          type = desc.type;

      var unifiedPlanSdp;

      if (__WEBPACK_IMPORTED_MODULE_8_common_utils__["isFirefox"] && !this._firstMid) {
        // Start off by grabbing the mid for the first media block. This has to be
        // done straight away and stored, since future renegotiatons may inactivate the
        // block and remove the mid from the SDP.
        // We need this in order to add ICE candidates, since we will be receiving candidates
        // that have translated mIds.
        var _ref7 = desc.sdp.match(/^a=mid:(.+)$/m) || [],
            _ref8 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_ref7, 2),
            mid = _ref8[1];

        if (mid) {
          this._firstMid = mid;
        }
      }

      if (this._iceCandidateFilter) {
        sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["c" /* filterSdpCandidates */])(sdp, this._iceCandidateFilter, 'local');
      }

      if (__WEBPACK_IMPORTED_MODULE_8_common_utils__["isFirefox"]) {
        unifiedPlanSdp = desc.sdp;

        var _extractApplicationBl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["e" /* extractApplicationBlock */])(desc.sdp),
            _extractApplicationBl2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_extractApplicationBl, 2),
            extractedSdp = _extractApplicationBl2[0],
            extracted = _extractApplicationBl2[1];

        sdp = extractedSdp;
        if (extracted && extracted.needsInteropTranslation) {
          // Firefox uses the unified SDP format, which adds multiple media blocks,
          // one block for each track. Each block has an individual mode describing if it's
          // inactive, sending, receiving, or both (inactive, sendonly, recvonly, sendrecv).
          // When that SDP is converted to plan B format, which has a single media block
          // for each media type, only the last mode mentioned in the SDP will
          // be used, which will often break the connection.
          // readMediaModeUnions() reads the modes of the different media types
          // in the initial SDP and creates a union for each media type, e.g.
          // sendonly | recvonly = sendrecv, inactive | sendonly = sendonly, etc.
          // overrideMediaModes() then injects those union modes to the plan B SDP.
          var mediaModeUnions = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["f" /* readMediaModeUnions */])(desc.sdp);
          sdp = this._interop.toPlanB({ type: desc.type, sdp: sdp }).sdp;
          sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["g" /* overrideMediaModes */])(sdp, mediaModeUnions);

          // The interop SDP transform doesn't always rewrite the bundle
          // attribute properly, so we recreate it just in case
          sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["h" /* rewriteBundleAttribute */])(sdp);
        }
        sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["i" /* injectApplicationBlock */])(sdp, extracted);
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, 'converted local ' + desc.type + ' SDP from unified plan ' + unifiedPlanSdp + '\n\nto\n\n' + sdp);
      }

      return {
        sdp: sdp,
        type: type,
        unifiedPlanSdp: unifiedPlanSdp
      };
    }
  }, {
    key: '_rewriteRemoteInputDescription',
    value: function _rewriteRemoteInputDescription(desc) {
      var sdp = desc.sdp,
          type = desc.type,
          unifiedPlanSdp = desc.unifiedPlanSdp;


      if (this._iceCandidateFilter) {
        sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["c" /* filterSdpCandidates */])(sdp, this._iceCandidateFilter, 'remote');
      }

      if (__WEBPACK_IMPORTED_MODULE_8_common_utils__["isFirefox"]) {
        // When we receive a description it might already contain a unified plan SDP
        // if it was sent by Firefox, use it directly in that case
        if (unifiedPlanSdp) {
          sdp = unifiedPlanSdp;
        } else {
          // Otherwise we need to convert the SDP from plan B to unified plan
          var oldSdp = desc.sdp;

          var _extractApplicationBl3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["e" /* extractApplicationBlock */])(desc.sdp),
              _extractApplicationBl4 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_extractApplicationBl3, 2),
              extractedSdp = _extractApplicationBl4[0],
              extracted = _extractApplicationBl4[1];

          sdp = extractedSdp;
          sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["j" /* removeChromeRetransmission */])(sdp);
          if (extracted && extracted.needsInteropTranslation) {
            sdp = this._interop.toUnifiedPlan({ type: desc.type, sdp: sdp }).sdp;
          }
          sdp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["i" /* injectApplicationBlock */])(sdp, extracted);
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, 'converted remote ' + desc.type + ' SDP from plan b ' + oldSdp + '\n\nto\n\n' + sdp);
        }
      }

      return new RTCSessionDescription({
        sdp: sdp,
        type: type
      });
    }
  }, {
    key: '_setLocalDescription',
    value: function _setLocalDescription(desc) {
      var _this7 = this;

      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, this + '.setLocalDescription', desc.sdp);
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        _this7._pc.setLocalDescription(desc, function () {
          resolve(desc);
        }, function (error) {
          reject(makeError('setLocalDescription', 'failed to set local description', error));
        });
      });
    }
  }, {
    key: '_setRemoteDescription',
    value: function _setRemoteDescription(desc) {
      var _this8 = this;

      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, this + '.setRemoteDescription', desc.sdp);
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        _this8._pc.setRemoteDescription(desc, function () {
          resolve();
        }, function (error) {
          reject(makeError('setRemoteDescription', 'failed to set remote description', error));
        });
      });
    }
  }, {
    key: '_createOffer',
    value: function _createOffer(constraints) {
      var _this9 = this;

      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, this + '.createOffer');
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        _this9._pc.createOffer(function (desc) {
          if (!desc) {
            reject(new Error('failed to create offer, no offer generated'));
          } else {
            resolve(desc);
          }
        }, function (error) {
          reject(makeError('createOffer', 'failed to create offer', error));
        }, constraints);
      });
    }
  }, {
    key: '_createAnswer',
    value: function _createAnswer(constraints) {
      var _this10 = this;

      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, this + '.createAnswer');
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        _this10._pc.createAnswer(function (desc) {
          if (!desc) {
            return reject(new Error('failed to create answer, no answer generated'));
          }
          resolve(desc);
        }, function (error) {
          reject(makeError('createAnswer', 'failed to create answer', error));
        }, constraints);
      });
    }
  }, {
    key: 'addIceCandidate',
    value: function addIceCandidate(candidate) {
      var _this11 = this;

      if (candidate.sdpMLineIndex !== 0) {
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].debug(TAG, 'ignored candidate with sdpMLineIndex != 0, ' + candidate.sdpMLineIndex);
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve();
      }
      if (!(candidate instanceof RTCIceCandidate)) {
        candidate = new RTCIceCandidate(candidate);
      }
      if (this._iceCandidateFilter) {
        try {
          var info = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_sdpTransform__["a" /* parseCandidateInfo */])(candidate.candidate, 'remote');
          if (!this._iceCandidateFilter(info)) {
            __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].debug(TAG, 'ignored candidate due to being filtered out: ' + candidate);
            return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve();
          }
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'ignoring candidate, error was thrown in candidate filter: ' + error);
          return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve();
        }
      }
      if (__WEBPACK_IMPORTED_MODULE_8_common_utils__["isFirefox"]) {
        if (!this._firstMid) {
          return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject(new Error('Tried to add ice candidate before local description was set'));
        }
        candidate.sdpMid = this._firstMid;
      }
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        _this11._pc.addIceCandidate(candidate, resolve, function (error) {
          reject(makeError('addIceCandidate', 'failed add ice candidate', error));
        });
      });
    }
  }, {
    key: 'createDataChannel',
    value: function createDataChannel(label, config) {
      return this._pc.createDataChannel(label, config);
    }
  }, {
    key: 'getStats',
    value: function getStats(selector) {
      var _this12 = this;

      if (__WEBPACK_IMPORTED_MODULE_8_common_utils__["isFirefox"]) {
        return this._pc.getStats(selector);
      }
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        _this12._pc.getStats(function (response) {
          var standardReport = {};
          response.result().forEach(function (report) {
            var standardStats = {
              id: report.id,
              type: report.type
            };
            report.names().forEach(function (name) {
              standardStats[name] = report.stat(name);
            });
            standardReport[standardStats.id] = standardStats;
          });
          resolve(standardReport);
        }, selector, reject);
      });
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'signalingState',
    get: function get() {
      return this._pc.signalingState;
    }
  }, {
    key: 'iceConnectionState',
    get: function get() {
      return this._pc.iceConnectionState;
    }
  }, {
    key: 'iceGatheringState',
    get: function get() {
      return this._pc.iceGatheringState;
    }
  }, {
    key: 'hasRemoteDescription',
    get: function get() {
      var remoteDescription = this._pc.remoteDescription;

      return !!remoteDescription && !!remoteDescription.type;
    }
  }, {
    key: 'onaddstream',
    set: function set(value) {
      throw new Error(EVENT_HANDLER_ERROR_TEMPLATE.replace('FUNC', 'addstream'));
    }
  }, {
    key: 'ondatachannel',
    set: function set(value) {
      throw new Error(EVENT_HANDLER_ERROR_TEMPLATE.replace('FUNC', 'datachannel'));
    }
  }, {
    key: 'onicecandidate',
    set: function set(value) {
      throw new Error(EVENT_HANDLER_ERROR_TEMPLATE.replace('FUNC', 'icecandidate'));
    }
  }, {
    key: 'oniceconnectionstatechange',
    set: function set(value) {
      throw new Error(EVENT_HANDLER_ERROR_TEMPLATE.replace('FUNC', 'iceconnectionstatechange'));
    }
  }, {
    key: 'onnegotiationneeded',
    set: function set(value) {
      throw new Error(EVENT_HANDLER_ERROR_TEMPLATE.replace('FUNC', 'negotiationneeded'));
    }
  }, {
    key: 'onremovestream',
    set: function set(value) {
      throw new Error(EVENT_HANDLER_ERROR_TEMPLATE.replace('FUNC', 'removestream'));
    }
  }, {
    key: 'onsignalingstatechange',
    set: function set(value) {
      throw new Error(EVENT_HANDLER_ERROR_TEMPLATE.replace('FUNC', 'signalingstatechange'));
    }
  }, {
    key: 'localDescription',
    get: function get() {
      return this._pc.localDescription;
    }
  }]);

  return PeerConnectionProxy;
}();

/* harmony default export */ __webpack_exports__["a"] = (PeerConnectionProxy);


function makeError(funcName, message, reason) {
  var msg = 'Error in ' + funcName + ', ' + message;
  try {
    var error = new Error(msg + ': ' + reason);
    error.reason = reason;
    error.stack = reason.stack;
    return error;
  } catch (error) {
    return new Error(msg + ' and failed to serialize root cause: ' + error);
  }
}

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(170), __esModule: true };

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_mediaSource__ = __webpack_require__(144);













var TAG = 'concrete-media-source';

/**
 * A {@link MediaSource} that is backed by a single media stream from a tangible source, such
 * as a camera or microphone.
 *
 * @class ConcreteMediaSource
 */

var ConcreteMediaSource = function (_MediaSource) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(ConcreteMediaSource, _MediaSource);

  function ConcreteMediaSource() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ConcreteMediaSource);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConcreteMediaSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ConcreteMediaSource)).call(this));

    _this._onInactive = _this._onInactive.bind(_this);

    _this._deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["defer"])();
    _this._stopped = false;
    _this._error = null;
    return _this;
  }

  /**
   * A promise that is resolved to the stream as soon as it is available, or rejected
   * with an error.
   *
   * @readonly
   * @member {Promise<MediaStream, Error>}
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(ConcreteMediaSource, [{
    key: 'setError',


    /**
     * Signals that a backing stream could not be acquired and the source is stopped with an error.
     *
     * This method should only be called by the subclass implementation.
     *
     * @param {Error} error - The error that caused the setup to fail.
     */
    value: function setError(error) {
      if (!this._stopped) {
        this._error = error;
        this.stop();
        this._deferred.reject(error);
      }
    }

    /**
     * Sets the backing stream and signals that an error did not occur.
     *
     * The stream should be valid until the stop method is called.
     *
     * This method should only be called by the subclass implementation.
     *
     * @param {MediaStream} stream - The media stream.
     */

  }, {
    key: 'setStream',
    value: function setStream(stream) {
      if (this._stopped) {
        if (stream) {
          this._stopStream(stream);
        }
      } else {
        this._deferred.resolve(stream);
        __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default()(ConcreteMediaSource.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ConcreteMediaSource.prototype), 'setStream', this).call(this, stream);
        if (stream.addEventListener) {
          stream.addEventListener('inactive', this._onInactive);
        } else {
          stream.attachEvent('inactive', this._onInactive);
        }
      }
    }

    /**
     * Stops the source and cleans up all resources. This has to be called once the source
     * is no longer used in order to clean up resources.
     *
     * If an error happened there is no need to call this function, although calling it will have no effect.
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (this._stopped) {
        return;
      }
      this._stopped = true;
      var stream = this.stream;
      __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_get___default()(ConcreteMediaSource.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ConcreteMediaSource.prototype), 'setStream', this).call(this, null);
      if (stream) {
        this._stopStream(stream);
      }
    }
  }, {
    key: '_onInactive',
    value: function _onInactive() {
      this.stop();
    }
  }, {
    key: '_stopStream',
    value: function _stopStream(stream) {
      stream.getTracks().forEach(function (track) {
        try {
          track.stop();
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'failed to stop media stream track:', error);
        }
      });
      if (stream.removeEventListener) {
        stream.removeEventListener('inactive', this._onInactive);
      } else {
        stream.detachEvent('inactive', this._onInactive);
      }
    }
  }, {
    key: 'promise',
    get: function get() {
      return this._deferred.promise;
    }

    /**
     * True if the media stream has been stopped.
     *
     * @readonly
     * @member {boolean} ConcreteMediaSource#stopped
     */

  }, {
    key: 'stopped',
    get: function get() {
      return this._stopped;
    }

    /**
     * An error explaining why the stream could not be acquired, if that was the case.
     *
     * @readonly
     * @member {?Error} ConcreteMediaSource#error
     */

  }, {
    key: 'error',
    get: function get() {
      return this._error;
    }
  }]);

  return ConcreteMediaSource;
}(__WEBPACK_IMPORTED_MODULE_8_media_mediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (ConcreteMediaSource);

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = createImageResourceFactory;
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageResource;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_utils__ = __webpack_require__(13);





function createImageResourceFactory(baseUri) {
  var cache = {};
  return function (uri) {
    var resource = cache[uri] = cache[uri] || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["priv"])(ImageResource, uri, baseUri);
    return resource;
  };
}

// eslint-disable-next-line
/**
 * Represents a server-side image resource.
 *
 * This class provides a link to an image, as well as the possibility to thumbnail the image.
 *
 * @abstract
 * @class ImageResource
 */
function ImageResource(priv, resourceUri, baseUri) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["assertPriv"])('ImageResource', priv);
  var match = resourceUri.match(/mxc:\/\/([^\/]+\/[^\/#]+)(#.+)?$/);
  if (!match) {
    throw new TypeError('ImageResource: invalid resource url ', resourceUri);
  }
  var resourceId = match[1];
  var fragment = match[2] || '';

  var thumbnailUri = baseUri + '/_matrix/media/v1/thumbnail/' + resourceId;
  var downloadUri = baseUri + '/_matrix/media/v1/download/' + resourceId + fragment;

  /**
   * The uri to the image
   * @readonly
   * @member {string} ImageResource#uri
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["prop"])(this, 'uri', downloadUri);

  /**
   * The original resource uri of the resource, of the form `mxc://...`
   * @readonly
   * @member {MatrixContentUri} ImageResource#resourceUri
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["prop"])(this, 'resourceUri', resourceUri);

  /**
   * Generates a thumbnail uri for the image resource
   *
   * @name ImageResource#thumbnail
   * @function
   * @param {number} width - The request width of the thumbnail
   * @param {number} height=width - The request height of the thumbnail
   * @param {'scale'|'crop'} resizeMethod='scale' - The method used for resizing the image.
   *  'scale' will try to
   * @returns {string} - A thumbnail uri for the image
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["prop"])(this, 'thumbnail', function (width, height, resizeMethod) {
    __WEBPACK_IMPORTED_MODULE_0_common_argCheck__["a" /* default */].count('ImageResource.thumbnail', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_0_common_argCheck__["a" /* default */].number('ImageResource.thumbnail', 'width', width);
    if (arguments.length === 1) {
      height = width;
      resizeMethod = 'scale';
    } else if (arguments.length === 2) {
      __WEBPACK_IMPORTED_MODULE_0_common_argCheck__["a" /* default */].number('ImageResource.thumbnail', 'height', height);
      resizeMethod = 'scale';
    } else {
      __WEBPACK_IMPORTED_MODULE_0_common_argCheck__["a" /* default */].values('ImageResource.thumbnail', 'resizeMethod', resizeMethod, ['scale', 'crop']);
    }
    var query = '?width=' + width + '&height=' + height + '&method=' + resizeMethod;
    return thumbnailUri + query + fragment;
  });
}

ImageResource.prototype.toString = function () {
  return this.uri;
};

/**
 * Represents a media upload.
 *
 * @abstract
 * @class ImageUpload
 * @extends EventEmitter
 */

/**
 * A promise which resolves to an ImageResource for the uploaded media file.
 *
 * ##### Errors:
 * - {@link GuestAccessError} - Guest access is not allowed.
 * - {@link AuthenticationError} - The client must be authenticated to use this method.
 *
 * @member ImageUpload#promise {Promise<ImageResource, CctError>}
 */

/**
 * Emitted when the progress of the upload is updated
 * @event ImageUpload#progress
 * @param {number} progress - The progress of the upload as a value between 0 and 1
 */

/**
 * @typedef {string} MatrixContentUri
 * A string in uri form with the protocol "mxc", the hostname of the originating
 * server, and a resource id as the path.
 */

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export RequestError */
/* unused harmony export ResponseError */
/* unused harmony export JsonResponse */
/* harmony export (immutable) */ __webpack_exports__["c"] = Request;
/* harmony export (immutable) */ __webpack_exports__["d"] = FileUploadClient;
/* harmony export (immutable) */ __webpack_exports__["b"] = JsonRetryClient;
/* harmony export (immutable) */ __webpack_exports__["a"] = SerializedJsonRetryClient;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_errors__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_emitter__ = __webpack_require__(38);















var RequestError = function (_CctError) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(RequestError, _CctError);

  function RequestError(message, xhrStatus) {
    __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, RequestError);

    var _this = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default()(this, (RequestError.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(RequestError)).call(this, message));

    _this.xhrStatus = xhrStatus;
    return _this;
  }

  return RequestError;
}(__WEBPACK_IMPORTED_MODULE_8_common_errors__["a" /* default */]);
RequestError.errorName = 'RequestError';

var ResponseError = function (_CctError2) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(ResponseError, _CctError2);

  function ResponseError() {
    __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, ResponseError);

    return __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ResponseError.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(ResponseError)).apply(this, arguments));
  }

  return ResponseError;
}(__WEBPACK_IMPORTED_MODULE_8_common_errors__["a" /* default */]);
ResponseError.errorName = 'ResponseError';

var JsonResponse = function JsonResponse() {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, JsonResponse);
};

function Request(copy) {
  if (!this) {
    return new Request();
  }
  copy = copy || {};
  this._origin = copy._origin || '';
  this._path = copy._path || [];
  this._params = copy._params || {};
  this._query = copy._query || {};
  this._config = copy._config || {};
  this._headers = copy._headers || {};
  this._client = copy._client || Request.DEFAULT_CLIENT;
  this._errorHandler = copy._errorHandler;
  this._fragment = copy._fragment || '';
}

Request.prototype = {
  constructor: Request,
  tag: 'request',

  toString: function toString() {
    var origin = this._origin;
    var path = 'path=' + this._path.join('/');
    var params = 'params=[' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["map"])(this._params, function (value, key) {
      return key + '=' + value;
    }).join(',') + ']';
    var query = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys___default()(this._query);

    return 'request{' + [origin, path, params, query].join(',') + '}';
  },

  path: function path() {
    var copy = new Request(this);
    copy._path = copy._path.concat.apply(copy._path, arguments);
    return copy;
  },
  origin: function origin(_origin) {
    var copy = new Request(this);
    copy._origin = _origin;
    return copy;
  },
  client: function client(_client) {
    var copy = new Request(this);
    copy._client = _client;
    return copy;
  },
  errorHandler: function errorHandler(_errorHandler) {
    var copy = new Request(this);
    copy._errorHandler = _errorHandler;
    return copy;
  },
  fragment: function fragment(_fragment) {
    var copy = new Request(this);
    copy._fragment = _fragment;
    return copy;
  },

  // The below methods append values to each respective object prepresentation
  // If an object is passed as the first argument, all key-value pairs are copied,
  // If a string is passed as first argument, it will be used as key while the second
  // argument will be used as value.
  // e.g. req.headers({'x-ample': 'text'}) or req.headers('x-ample', 'test')

  // will be serialized to a query string when sendings a request
  query: function query(obj, value) {
    var copy = new Request(this);
    var query = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["shallowCopy"])(this._query);
    if (typeof obj === 'string') {
      query[obj] = value;
    } else {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["assign"])(query, obj);
    }
    copy._query = query;
    return copy;
  },
  // substitutes any key that is found within braces in the url with the value of the param
  // e.g. {userId: 'test'} will change /users/{userId}/ to /users/test/
  params: function params(obj, value) {
    var copy = new Request(this);
    var params = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["shallowCopy"])(this._params);
    if (typeof obj === 'string') {
      params[obj] = value;
    } else {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["assign"])(params, obj);
    }
    copy._params = params;
    return copy;
  },
  // HTTP headers...
  header: function header(obj, value) {
    var copy = new Request(this);
    var headers = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["shallowCopy"])(this._headers);
    if (typeof obj === 'string') {
      headers[obj] = value;
    } else {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["assign"])(headers, obj);
    }
    copy._headers = headers;
    return copy;
  },
  config: function config(obj, value) {
    var copy = new Request(this);
    var config = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["shallowCopy"])(this._config);
    if (typeof obj === 'string') {
      config[obj] = value;
    } else {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["assign"])(config, obj);
    }
    copy._config = config;
    return copy;
  },

  get: function get() {
    return this._do('GET', arguments);
  },

  del: function del() {
    return this._do('DEL', arguments);
  },

  post: function post() {
    return this._do('POST', arguments);
  },

  put: function put() {
    return this._do('PUT', arguments);
  },

  _do: function _do(method, args) {
    var extraPath;
    var body = null;

    if (method === 'POST' || method === 'PUT') {
      if (args.length === 0) {
        body = {};
      } else if (args.length === 1) {
        body = args[0];
      } else {
        extraPath = args[0];
        body = args[1];
      }
    } else {
      extraPath = args[0];
    }

    var options = this._compileOptions(method, extraPath, body);
    if (this._errorHandler) {
      options.errorHandler = this._errorHandler;
    } else {
      options.errorHandler = function (error) {
        return error;
      };
    }
    return this._client.executeRequest(options);
  },

  _compileOptions: function _compileOptions(method, extraPath, body) {
    var path = this._path.concat(extraPath || []);
    var params = this._params;
    path = path.map(function (component) {
      var match = component.match(/^\{(.+)\}$/);
      if (match && !match[1].match(/^\{.*\}$/)) {
        component = params[match[1]];
      }
      return encodeURIComponent(component);
    }).join('/');
    var url = this._origin + (path ? '/' + path : '');

    var query = this._query;
    var queryString = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys___default()(query).filter(function (key) {
      return query[key];
    }).map(function (key) {
      return encodeURIComponent(key) + '=' + encodeURIComponent(query[key]);
    }).join('&');

    url += queryString && '?' + queryString;
    url += this._fragment && '#' + this._fragment;

    return {
      headers: this._headers,
      timeout: this._config.timeout,
      method: method,
      body: body,
      url: url
    };
  }
};

Request._executeXhrWithJsonResponse = function (xhr, options, body) {
  if (typeof options.timeout === 'number') {
    xhr.timeout = options.timeout;
  }
  var headers = options.headers;
  for (var header in headers) {
    if (headers.hasOwnProperty(header)) {
      xhr.setRequestHeader(header, headers[header]);
    }
  }

  function copyResponseInfoTo(res) {
    res.status = xhr.status;
    res.statusText = xhr.statusText;
    res.url = xhr.responseURL;
    res.headers = xhr.getAllResponseHeaders().split('\r\n').reduce(function (obj, line) {
      var index = line.indexOf(': ');
      if (index > 0) {
        obj[line.substring(0, index)] = line.substring(index + 2);
      }
      return obj;
    }, {});
  }

  return new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
    xhr.onreadystatechange = function () {
      if (xhr.readyState !== 4) {
        return;
      }
      if (!xhr.status) {
        var message = 'failed ' + options.method + ' request to ' + options.url;
        reject(new RequestError(message, xhr.status));
        return;
      }

      var res = new JsonResponse();
      try {
        if (xhr.responseText) {
          res.body = JSON.parse(xhr.responseText);
        }
      } catch (parseError) {
        var error = new ResponseError('Failed to parse response JSON: ' + parseError.message);
        error.reason = parseError;
        error.responseText = xhr.responseText;
        copyResponseInfoTo(error);
        reject(error);
        return;
      }

      copyResponseInfoTo(res);

      if (res.status >= 400) {
        reject(options.errorHandler(res));
      } else {
        resolve(res);
      }
    };
    xhr.send(body || options.body);
  });
};

Request.jsonRequest = function (options) {
  var xhr = new XMLHttpRequest();
  xhr.open(options.method, options.url, true);
  if (xhr.overrideMimeType) {
    xhr.overrideMimeType('application/json');
  }

  var body = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(options.body || {});
  xhr.setRequestHeader('Content-Type', 'application/json');

  return Request._executeXhrWithJsonResponse(xhr, options, body);
};

Request.uploadFile = function (options) {
  var xhr = new XMLHttpRequest();
  xhr.open(options.method, options.url, true);

  var upload = new __WEBPACK_IMPORTED_MODULE_10_common_emitter__["a" /* default */]();

  xhr.upload.addEventListener('progress', function (event) {
    if (event.lengthComputable) {
      upload._emit('progress', event.loaded / event.total);
    }
  }, false);

  xhr.upload.addEventListener('load', function () {
    upload._emit('done');
  }, false);

  upload.promise = Request._executeXhrWithJsonResponse(xhr, options);

  return upload;
};

function FileUploadClient() {}

FileUploadClient.prototype = {
  constructor: FileUploadClient,
  tag: 'file-upload-client',

  toString: function toString() {
    return 'fileUploadClient{}';
  },

  executeRequest: function executeRequest(options) {
    return Request.uploadFile(options);
  }
};

function JsonRetryClient() {
  this._execute = this._execute.bind(this);
}

JsonRetryClient.prototype = {
  constructor: JsonRetryClient,
  tag: 'json-retry-client',

  toString: function toString() {
    return 'jsonRetryClient{}';
  },

  executeRequest: function executeRequest(options) {
    var request = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["defer"])();
    request.options = options;
    this._execute(request);
    return request.promise;
  },

  _execute: function _execute(request) {
    var self = this;
    Request.jsonRequest(request.options).then(function (response) {
      request.resolve(response);
    }, function (err) {
      if (err.name === 'RateLimitError') {
        setTimeout(self._execute, err.retryAfterMs, request);
      } else {
        request.reject(err);
      }
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(self.tag, 'error while executing request: ', error);
    });
  }
};

function SerializedJsonRetryClient() {
  this._queue = [];
  this._working = false;
}

SerializedJsonRetryClient.prototype = {
  constructor: SerializedJsonRetryClient,
  tag: 'serialized-json-retry-client',

  toString: function toString() {
    return 'serializedJsonRetryClient{working=' + this._working + ',queued=' + this._queue.length + '}';
  },

  executeRequest: function executeRequest(options) {
    var request = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["defer"])();
    request.options = options;
    this._queue.push(request);
    this._poll();
    return request.promise;
  },

  _poll: function _poll() {
    if (this._working) {
      return;
    }

    var request = this._queue.shift();
    if (!request) {
      return;
    }

    var self = this;
    this._working = true;

    Request.jsonRequest(request.options).then(function (response) {
      request.resolve(response);
      self._working = false;
      self._poll();
    }, function (err) {
      if (err.name === 'RateLimitError') {
        setTimeout(function () {
          self._queue.unshift(request);
          self._working = false;
          self._poll();
        }, err.retryAfterMs);
      } else {
        request.reject(err);
        self._working = false;
        self._poll();
      }
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(self.tag, 'error while executing request: ', error);
    });
  }
};

Request.DEFAULT_CLIENT = new JsonRetryClient();

/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return EXPECTED_RTT_MS; });
/* unused harmony export FollowerMapEntry */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LeaderState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FollowerState; });
/* unused harmony export CandidateState */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return JoinerState; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_conference_raftConfiguration__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_conference_raftLogEntry__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_conference_raftMessages__ = __webpack_require__(147);





















var TAG = 'raft';

var EXPECTED_RTT_MS = 200;

// This doesn't need to be particularly low, but it's good to get rid
// of old followers so that we don't leak into unused send buffers,
// It should however be high enough that the follower has a chance to
// reconnect, so we set it higher than datachannel and ICE timeouts.
var FOLLOWER_REMOVE_TIMEOUT_MS = 15000;

var RaftState = function () {
  function RaftState(log, send, term) {
    __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck___default()(this, RaftState);

    this._log = log;
    this._send = send;
    this._term = __WEBPACK_IMPORTED_MODULE_11_common_argCheck__["a" /* default */].number(this, 'term', term);
  }

  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass___default()(RaftState, [{
    key: 'toFollower',
    value: function toFollower(term, leader, votedFor) {
      if (this.stop) {
        this.stop();
      }
      return new FollowerState(this._log, this._send, term, leader, votedFor);
    }
  }, {
    key: 'toCandidate',
    value: function toCandidate(term, preVoteDone) {
      if (this.stop) {
        this.stop();
      }
      return new CandidateState(this._log, this._send, term, preVoteDone);
    }
  }, {
    key: 'toLeader',
    value: function toLeader(term, configuration) {
      if (this.stop) {
        this.stop();
      }
      return new LeaderState(this._log, this._send, term, configuration);
    }
  }, {
    key: 'handleAppendEntriesRequest',
    value: function handleAppendEntriesRequest(peerId, message) {
      var response = this._log.handleAppendEntriesRequest(message);
      if (response) {
        this._send(peerId, response);
        return this.toFollower(message.term, peerId);
      }
    }
  }, {
    key: 'handleAppendEntriesResponse',
    value: function handleAppendEntriesResponse(peerId, message) {}
  }, {
    key: 'handleRequestVoteRequest',
    value: function handleRequestVoteRequest(peerId, message) {
      var granted = message.compareLog(this._log) >= 0;
      if (message.term === this._term) {
        if (this._votedFor === peerId) {
          // If we already voted for the peer this term, meaning we are a follower, resend the vote
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'resending granted vote to peer, \'' + peerId + '\'');
          this._send(peerId, message.response({ granted: true }));
        } else if (this._votedFor) {
          // Or if we already voted for someone else, reject the vote
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'rejecting vote for \'' + peerId + '\', already voted for ' + this._votedFor);
          this._send(peerId, message.response({ granted: false }));
        } else if (this instanceof FollowerState) {
          // If we are follower at this point, it means we rejected a vote for this term,
          // but may still select someone else to vote for.
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, (granted ? 'granting' : 'rejecting') + ' same-term vote request from \'' + peerId + '\'');
          this._send(peerId, message.response({ granted: granted }));
          if (granted) {
            this._votedFor = peerId;
            return this;
          }
        } else {
          // Otherwise we are either leader or candidate and should reject the vote
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'ignoring vote request from \'' + peerId + '\', already leader');
          this._send(peerId, message.response({ granted: false }));
        }
      } else if (message.term <= this._term) {
        // If the vote is for an old term, reject it
        this._send(peerId, message.response({ granted: false }));
      } else {
        // We received a vote request for a new term, but need to figure out if logs are up to date
        // TODO: we may want to ignore votes when we're still hearing from the leader
        this._send(peerId, message.response({ granted: granted }));
        if (this instanceof FollowerState) {
          this._term = __WEBPACK_IMPORTED_MODULE_11_common_argCheck__["a" /* default */].number('RaftState.handleRequestVoteRequest', 'message.term', message.term);
          this._leader = null;
          if (granted) {
            this._votedFor = peerId;
            return this;
          }
        } else {
          return this.toFollower(message.term, null, granted ? peerId : null);
        }
      }
    }
  }, {
    key: 'handleRequestVoteResponse',
    value: function handleRequestVoteResponse(peerId, message) {}
  }, {
    key: 'handlePreVoteRequest',
    value: function handlePreVoteRequest(peerId, message) {
      var granted = false;
      var reason = 'none';

      if (message.term < this._term) {
        // If the vote is for an old term, reject it
        granted = false;
        reason = 'old or current term';
      } else {
        // We received a vote request for a new term, but need to figure out if logs are up to date
        granted = message.compareLog(this._log) >= 0;
        reason = 'newer term';
      }
      __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, (granted ? 'granting' : 'rejecting') + ' pre-vote request from \'' + peerId + '\' when ' + reason);
      this._send(peerId, message.response({ granted: granted }));
    }
  }, {
    key: 'handlePreVoteResponse',
    value: function handlePreVoteResponse(peerId, message) {}
  }, {
    key: 'handleSnapshotRequest',
    value: function handleSnapshotRequest(peerId, message) {}
  }, {
    key: 'handleSnapshotResponse',
    value: function handleSnapshotResponse(peerId, message) {}
  }, {
    key: 'handleStateOpRequest',
    value: function handleStateOpRequest(peerId, message) {
      this._send(peerId, message.response({ errorCode: __WEBPACK_IMPORTED_MODULE_16_conference_raftMessages__["k" /* StateOpResponse */].NOT_LEADER }));
    }

    // StateOpResponse is handled by StateMachine

  }, {
    key: 'forwardStateOpRequest',
    value: function forwardStateOpRequest(request) {}
  }, {
    key: 'hasVote',
    value: function hasVote(peerId) {
      return false;
    }
  }]);

  return RaftState;
}();

/* unused harmony default export */ var _unused_webpack_default_export = (RaftState);


var FollowerMapEntry = function () {
  function FollowerMapEntry(_ref) {
    var term = _ref.term,
        nextIndex = _ref.nextIndex,
        topologyInfo = _ref.topologyInfo,
        log = _ref.log,
        send = _ref.send,
        remove = _ref.remove;

    __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck___default()(this, FollowerMapEntry);

    this._term = term;
    this._log = log;
    this._send = send;
    this._removeSelf = remove;
    this._nextIndex = __WEBPACK_IMPORTED_MODULE_11_common_argCheck__["a" /* default */].number(this, 'nextIndex', nextIndex);
    this._matchIndex = 0;
    this._topologyInfo = topologyInfo;
    this._timeoutId = null;
    this._removeTimeoutId = null;
    this._idle = true;
    this._removeIndex = Infinity;
  }

  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass___default()(FollowerMapEntry, [{
    key: 'start',
    value: function start() {
      this._startTimeout();
      this._sendAppendRequest(0);
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
        this._timeoutId = null;
      }
      if (this._removeTimeoutId) {
        clearTimeout(this._removeTimeoutId);
        this._removeTimeoutId = null;
      }
      this._topologyInfo._invalidate();
    }

    // Followers that are removed should receive the information that they
    // have been removed, so we keep sending messages until we have received
    // a matchIndex that confirms that they have been informed of their own
    // removal.
    // By always using the minimum index it's safe to call this multiple
    // times as as configurations change.

  }, {
    key: 'phaseOutUntilIndex',
    value: function phaseOutUntilIndex(index) {
      var _this = this;

      if (this._removeIndex !== Infinity) {
        this._removeIndex = Math.min(this._removeIndex, index);
        this._removeTimeoutId = setTimeout(function () {
          _this._removeTimeoutId = null;
          _this._removeSelf();
        }, FOLLOWER_REMOVE_TIMEOUT_MS);
      }
    }
  }, {
    key: 'handleAppendEntriesResponse',
    value: function handleAppendEntriesResponse(message) {
      this._topologyInfo._update(message);

      if (message.success) {
        this._matchIndex = message.matchIndex;
        this._nextIndex = message.matchIndex + 1;
        if (this._log.lastLogIndex > this._nextIndex) {
          this._sendAppendRequest(5);
        } else {
          this._idle = true;
        }
      } else {
        this._nextIndex = message.matchIndex;
        if (this._nextIndex < 1) {
          this._nextIndex = 1;
        }
        this._sendAppendRequest(0);
      }

      if (this._matchIndex >= this._removeIndex) {
        clearTimeout(this._removeTimeoutId);
        this._removeTimeoutId = null;
        this._removeSelf();
      }
    }
  }, {
    key: '_onAppend',
    value: function _onAppend(toIndex) {
      // Will only trigger a send if we have received acks for all messages
      if (this._nextIndex === toIndex) {
        if (this._idle) {
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].verbose(TAG, this, 'was idle when matching entries were added, sending');
          this._sendAppendRequest(5);
        } else {
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].verbose(TAG, this, 'was busy when matching entries were added');
        }
      }
    }
  }, {
    key: '_sendAppendRequest',
    value: function _sendAppendRequest() {
      var maxEntries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var prevIndex = this._nextIndex - 1;
      var prevTerm = this._log.entryTermAtIndex(prevIndex);
      var entries = this._log.sliceEntries(this._nextIndex, this._nextIndex + maxEntries);

      var maxCommitIndex = this._log.commitIndex;
      var lastEntryIndex = prevIndex + entries.length;
      var commitIndex = Math.min(maxCommitIndex, lastEntryIndex);

      this._send(__WEBPACK_IMPORTED_MODULE_16_conference_raftMessages__["b" /* AppendEntriesRequest */].create({
        term: this._term,
        topologyIndex: this._topologyInfo.topologyIndex,
        prevIndex: prevIndex,
        prevTerm: prevTerm,
        commitIndex: commitIndex,
        entries: entries
      }));

      this._idle = false;
    }
  }, {
    key: '_startTimeout',
    value: function _startTimeout() {
      var _this2 = this;

      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
      }
      this._timeoutId = setTimeout(function () {
        _this2._startTimeout();
        _this2._sendAppendRequest(1);
      }, EXPECTED_RTT_MS * 4);
    }
  }, {
    key: 'matchIndex',
    get: function get() {
      return this._matchIndex;
    }
  }]);

  return FollowerMapEntry;
}();

/*
  ##       ########    ###    ########  ######## ########
  ##       ##         ## ##   ##     ## ##       ##     ##
  ##       ##        ##   ##  ##     ## ##       ##     ##
  ##       ######   ##     ## ##     ## ######   ########
  ##       ##       ######### ##     ## ##       ##   ##
  ##       ##       ##     ## ##     ## ##       ##    ##
  ######## ######## ##     ## ########  ######## ##     ##
*/

var LeaderState = function (_RaftState) {
  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default()(LeaderState, _RaftState);

  function LeaderState(log, send) {
    var term = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck___default()(this, LeaderState);

    var _this3 = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default()(this, (LeaderState.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(LeaderState)).call(this, log, send, term));

    _this3._onTopologyChange = _this3._onTopologyChange.bind(_this3);

    // TODO: Leader should also have an election timeout that is triggered if not
    // a majority of the followers respond.
    _this3._followerMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();
    _this3._joinerMap = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();
    _this3._pendingAdditions = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default.a();
    _this3._pendingRemovals = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default.a();

    _this3.start();
    return _this3;
  }

  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass___default()(LeaderState, [{
    key: 'toString',
    value: function toString() {
      return 'leader{term=' + this._term + '}';
    }
  }, {
    key: 'start',
    value: function start() {
      var _this4 = this;

      this._log.createOpEntry({ term: this._term, op: __WEBPACK_IMPORTED_MODULE_15_conference_raftLogEntry__["a" /* OP */].noop });
      this._afterAppend();
      var nextIndex = this._log.lastLogIndex + 1;
      this._log.meshTopology.activate();
      this._log.meshTopology.addChangeListener(this._onTopologyChange);
      this._log.configuration.forEachPeer(function (peerId) {
        return _this4._addFollower(peerId, nextIndex);
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      this._followerMap.forEach(function (follower) {
        return follower.stop();
      });
      this._followerMap.clear();
      this._joinerMap.forEach(function (intervalId) {
        return clearInterval(intervalId);
      });
      this._joinerMap.clear();
      this._log.meshTopology.removeChangeListener(this._onTopologyChange);
      this._log.meshTopology.deactivate();
    }
  }, {
    key: '_onTopologyChange',
    value: function _onTopologyChange(topology, changedUpState) {
      var _this5 = this;

      if (!changedUpState) {
        // Leader only cares about connections going up and down, rtt/bw is for relaying
        return;
      }

      __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].verbose(TAG, this, 'got significant topology change, checking if any members should be removed');

      // First we figure out what member connections we are missing between ourselves and each follower
      var missingConnections = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default.a();
      var localLinks = topology.localTopologyInfo.links;
      // this._followerMap.forEach((follower, peerId) => {
      this._log.configuration.members.forEach(function (peerId) {
        if (peerId === _this5._log.configuration.ownId) {
          return;
        }
        var localLink = localLinks[peerId];
        if (localLink && localLink.up) {
          return;
        }
        if (_this5._pendingRemovals.has(peerId)) {
          return;
        }
        missingConnections.add(peerId);
      });

      if (missingConnections.size === 0) {
        return;
      }

      // Look at the link infos for the rest of the cluster and keep all connections
      // where some other conference member has a conneciton.
      topology.topologyInfos.forEach(function (_ref2, peerId) {
        var links = _ref2.links;

        // If our link to the peer is down we don't trust the current peer link info
        var localLink = localLinks[peerId];
        if (!localLink || !localLink.up) {
          return;
        }
        if (_this5._followerMap.has(peerId)) {
          missingConnections.forEach(function (missingPeerId) {
            if (missingPeerId === peerId) {
              return;
            }
            if (links[missingPeerId] && links[missingPeerId].up) {
              __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, _this5, 'not removing connection to ' + missingPeerId + ' because ' + peerId + ' has a connection');
              missingConnections.delete(missingPeerId);
            }
          });
        }
      });

      __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].info(TAG, this, 'removing connections to [' + [].concat(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default()(missingConnections)).join(',') + '] with topology: ' + topology);
      // Now we're left with all peers that should be removed
      missingConnections.forEach(function (peerId) {
        _this5._pendingRemovals.add(peerId);
      });
      this._handlePendingMembershipUpdates();
    }

    // When adding a peer it will always be in the joiner state. This is because a joiner
    // does not transition to follower until a configuration with their id has been committed.
    // Meaning that if we manager to get elected as leader, we will either see the peer in the
    // configuration and ignore the add request, or we won't and the peer must still be in
    // the joiner state.

  }, {
    key: 'addPeer',
    value: function addPeer(_ref3) {
      var _this6 = this;

      var peerId = _ref3.peerId,
          _ref3$mustRejoin = _ref3.mustRejoin,
          mustRejoin = _ref3$mustRejoin === undefined ? true : _ref3$mustRejoin;

      if (this._followerMap.has(peerId)) {
        var isMember = this._log.configuration.members.has(peerId);
        var localLink = this._log.meshTopology.localTopologyInfo.links[peerId];
        if (isMember && localLink && localLink.up && !mustRejoin) {
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'got add request for follower, but the link is up, ignoring');
          return;
        } else {
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'got add request for follower, ' + peerId + ', resetting state');
          this._removeFollower(peerId);
        }
      }
      if (this._joinerMap.has(peerId)) {
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'got a second request to add peer ' + peerId);
        return;
      }
      __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'added peer to joiners: ' + peerId);

      var sendSnapshot = function sendSnapshot() {
        var snapshot = _this6._log.createSnapshot(_this6._term);
        _this6._send(peerId, snapshot);
      };
      var intervalId = setInterval(sendSnapshot, EXPECTED_RTT_MS * 4);
      this._joinerMap.set(peerId, intervalId);
      sendSnapshot();
    }
  }, {
    key: 'appendConfiguration',
    value: function appendConfiguration(data) {
      var _this7 = this;

      var oldMembers = this._log.configuration.members;
      var entry = this._log.createConfigurationEntry({ term: this._term, data: data });
      var newMembers = this._log.configuration.members;

      var _diff = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13_common_utils__["diff"])(oldMembers, newMembers),
          _diff2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_diff, 2),
          addedPeers = _diff2[0],
          removedPeers = _diff2[1];

      var nextIndex = this._log.lastLogIndex + 1;

      addedPeers.forEach(function (peerId) {
        return _this7._addFollower(peerId, nextIndex);
      });
      removedPeers.forEach(function (peerId) {
        var follower = _this7._followerMap.get(peerId);
        if (follower) {
          follower.phaseOutUntilIndex(nextIndex);
        }
      });
      this._afterAppend();
      return entry;
    }
  }, {
    key: '_afterAppend',
    value: function _afterAppend() {
      var index = this._log.lastLogIndex;
      this._followerMap.forEach(function (follower) {
        follower._onAppend(index);
      });
      this._tryCommit();
    }
  }, {
    key: 'handleAppendEntriesRequest',
    value: function handleAppendEntriesRequest(peerId, message) {
      if (message.term === this._term) {
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, 'ERROR: ' + this + ' received append request for own term: ' + message);
      } else if (message.term > this._term) {
        // A new leader was elected, allow it to take over
        return __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get___default()(LeaderState.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(LeaderState.prototype), 'handleAppendEntriesRequest', this).call(this, peerId, message);
      }
    }
  }, {
    key: 'handleAppendEntriesResponse',
    value: function handleAppendEntriesResponse(peerId, message) {
      if (message.term === this._term) {
        // TODO: Add tests for this
        if (message.needSnapshot) {
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'received append entries response from ' + peerId + ' with needSnapshot flag');
          this.addPeer({ peerId: peerId, mustRejoin: true });
          return;
        }
        // Got a response to one of our append requests
        var follower = this._followerMap.get(peerId);
        if (follower) {
          follower.handleAppendEntriesResponse(message);
          if (message.success) {
            // We have appended new log entires, might be able to increment commit index
            this._tryCommit();
          }
        } else {
          __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, 'ERROR: ' + this + ' got append entries response from unknown peer: ' + peerId);
        }
      } else if (message.term > this._term) {
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, 'ERROR: ' + this + ' received append response for newer term: ' + message);
      }
    }
  }, {
    key: 'handleSnapshotResponse',
    value: function handleSnapshotResponse(peerId, message) {
      if (message.term !== this._term) {
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].warning(TAG, this, 'received snapshot response for future term: ' + message);
        return;
      }
      var intervalId = this._joinerMap.get(peerId);
      if (!intervalId) {
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'received snapshot response for missing joiner: ' + message);
        return;
      }
      clearInterval(intervalId);
      this._joinerMap.delete(peerId);

      __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'accepted snapshot response from ' + peerId + ': ' + message);
      var lastIndex = message.lastIndex;

      this._addFollower(peerId, lastIndex + 1);

      this._pendingAdditions.add(peerId);
      this._handlePendingMembershipUpdates();
    }
  }, {
    key: 'handleStateOpRequest',
    value: function handleStateOpRequest(peerId, message) {
      this.forwardStateOpRequest(message);
      this._send(peerId, message.response());
    }
  }, {
    key: 'forwardStateOpRequest',
    value: function forwardStateOpRequest(request) {
      var id = request.id,
          op = request.op,
          args = request.args;

      this._log.createOpEntry({ term: this._term, id: id, op: op, args: args });
      this._afterAppend();
    }
  }, {
    key: '_tryCommit',
    value: function _tryCommit() {
      var matchIndices = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()({}, this._log.configuration.ownId, this._log.lastLogIndex);
      this._followerMap.forEach(function (follower, clientId) {
        matchIndices[clientId] = follower.matchIndex;
      });
      var majorityMatchIndex = this._log.configuration.getMajorityIndex(matchIndices);
      var committed = this._log.tryCommitIndexForTerm(majorityMatchIndex, this._term);

      if (committed && committed.length) {
        this._followerMap.forEach(function (follower) {
          return follower._sendAppendRequest(0);
        });
      }

      if (committed && committed.some(function (entry) {
        return entry instanceof __WEBPACK_IMPORTED_MODULE_15_conference_raftLogEntry__["b" /* ConfigurationEntry */];
      })) {
        // This assumes that there can only be a single un-committed configuration log entry
        // at any given time for any leader. Afaik that is true but needs some proof.
        this._handlePendingMembershipUpdates();
      }
    }
  }, {
    key: '_handlePendingMembershipUpdates',
    value: function _handlePendingMembershipUpdates() {
      if (this._pendingAdditions.size + this._pendingRemovals.size === 0) {
        return;
      }

      var members = this._log.configuration.members;

      // The configuration implementation in the first Raft paper is more
      // complex and less robus than the one in the thesis.
      // The basic concept of the one from the thesis is that as long as
      // we do few enough additions or removals each time, it is safe.
      //
      // TODO: It's possible to add or remove more than one members at
      // at time in large clusters, figure out limits.
      if (this._pendingRemovals.size) {
        var _ref4 = [].concat(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default()(this._pendingRemovals)),
            removed = _ref4[0];

        this._pendingRemovals.delete(removed);
        members.delete(removed);
      } else if (this._pendingAdditions.size) {
        var _ref5 = [].concat(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toConsumableArray___default()(this._pendingAdditions)),
            added = _ref5[0];

        this._pendingAdditions.delete(added);
        members.add(added);
      }

      var data = this._log.configuration.createMembersChange(members);
      this.appendConfiguration(data);
    }
  }, {
    key: '_addFollower',
    value: function _addFollower(peerId, nextIndex) {
      var _this8 = this;

      if (this._followerMap.has(peerId)) {
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'not adding new follower, already exists since joining: ' + peerId);
        return;
      }
      __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'added peer to followers: ' + peerId);
      var send = function send(message) {
        return _this8._send(peerId, message);
      };
      var topologyInfo = this._log.meshTopology.addClient(peerId);
      var follower = new FollowerMapEntry({
        term: this._term,
        nextIndex: nextIndex,
        topologyInfo: topologyInfo,
        log: this._log,
        send: send,
        remove: this._removeFollower.bind(this, peerId)
      });
      this._followerMap.set(peerId, follower);
      follower.start();
    }
  }, {
    key: '_removeFollower',
    value: function _removeFollower(peerId) {
      var follower = this._followerMap.get(peerId);
      if (follower) {
        follower.stop();
        this._followerMap.delete(peerId);
        this._log.meshTopology.removeClient(peerId);
      } else {
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].warning(TAG, this, 'failed to remove missing follower: ' + peerId);
      }
    }
  }]);

  return LeaderState;
}(RaftState);

/*
  ########  #######  ##       ##        #######  ##      ## ######## ########
  ##       ##     ## ##       ##       ##     ## ##  ##  ## ##       ##     ##
  ##       ##     ## ##       ##       ##     ## ##  ##  ## ##       ##     ##
  ######   ##     ## ##       ##       ##     ## ##  ##  ## ######   ########
  ##       ##     ## ##       ##       ##     ## ##  ##  ## ##       ##   ##
  ##       ##     ## ##       ##       ##     ## ##  ##  ## ##       ##    ##
  ##        #######  ######## ########  #######   ###  ###  ######## ##     ##
*/

var FollowerState = function (_RaftState2) {
  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default()(FollowerState, _RaftState2);

  function FollowerState(log, send) {
    var term = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var leader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var votedFor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck___default()(this, FollowerState);

    var _this9 = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default()(this, (FollowerState.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(FollowerState)).call(this, log, send, term));

    __WEBPACK_IMPORTED_MODULE_11_common_argCheck__["a" /* default */].optString(_this9, 'leader', leader);

    _this9._sendPreVoteRequests = _this9._sendPreVoteRequests.bind(_this9);

    _this9._leader = leader;
    _this9._votedFor = votedFor;

    // When doing a pre-vote, this is the term we would candidate for
    _this9._targetTerm = null;
    return _this9;
  }

  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass___default()(FollowerState, [{
    key: 'toString',
    value: function toString() {
      return 'follower{term=' + this._term + ',leader=' + this._leader + ',votedFor=' + this._votedFor + '}';
    }
  }, {
    key: 'hasVote',
    value: function hasVote(peerId) {
      return this._votedFor === peerId;
    }
  }, {
    key: 'toFollower',
    value: function toFollower(term, leader) {
      var votedFor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (term > this._term) {
        this._term = term;
        this._leader = leader;
        this._votedFor = votedFor;
      }
      if (term === this._term && !this._leader) {
        this._leader = leader;
      }
      this.stop();
      return this;
    }

    // The below code is a part of the pre-vote modification of Raft, see raftMessages.js

  }, {
    key: 'toCandidate',
    value: function toCandidate(term, preVoteDone) {
      if (preVoteDone) {
        return __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get___default()(FollowerState.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(FollowerState.prototype), 'toCandidate', this).call(this, term, preVoteDone);
      }
      this.stop();
      this._targetTerm = term;
      this._preVotes = new __WEBPACK_IMPORTED_MODULE_14_conference_raftConfiguration__["d" /* Votes */](this._log.configuration.ownId);
      this.start();
      return this;
    }
  }, {
    key: 'start',
    value: function start() {
      this._sendPreVoteRequests();
      this._intervalId = setInterval(this._sendPreVoteRequests, EXPECTED_RTT_MS * 4);
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
      if (this._targetTerm) {
        this._targetTerm = null;
        this._preVotes = null;
      }
    }
  }, {
    key: 'handlePreVoteResponse',
    value: function handlePreVoteResponse(peerId, message) {
      if (this._targetTerm && message.term === this._targetTerm) {
        // We got a vote for the current term, so we store the reply and check if we
        // have received enough votes to have a majority and become leader
        this._preVotes.set(peerId, message.granted);
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'received pre-vote reply from ' + peerId + ': ' + (message.granted ? 'granted' : 'rejected'));
        if (this._log.configuration.hasMajority(this._preVotes.grantedVotes)) {
          return __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get___default()(FollowerState.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(FollowerState.prototype), 'toCandidate', this).call(this, this._targetTerm, true);
        }
      }
    }
  }, {
    key: 'forwardStateOpRequest',
    value: function forwardStateOpRequest(request) {
      if (this._leader) {
        this._send(this._leader, request);
      } else {
        // We just let the client time out for now
        // TODO: Use an async queue to serialize messages and send feedback
      }
    }
  }, {
    key: '_sendPreVoteRequests',
    value: function _sendPreVoteRequests() {
      var _this10 = this;

      var request = __WEBPACK_IMPORTED_MODULE_16_conference_raftMessages__["f" /* PreVoteRequest */].create({
        term: this._targetTerm, // we're going to be voting in the next term
        lastLogTerm: this._log.lastLogTerm,
        lastLogIndex: this._log.lastLogIndex
      });

      this._log.configuration.forEachPeer(function (peerId) {
        if (!_this10._preVotes.has(peerId)) {
          _this10._send(peerId, request);
        }
      });
    }
  }]);

  return FollowerState;
}(RaftState);

/*
   ######     ###    ##    ## ########  #### ########     ###    ######## ########
  ##    ##   ## ##   ###   ## ##     ##  ##  ##     ##   ## ##      ##    ##
  ##        ##   ##  ####  ## ##     ##  ##  ##     ##  ##   ##     ##    ##
  ##       ##     ## ## ## ## ##     ##  ##  ##     ## ##     ##    ##    ######
  ##       ######### ##  #### ##     ##  ##  ##     ## #########    ##    ##
  ##    ## ##     ## ##   ### ##     ##  ##  ##     ## ##     ##    ##    ##
   ######  ##     ## ##    ## ########  #### ########  ##     ##    ##    ########
*/

var CandidateState = function (_RaftState3) {
  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default()(CandidateState, _RaftState3);

  function CandidateState(log, send, term, preVoteDone) {
    __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck___default()(this, CandidateState);

    var _this11 = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default()(this, (CandidateState.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(CandidateState)).call(this, log, send, term));

    _this11._tick = _this11._tick.bind(_this11);

    // Start by gathering a majority of pre-votes, otherwise we wait until next election.
    // Pre-votes are a modification to Raft, see raftMessages.js
    _this11._preVoteDone = preVoteDone;
    _this11._preVotes = preVoteDone ? null : new __WEBPACK_IMPORTED_MODULE_14_conference_raftConfiguration__["d" /* Votes */](log.configuration.ownId);
    _this11._votes = preVoteDone ? new __WEBPACK_IMPORTED_MODULE_14_conference_raftConfiguration__["d" /* Votes */](log.configuration.ownId) : null;
    _this11._intervalId = null;

    _this11.start();
    return _this11;
  }

  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass___default()(CandidateState, [{
    key: 'toString',
    value: function toString() {
      return 'candidate{term=' + this._term + ',votes=' + this._votes + '}';
    }
  }, {
    key: 'start',
    value: function start() {
      this._tick();
      this._intervalId = setInterval(this._tick, EXPECTED_RTT_MS * 4);
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
    }
  }, {
    key: '_tick',
    value: function _tick() {
      var _this12 = this;

      var requestFactory = this._preVoteDone ? __WEBPACK_IMPORTED_MODULE_16_conference_raftMessages__["d" /* RequestVoteRequest */] : __WEBPACK_IMPORTED_MODULE_16_conference_raftMessages__["f" /* PreVoteRequest */];
      var voteCollection = this._preVoteDone ? this._votes : this._preVotes;

      var request = requestFactory.create({
        term: this._term,
        lastLogTerm: this._log.lastLogTerm,
        lastLogIndex: this._log.lastLogIndex
      });

      this._log.configuration.forEachPeer(function (peerId) {
        if (!voteCollection.has(peerId)) {
          _this12._send(peerId, request);
        }
      });
    }
  }, {
    key: 'handlePreVoteResponse',
    value: function handlePreVoteResponse(peerId, message) {
      if (!this._preVoteDone && message.term === this._term) {
        // We got a vote for the current term, so we store the reply and check if we
        // have received enough votes to have a majority and become leader
        this._preVotes.set(peerId, message.granted);
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'received pre-vote reply from ' + peerId + ': ' + (message.granted ? 'granted' : 'rejected'));
        if (this._log.configuration.hasMajority(this._preVotes.grantedVotes)) {
          this._preVoteDone = true;
          this._votes = new __WEBPACK_IMPORTED_MODULE_14_conference_raftConfiguration__["d" /* Votes */](this._log.configuration.ownId);
          // trigger tick and reset timer
          this.stop();
          this.start();
        }
      }
    }
  }, {
    key: 'handleRequestVoteResponse',
    value: function handleRequestVoteResponse(peerId, message) {
      if (this._preVoteDone && message.term === this._term) {
        // We got a vote for the current term, so we store the reply and check if we
        // have received enough votes to have a majority and become leader
        this._votes.set(peerId, message.granted);
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].debug(TAG, this, 'received vote reply from ' + peerId + ': ' + (message.granted ? 'granted' : 'rejected'));
        if (this._log.configuration.hasMajority(this._votes.grantedVotes)) {
          return this.toLeader(this._term);
        }
      }
    }
  }]);

  return CandidateState;
}(RaftState);

/*
        ##  #######  #### ##    ## ######## ########
        ## ##     ##  ##  ###   ## ##       ##     ##
        ## ##     ##  ##  ####  ## ##       ##     ##
        ## ##     ##  ##  ## ## ## ######   ########
  ##    ## ##     ##  ##  ##  #### ##       ##   ##
  ##    ## ##     ##  ##  ##   ### ##       ##    ##
   ######   #######  #### ##    ## ######## ##     ##
*/

// The joiner state is a new state not documented in the main raft paper.
//
// In this state the client waits for a snapshot request to be able to join in, it
// then waits for a configuration to be committed where the client is a member of the cluster.
//
// When adding a peer, the leader will first send snaptshots until a snapshot response for
// the current term is received. It will then request a new configuration which includes the
// new client as soon as possible.
//
// Clients in the joiner state will not vote or be requested to vote, they will also not
// time out and start candidating.
var JoinerState = function (_RaftState4) {
  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default()(JoinerState, _RaftState4);

  function JoinerState(log, send) {
    __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_classCallCheck___default()(this, JoinerState);

    return __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default()(this, (JoinerState.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(JoinerState)).call(this, log, send, 0));
  }

  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_createClass___default()(JoinerState, [{
    key: 'toString',
    value: function toString() {
      return 'joiner{}';
    }
  }, {
    key: 'handleAppendEntriesRequest',
    value: function handleAppendEntriesRequest(peerId, message) {
      if (this._term === 0) {
        // We haven't received a snapshot yet. The old leader was probably replaced and the new one thinks
        // we're a regular cluster member.
        this._send(peerId, message.response({ needSnapshot: true }));
        return;
      }
      var response = this._log.handleAppendEntriesRequest(message);
      if (response) {
        this._send(peerId, response);
        this._term = message.term;
        return this._convertToFollowerIfMember(peerId);
      }
    }
  }, {
    key: 'handleAppendEntriesResponse',
    value: function handleAppendEntriesResponse(peerId, message) {}
  }, {
    key: 'handleRequestVoteRequest',
    value: function handleRequestVoteRequest(peerId, message) {
      // joiners do not participate in voting in any way
    }
  }, {
    key: 'handleRequestVoteResponse',
    value: function handleRequestVoteResponse(peerId, message) {}
  }, {
    key: 'handleSnapshotRequest',
    value: function handleSnapshotRequest(peerId, message) {
      if (this._term > message.term || this._log.commitIndex > message.lastIndex) {
        return; // ignore old snapshots
      }
      this._log.loadSnapshot(message);
      this._send(peerId, message.response());
      this._term = message.term;
      return this._convertToFollowerIfMember(peerId);
    }
  }, {
    key: 'handleSnapshotResponse',
    value: function handleSnapshotResponse(peerId, message) {}
  }, {
    key: '_convertToFollowerIfMember',
    value: function _convertToFollowerIfMember(peerId) {
      var configData = this._log.getCommittedConfigurationData();
      var ownId = this._log.configuration.ownId;
      if (configData.includes(ownId)) {
        __WEBPACK_IMPORTED_MODULE_12_common_log__["default"].info(TAG, this, 'found itself in committed configuration, converting to follower');
        return this.toFollower(this._term, peerId);
      }
    }
  }]);

  return JoinerState;
}(RaftState);

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = parseId;
/* harmony export (immutable) */ __webpack_exports__["a"] = parseIdForServer;
/* harmony export (immutable) */ __webpack_exports__["b"] = toMatrixIdForServer;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toArray__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_defineProperty__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_argCheck__ = __webpack_require__(12);






var _typeTagMap;



var TYPE_ROOM = 'room';
var TYPE_USER = 'user';
var TYPE_EVENT = 'event';
var TYPE_ALIAS = 'alias';

var tagTypeMap = {
  '!': TYPE_ROOM,
  '@': TYPE_USER,
  '$': TYPE_EVENT,
  '#': TYPE_ALIAS
};
var typeTagMap = (_typeTagMap = {}, __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_defineProperty___default()(_typeTagMap, TYPE_ROOM, '!'), __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_defineProperty___default()(_typeTagMap, TYPE_USER, '@'), __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_defineProperty___default()(_typeTagMap, TYPE_EVENT, '$'), __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_defineProperty___default()(_typeTagMap, TYPE_ALIAS, '#'), _typeTagMap);

function parseId(matrixId) {
  __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('parseId', 'matrixId', matrixId);

  var _matrixId$split = matrixId.split(':'),
      _matrixId$split2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toArray___default()(_matrixId$split),
      id = _matrixId$split2[0],
      rest = _matrixId$split2.slice(1);

  var typeTag = id[0];
  var localId = id.slice(1);
  if (localId.length === 0) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('parseId', 'matrixId', 'not have an empty local id');
  }
  var type = tagTypeMap[typeTag];
  if (!type) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('parseId', 'matrixId', 'have a valid type tag');
  }
  var serverName = rest.join(':');
  if (serverName.length === 0) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('parseId', 'matrixId', 'not have an empty server name');
  }
  return [type, localId, serverName];
}

function parseIdForServer(context, matrixId, serverName, expectedType) {
  __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string(context, 'serverName', serverName);

  var _parseId = parseId(matrixId),
      _parseId2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_parseId, 3),
      type = _parseId2[0],
      localId = _parseId2[1],
      parsedServerName = _parseId2[2];

  if (type !== expectedType) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error(context, 'type', 'be ' + expectedType + ' and not ' + type);
  }
  if (serverName === parsedServerName) {
    return localId;
  } else {
    return localId + ':' + parsedServerName;
  }
}

function toMatrixIdForServer(context, id, serverName, type) {
  __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string(context, 'id', id);
  var tag = typeTagMap[type];
  if (!type) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error(context, 'type', 'use a valid type');
  }

  if (id.indexOf(':') === -1) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string(context, 'serverName', serverName);
    id = id + ':' + serverName;
  }
  if (id[0] !== tag) {
    id = tag + id;
  }

  return id;
}

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(171), __esModule: true };

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(173);
module.exports = __webpack_require__(0).Object.assign;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(174);
var $Object = __webpack_require__(0).Object;
module.exports = function getOwnPropertyNames(it){
  return $Object.getOwnPropertyNames(it);
};

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = __webpack_require__(25)
  , gOPS     = __webpack_require__(68)
  , pIE      = __webpack_require__(43)
  , toObject = __webpack_require__(26)
  , IObject  = __webpack_require__(67)
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(21)(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(6);

$export($export.S + $export.F, 'Object', {assign: __webpack_require__(172)});

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(46)('getOwnPropertyNames', function(){
  return __webpack_require__(91).f;
});

/***/ }),
/* 175 */
/***/ (function(module, exports) {

var grammar = module.exports = {
  v: [{
      name: 'version',
      reg: /^(\d*)$/
  }],
  o: [{ //o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  //k: [{}], // outdated thing ignored
  t: [{ //t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: "%d %d"
  }],
  c: [{ //c=IN IP4 10.47.197.26
      name: 'connection',
      reg: /^IN IP(\d) (\S*)/,
      names: ['version', 'ip'],
      format: "IN IP%d %s"
  }],
  b: [{ //b=AS:4000
      push: 'bandwidth',
      reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
      names: ['type', 'limit'],
      format: "%s:%s"
  }],
  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
      // NB: special - pushes to session
      // TODO: rtp/fmtp should be filtered by the payloads found here?
      reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
      names: ['type', 'port', 'protocol', 'payloads'],
      format: "%s %d %s %s"
  }],
  a: [
    { //a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding) ?
          "rtpmap:%d %s/%s/%s":
          o.rate ?
          "rtpmap:%d %s/%s":
          "rtpmap:%d %s";
      }
    },
    {
      //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      //a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: "fmtp:%d %s"
    },
    { //a=control:streamid=0
        name: 'control',
        reg: /^control:(.*)/,
        format: "control:%s"
    },
    { //a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null) ?
          "rtcp:%d %s IP%d %s":
          "rtcp:%d";
      }
    },
    { //a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: "rtcp-fb:%d trr-int %d"
    },
    { //a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null) ?
          "rtcp-fb:%s %s %s":
          "rtcp-fb:%s %s";
      }
    },
    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      //a=extmap:1/recvonly URI-gps-string
      push: 'ext',
      reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
      names: ['value', 'uri', 'config'], // value may include "/direction" suffix
      format: function (o) {
        return (o.config != null) ?
          "extmap:%s %s %s":
          "extmap:%s %s";
      }
    },
    {
      //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null) ?
          "crypto:%d %s %s %s":
          "crypto:%d %s %s";
      }
    },
    { //a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    { //a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    { //a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*)/,
      format: "ptime:%d"
    },
    { //a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*)/,
      format: "maxptime:%d"
    },
    { //a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    { //a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    { //a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: "fingerprint:%s %s"
    },
    {
      //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0
      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0
      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation'],
      format: function (o) {
        var str = "candidate:%s %d %s %d %s %d typ %s";

        str += (o.raddr != null) ? " raddr %s rport %d" : "%v%v";

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? " tcptype %s" : "%v";

        if (o.generation != null) {
          str += " generation %d";
        }
        return str;
      }
    },
    { //a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    { //a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
      names: ['id', 'attribute', 'value'],
      format: "ssrc:%d %s:%s"
    },
    { //a=ssrc-group:FEC 1 2
      push: "ssrcGroups",
      reg: /^ssrc-group:(\w*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: "ssrc-group:%s %s"
    },
    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: "msid-semantic: %s %s" // space after ":" is not accidental
    },
    { //a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: "group:%s %s"
    },
    { //a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    { //a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    { // any a= that we don't understand is kepts verbatim on media.invalid
      push: 'invalid',
      names: ["value"]
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = "%s";
    }
  });
});


/***/ }),
/* 176 */,
/* 177 */,
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_mediaSource__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_webrtc_utils__ = __webpack_require__(66);











/**
 * A dummy source that can generate a silent audio stream and a 1x1 black video stream.
 *
 * Useful for testing and working around browser bugs where streams have to be present.
 *
 * @class DummySource
 * @extends MediaSource
 * @param {Object} [options] - Optional options object
 * @param {boolean} [options.video=true] - Whether to generate dummy video.
 * @param {boolean} [options.audio=true] - Whether to generate dummy audio.
 */

var DummySource = function (_MediaSource) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(DummySource, _MediaSource);

  function DummySource() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { audio: true, video: true },
        audio = _ref.audio,
        video = _ref.video;

    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, DummySource);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (DummySource.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(DummySource)).call(this));

    var tracks = [];
    if (audio) {
      _this._audioContext = __WEBPACK_IMPORTED_MODULE_7_webrtc_utils__["audioContextUtil"].get();
      _this._destination = _this._audioContext.createMediaStreamDestination();

      var _this$_destination$st = _this._destination.stream.getTracks(),
          _this$_destination$st2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_this$_destination$st, 1),
          track = _this$_destination$st2[0];
      // track.enabled = false


      tracks.push(track);

      _this._silence = _this._audioContext.createBufferSource();
      _this._silence.connect(_this._destination, 0, 0);
    }
    if (video) {
      _this._canvas = document.createElement('canvas');
      _this._canvas.style.width = '1px';
      _this._canvas.style.height = '1px';
      _this._canvas.width = 1;
      _this._canvas.height = 1;

      // Otherwise Firefox will complain about the canvas not being initialized
      _this._canvas.getContext('2d');

      var stream = _this._canvas.captureStream(1);

      var _stream$getTracks = stream.getTracks(),
          _stream$getTracks2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_stream$getTracks, 1),
          _track = _stream$getTracks2[0];
      // track.enabled = false


      tracks.push(_track);
    }
    _this._stream = new MediaStream(tracks);
    _this.setStream(_this._stream);
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(DummySource, [{
    key: 'stop',


    /**
     * Stops the source and cleans up all resources. This has to be called once the source
     * is no longer used in order to clean up resources.
     *
     * Calling this method multiple times has no effect.
     */
    value: function stop() {
      if (this._stream) {
        this.setStream(null);
        this._stream.getTracks().forEach(function (track) {
          return track.stop();
        });
        this._stream = null;
        this._canvas = null;
        if (this._audioContext) {
          __WEBPACK_IMPORTED_MODULE_7_webrtc_utils__["audioContextUtil"].release();
          this._audioContext = null;
          this._destination = null;
          this._silence.stop();
          this._silence = null;
        }
      }
    }

    /**
     * @private
     * @function DummySource#setStream
     */

  }, {
    key: 'output',
    get: function get() {
      return this._output;
    }
  }]);

  return DummySource;
}(__WEBPACK_IMPORTED_MODULE_6_media_mediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (DummySource);

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_mediaNodeOutput__ = __webpack_require__(149);













var TAG = 'media-filter';

/**
 * A base class for media nodes with a single input and a single output.
 *
 * The subclass should override the `onStream` method, and call `setStream` to update
 * the output stream.
 *
 * @class MediaFilter
 * @extends MediaNode
 * @extends ConnectMixin
 */

var MediaFilter = function (_MediaNode$connectMix) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(MediaFilter, _MediaNode$connectMix);

  function MediaFilter() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, MediaFilter);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (MediaFilter.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(MediaFilter)).call(this));

    _this._input = new __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__["a" /* default */]({
      name: 'default',
      parent: _this,
      onStream: _this.onStream.bind(_this)
    });
    _this._output = new __WEBPACK_IMPORTED_MODULE_8_media_mediaNodeOutput__["a" /* default */]({
      name: 'default',
      parent: _this
    });
    return _this;
  }

  /**
   * The input of the filter.
   *
   * @readonly
   * @member {MediaNodeInput} MediaFilter#input
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(MediaFilter, [{
    key: 'onStream',


    /**
     * Abstract method that is called whenever the input stream is updated, this should
     * be overridden by the subclass.
     *
     * This will only ever be called if the stream has changed, been added, or removed,
     * i.e. stream and oldStream will never be equal.
     *
     * The `onStream` method will not be called when the backing tracks of a stream is changed.
     * If the subclass needs to be notified of track updates this has to be done manually using
     * the MediaStream listeners.
     *
     * @abstract
     * @param  {?MediaStream} stream - The new media stream, or null.
     * @param  {?MediaStream} oldStream - The old media stream, or null.
     */
    value: function onStream(stream, oldStream) {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, this.constructor.name + '.onStream should be overridden');
    }

    /**
     * Sets the current output stream.
     *
     * This should only be called by the subclass implementation, and not from outside the media node.
     *
     * @param {?MediaStream} stream - The new output stream, or null.
     */

  }, {
    key: 'setStream',
    value: function setStream(stream) {
      this._output.setStream(stream);
    }
  }, {
    key: 'input',
    get: function get() {
      return this._input;
    }

    /**
     * The output of the filter.
     *
     * @readonly
     * @member {MediaNodeOutput} MediaFilter#output
     */

  }, {
    key: 'output',
    get: function get() {
      return this._output;
    }
  }]);

  return MediaFilter;
}(__WEBPACK_IMPORTED_MODULE_6_media_mediaNode__["a" /* default */].connectMixin(__WEBPACK_IMPORTED_MODULE_6_media_mediaNode__["a" /* default */]));

/* harmony default export */ __webpack_exports__["a"] = (MediaFilter);

/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaFilter__ = __webpack_require__(179);












var TAG = 'mute-filter';

/**
 * A media node that can mute the audio and/or video of a stream.
 *
 * @class MuteFilter
 * @extends MediaFilter
 */

var MuteFilter = function (_MediaFilter) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(MuteFilter, _MediaFilter);

  function MuteFilter() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$silent = _ref.silent,
        silent = _ref$silent === undefined ? false : _ref$silent;

    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, MuteFilter);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (MuteFilter.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(MuteFilter)).call(this));

    _this._audioMuted = false;
    _this._videoMuted = false;

    var filter = _this;
    _this._mute = {
      get audio() {
        return filter._audioMuted;
      },
      set audio(value) {
        value = Boolean(value);
        if (value !== filter._audioMuted) {
          filter._audioMuted = value;
          filter._updateMuteState();
        }
      },
      get video() {
        return filter._videoMuted;
      },
      set video(value) {
        value = Boolean(value);
        if (value !== filter._videoMuted) {
          filter._videoMuted = value;
          filter._updateMuteState();
        }
      }
    };
    return _this;
  }

  /**
   * Toggles muting of the media passing through this filter.
   *
   * When assigning an object to the property, only the media types
   *   present in the object will be updated.
   *
   * @example <caption>Different ways to set mute state</caption>
   * // directly
   * filter.mute.video = true
   *
   * // separately or simulateously
   * filter.mute = {
   *   video: true
   * }
   *
   * // both at once
   * filter.mute = true
   *
   * @member {Object} MuteFilter#mute
   * @property {boolean} audio - Audio mute state.
   * @property {boolean} video - Video mute state.
   */


  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(MuteFilter, [{
    key: '_updateMuteState',
    value: function _updateMuteState() {
      var _this2 = this;

      var stream = this.output.stream;

      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].debug(TAG, 'updating mute audio=' + this._audioMuted + ' video=' + this._videoMuted + ' state with stream ' + stream);
      if (stream) {
        stream.getAudioTracks().forEach(function (track) {
          track.enabled = !_this2._audioMuted;
        });
        stream.getVideoTracks().forEach(function (track) {
          track.enabled = !_this2._videoMuted;
        });
      }
    }

    /**
     * @private
     * @function MuteFilter#setStream
     */

    /**
     * @private
     * @param {MediaStream} stream - The new stream.
     */

  }, {
    key: 'onStream',
    value: function onStream(stream) {
      this.setStream(stream);
      this._updateMuteState();
    }
  }, {
    key: 'mute',
    get: function get() {
      return this._mute;
    },
    set: function set(value) {
      var audioMuteBefore = this._audioMuted;
      var videoMuteBefore = this._videoMuted;
      if (typeof value === 'boolean') {
        this._audioMuted = value;
        this._videoMuted = value;
      } else if ((typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default()(value)) === 'object' && value !== null) {
        if (value.hasOwnProperty('audio')) {
          this._audioMuted = !!value.audio;
        }
        if (value.hasOwnProperty('video')) {
          this._videoMuted = !!value.video;
        }
      }
      if (audioMuteBefore !== this._audioMuted || videoMuteBefore !== this._videoMuted) {
        this._updateMuteState();
      }
    }
  }]);

  return MuteFilter;
}(__WEBPACK_IMPORTED_MODULE_7_media_mediaFilter__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (MuteFilter);

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaFilter__ = __webpack_require__(179);












var TAG = 'passthrough';

/**
 * A simple identity filter that simply passes on the input stream.
 *
 * This node can e.g. be used to provide a separate output node in order to avoid losing
 * internal connections in a node. The example below shows how a container node uses a passthrough
 * element in order to avoid losing the connection between the filter and analyser if `disconnect()`
 * is called on the output.
 *
 * ```
 *                       ||
 *                     o-| Analyser |
 *          || | |__________|
 *  input o-| Filter |-o
 *          |________| | ||
 *                     o-| Passthrough |-o output
 *                       |_____________|
 * ```
 *
 * It can also be used to log updates and inspect a media pipeline.
 *
 * @class Passthrough
 * @extends MediaFilter
 * @extends EventEmitter
 * @param {Object} [options] - Optional options object.
 * @param {boolean} [options.silent=true] - If silent is set to false the node will emit a log
 *   message with log level `info` whenever the stream is updated.
 */

var Passthrough = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(Passthrough, _EmitterMixin);

  function Passthrough() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$silent = _ref.silent,
        silent = _ref$silent === undefined ? true : _ref$silent;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, Passthrough);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Passthrough.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(Passthrough)).call(this));

    _this._silent = silent;
    return _this;
  }

  /**
   * Emitted when the stream changes.
   *
   * @event Passthrough#stream
   * @param {?MediaStream} stream - The media stream.
   */

  // eslint-disable-next-line
  /**
   * @private
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Passthrough, [{
    key: 'onStream',
    value: function onStream(stream) {
      if (!this.silent) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, 'got new stream: ' + stream);
      }
      this.setStream(stream);
      this._emit('stream', stream);
    }
  }]);

  return Passthrough;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_7_media_mediaFilter__["a" /* default */]));

/* harmony default export */ __webpack_exports__["a"] = (Passthrough);

/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MT_OPEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return MT_OPEN_ACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return MT_DECLARE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return MT_CLOSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MT_CLEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return MT_DATA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return MT_PING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return MT_PONG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return MT_TRANSFER_HEADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return MT_TRANSFER_BINARY_DATA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return M_SEP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ID_BASE; });


// This module contains common constants for other
// datamux modules.

// Message types from senders point of view.

var MT_OPEN = 'o'; // <localId>:<base64Label>:<base64Protocol>
var MT_OPEN_ACK = 'a'; // <localId>:<remoteId>
var MT_DECLARE = 'd'; // <localId>:<base64Label>:<base64Protocol>:<base64PairingId>
var MT_CLOSE = 'c'; // <localId>
var MT_CLEAR = 'l'; // <localId>
var MT_DATA = 'j'; // <localId>:<jsonMessage>
var MT_PING = 'p'; // <pingTime>
var MT_PONG = 'g'; // <pingTime>

// Transfer message types
var MT_TRANSFER_HEADER = 'h'; // <transferId>:<typeDescriptor>:<byteLength>
var MT_TRANSFER_BINARY_DATA = 'b'; // <transferId>:<base64Data>

var M_SEP = ':';

var ID_BASE = 36; // The radix of the serialized channel IDs

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(202), __esModule: true };

/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_conference_raftLog__ = __webpack_require__(194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_conference_raftLogEntry__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_conference_meshTopology__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_conference_raftStateMachine__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_conference_raftState__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__ = __webpack_require__(147);


















/*
  Conferencing consensus plan:

  Raft (https://raft.github.io/) provides a simple consensus algorithm which
  is quite easy to implement and prove to be correct. It does not provide
  Byzantine fault tolerance, i.e. it assumes that all clients behave correctly.

  Each conference client participates in the Raft consensus protocol, there are no
  client-only nodes, like e.g. in etcd.
  The primary purpose of the Raft implementation is to provide a unified view of who the
  members of the conference are. Although it might prove to be useful for other types of
  log replication at a later stage.

  Raft supports controlled reconfiguration of the cluster members, which means that clients
  can be added and removed as long as a majority of the current cluster can agree on the change.
  For conferences we will sometimes see big changes in the number of participants. Adding
  members is quite straight-forward to do with the baseline Raft implementation, even if
  the new members make up the majority in the new configuration. Removing members is also
  straight-forward as long as the removed clients stay connected until the new configuration
  is in place.
  The tricky bit is getting rid of disconnected clients. The cluster needs to be able to
  reach a consensus that a client has been disconnected and can be removed. This will be
  even more troublesome if a majority of the cluster disconnects, as it may cause the
  new configuration and the entire cluster to get stuck in a bad state. Some mechanism
  for handling netsplits by letting minorities break away from the cluster needs to be
  implemented, as well as a mechanism for those clients to potentially rejoin the cluster
  at a later point.

  Alternative approaches:

  The main alternative to using Raft that is being considered is that all peers would
  simply broadcast the peers that they are connected to to all their connected peers.
  This way every peer would be able to get a somewhat complete view of the members,
  although it would fail to report peers that are more than two hops away. Consider
  the below scenario where clients A, B, C and D only have 3 connections set up so far.

    A <-> B <-> C <-> D

  With the proposed solution, A would be unaware of D's existence, and vice versa.
  This could be worked around by sending more information between the peers, with the
  downside of added complexity and bandwidth usage.
  Btw, Raft does not behave perfectly in the above scenario either, as A and D would take
  turns in triggering new elections, but there will still be some log replication happening
  and new connections should be set up soon enough.

  Another issue is feedback for the clients, should A respond to requests from B? Raft solves
  this with heartbeats and election timeouts.

  In the end the main reason for choosing Raft is that it is an established algorithm that
  is simple and easy to proove to be correct. Since raft needs to be extended a bit in order
  to work for conferences, it is possible that this alternative is reveisited if the
  modifications end up being too complex.
  A downside of using Raft is that the log replication functionality is not used at the
  moment, and it arguably what adds the most complexity to the algorithm. However, it is
  quite likely that it will be used in the future for Smart Mesh or SFU.

  Conference setup flow:

  An important piece of functionality for the below flow is that it is possible to generate
  a single offer that is valid for multiple peer connections, as long as all peer connections
  are configured to use the same certificate. We will try to use this functionality initially
  but may have to fall back to a more tranditional singaling approach if we run into trouble
  with plugins and native mobile clients.

  When joining a conference, send a JOIN message with the Raft ID and an offer SDP.
  Now one of two things may happen, either there is already an existing conference and the
  client will be added, or no one replies, and we wait. We likely want to repeat the JOIN
  message every so often while waiting, in order to provide some fault tolerance.

  When an existing conference sees a JOIN message a number of different things may happen
  depending on the state of the conference. But this is the general algorithm:

  (1) Upon receiving a JOIN message, every client adds the peer to a list of joining peers.
  (2) Every client that is a leader (there may be multiple with different terms) will
      send an answer to the joining peer. The joiner will set up a connection for each answer.
  (3) Once connected the leader(s) will add the peer as a joining client, and will start
      off by sending a snapshot of the current state. Once a reply from the snapshot request
      has been received the leader will request a configuration change which includes the new
      client.
      The joining client will prioritize snapshots with the latest term, and ignored old ones.
      Once the client has received a configuration where they are present and the configuration
      has been committed, they will convert to a follower and be a full member of the cluster.
      During this time, the joining client will communicate via the current p2p connections
      to set up new connections towards the other members of the cluster.
  (4) If there is a leadership change during the above process, the new leader will start over
      at (2), that is if the client has not already joined the cluster. This is why every
      client must keep track of JOIN messages.

  Removing disconnected members:

  The current plan is that each client will include the clients that it is not connected
  to in the heartbeat responses. That will make it possible for the leader to detect when
  no client is able to reach another client, and may then initiate a reconfiguration.

  The trickier problem of handling netsplits where the conference is split into segments
  is not yet solved. The current idea is to modify the voting algorithm and have vote
  requests include connected peers. Hopefully it'll be possible to find a simple way to
  simultaneously do an instant reconfiguration and leader election. This is probably
  doable because the majority log consistency constraint can be ignored. When the segment
  that has been spliced out rejoins the conference, the logs don't have to be consistent,
  it'll be possible to just do a regular join via snapshots.

  Updates:

  25-03-2017, Client IDs:

  The current implementation uses separate IDs for users and raft client, i.e. there is a 1-N mapping
  of user to raft IDs. This is because if the raft client state is lost is it no longer safe to rejoin
  the cluster using the same ID. Entries are committed based on the knowledge that clients are up to date,
  and if a client loses it's state and then reconnects using the same ID, incorrect assumptions may be
  made about what entries are actually committed.

  A planned change will consolidate the IDs to only use user IDs for all clients. This makes the conference
  implementation a lot simpler and easier to reason about. The reason this change can be made is the
  introduction of the Joiner state and messages. Built into the raft algorithm is the guarantee that if
  there exists a commit index N within the cluster, only clients that have at least N matching entries
  can ever be elected leader. Since clients that are joining the cluster always do so through a leader,
  it means that if a client reconnects, it will always receive a snapshot that restores at least N entries.
  This means that any commit index determined by a leader will stay correct, even if a client loses it's
  state and reconnects.

  One caveat is that clients that lose their state MUST rejoin the cluster through the joiner mechanism.
  If they simply rejoin as members then the above assumption does not hold and the implementation is not safe.

  The crucial bit is that reconnecting members do not vote until they have received a snapshot. It is also
  important that all snapshots that are sent contain all of the current log entries of the leader, otherwise
  reconnecting members might receive a partial snapshot were they are member, and begin voting too early.

  It is also possible that the disconnected client will be removed from the cluster before it rejoins. In
  that case the original rule of the raft algorithm applies, since if it is possible to update the
  configuration without the participation of the disconnected client, then the entries prior to the
  reconfiguration can be considered committed, even without the disconnected client.

  If the reconfiguration can not be committed due to lack of majority, the state machine will lock up until
  either the member reconnects, or some other mechanism is used to recover. The change proposed above does
  not solve this issue, but it likely does not make it more difficult to solve either.
 */

var WaitList = function () {
  function WaitList() {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, WaitList);

    this._entries = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default.a();
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(WaitList, [{
    key: 'add',
    value: function add(_ref) {
      var peerId = _ref.peerId,
          mustRejoin = _ref.mustRejoin,
          ttlMs = _ref.ttlMs;

      var endTime = Date.now() + ttlMs;

      if (this._entries.has(peerId)) {
        var entry = this._entries.get(peerId);
        endTime = Math.max(endTime, entry.endTime);
        mustRejoin = mustRejoin || entry.mustRejoin;
      }

      this._entries.set(peerId, { endTime: endTime, mustRejoin: mustRejoin });
    }
  }, {
    key: 'delete',
    value: function _delete(peerId) {
      this._entries.delete(peerId);
    }
  }, {
    key: 'deleteAll',
    value: function deleteAll(peerIds) {
      var _this = this;

      peerIds.forEach(function (peerId) {
        return _this.delete(peerId);
      });
    }
  }, {
    key: 'get',
    value: function get() {
      var _this2 = this;

      var waiting = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set___default.a();
      var deleted = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set___default.a();
      var now = Date.now();
      this._entries.forEach(function (_ref2, peerId) {
        var mustRejoin = _ref2.mustRejoin,
            endTime = _ref2.endTime;

        if (now < endTime) {
          waiting.add({ peerId: peerId, mustRejoin: mustRejoin });
        } else {
          deleted.add(peerId);
        }
      });
      deleted.forEach(function (peerId) {
        return _this2._entries.delete(peerId);
      });
      return waiting;
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._entries.clear();
    }
  }]);

  return WaitList;
}();

var TAG = 'raft';

var ELECTION_DEADLOCK_LIMIT = 3;

var Raft = function () {
  function Raft() {
    var _this3 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, Raft);

    var id = options.id,
        meshTopology = options.meshTopology,
        onMessage = options.onMessage,
        onStateChange = options.onStateChange,
        onMembersChange = options.onMembersChange,
        onLeadershipChange = options.onLeadershipChange,
        onReplicationDeadlock = options.onReplicationDeadlock;


    this._send = this._send.bind(this);
    this._onElectionTimeout = this._onElectionTimeout.bind(this);
    this._onConfigurationCommitted = this._onConfigurationCommitted.bind(this);

    this._id = __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].string(this, 'id', id);
    __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].instance(this, 'meshTopology', meshTopology, __WEBPACK_IMPORTED_MODULE_10_conference_meshTopology__["c" /* default */]);
    this._onMessage = __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optFunc(this, 'onMessage', onMessage);
    __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optFunc(this, 'onStateChange', onStateChange);
    this._onMembersChange = __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optFunc(this, 'onMembersChange', onMembersChange);
    this._onLeadershipChange = __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optFunc(this, 'onLeadershipChange', onLeadershipChange);
    this._onReplicationDeadlock = __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optFunc(this, 'onReplicationDeadlock', onReplicationDeadlock);

    this._raftState = null;
    this._electionTimeoutId = null;
    this._electionTimeoutTriggerCount = 0;
    this._waitList = new WaitList();
    this._stateMachine = new __WEBPACK_IMPORTED_MODULE_11_conference_raftStateMachine__["a" /* default */]({
      onStateChange: onStateChange,
      onConfigurationCommitted: this._onConfigurationCommitted,
      onStateOpRequest: function onStateOpRequest(request) {
        return _this3._raftState && _this3._raftState.forwardStateOpRequest(request);
      }
    });
    this._log = new __WEBPACK_IMPORTED_MODULE_7_conference_raftLog__["a" /* default */]({
      meshTopology: meshTopology,
      configuration: new __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["a" /* default */]({ ownId: id }),
      stateMachine: this._stateMachine
    });
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(Raft, [{
    key: 'toString',
    value: function toString() {
      return 'raft{id=' + this.id + ',' + this._raftState + ',' + this._log + ',' + this._stateMachine + '}';
    }
  }, {
    key: 'start',
    value: function start() {
      var initialMembers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [this.id];

      this.stop();
      this._stateMachine.start();

      var data = new __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["b" /* ConfigurationData */](new __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["c" /* Members */](initialMembers));
      this._log.configuration.set(data);

      if (this.log.configuration.hasMajority(new __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["d" /* Votes */](this._id))) {
        this._setState(new __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["a" /* LeaderState */](this._log, this._send, 1));
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].debug(TAG, this, 'starting as leader, signaling configuration commit');
        this._onConfigurationCommitted();
      } else {
        this._setState(new __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["b" /* FollowerState */](this._log, this._send));
      }
    }
  }, {
    key: 'startPassive',
    value: function startPassive() {
      this.stop();
      this._stateMachine.start();
      this._setState(new __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["c" /* JoinerState */](this._log, this._send));
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (this._raftState && this._raftState.stop) {
        this._raftState.stop();
      }
      this._stateMachine.stop();

      this._waitList.clear();

      this._log.clear();
      var data = new __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["b" /* ConfigurationData */](new __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["c" /* Members */]());
      this._log.configuration.set(data);

      this._setState(null); // Use _setState to properly trigger leadership change
      this._stopElectionTimeout();
    }
  }, {
    key: 'get',
    value: function get(key) {
      __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].string('Raft.get', 'key', key);
      return this._stateMachine.state[key];
    }
  }, {
    key: 'append',
    value: function append(key, value) {
      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref3$retryTtlMs = _ref3.retryTtlMs,
          retryTtlMs = _ref3$retryTtlMs === undefined ? 3000 : _ref3$retryTtlMs;

      __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].string('Raft.append', 'key', key);
      if (!this._raftState) {
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject(new Error('Raft is stopped'));
      }
      return this._stateMachine.requestStateOp({
        op: __WEBPACK_IMPORTED_MODULE_8_conference_raftLogEntry__["a" /* OP */].append,
        args: [key, value],
        retryTtlMs: retryTtlMs
      });
    }
  }, {
    key: 'set',
    value: function set(key, value) {
      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref4$retryTtlMs = _ref4.retryTtlMs,
          retryTtlMs = _ref4$retryTtlMs === undefined ? 3000 : _ref4$retryTtlMs;

      __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].string('Raft.set', 'key', key);
      if (!this._raftState) {
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject(new Error('Raft is stopped'));
      }
      return this._stateMachine.requestStateOp({
        op: __WEBPACK_IMPORTED_MODULE_8_conference_raftLogEntry__["a" /* OP */].set,
        args: [key, value],
        retryTtlMs: retryTtlMs
      });
    }

    // mustRejoin should be true if the peer is currently in another cluster. Otherwise
    // we will end up with inconsistencies in the raft log.

  }, {
    key: 'addPeer',
    value: function addPeer(peerId) {
      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref5$mustRejoin = _ref5.mustRejoin,
          mustRejoin = _ref5$mustRejoin === undefined ? true : _ref5$mustRejoin,
          _ref5$waitlistTtlMs = _ref5.waitlistTtlMs,
          waitlistTtlMs = _ref5$waitlistTtlMs === undefined ? 0 : _ref5$waitlistTtlMs;

      this._waitList.add({ peerId: peerId, mustRejoin: mustRejoin, ttlMs: waitlistTtlMs });
      if (this._raftState && this._raftState.addPeer) {
        this._raftState.addPeer({ peerId: peerId, mustRejoin: mustRejoin });
      }
    }
  }, {
    key: '_send',
    value: function _send(peerId, body) {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, this, 'send message to \'' + peerId + '\': ' + body);
      this._onMessage(peerId, body);
    }
  }, {
    key: '_setState',
    value: function _setState(newState) {
      var _this4 = this;

      var wasLeader = this._raftState instanceof __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["a" /* LeaderState */];
      this._raftState = newState;
      if (this._raftState instanceof __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["a" /* LeaderState */]) {
        this._stopElectionTimeout();
        this._waitList.get().forEach(function (_ref6) {
          var peerId = _ref6.peerId,
              mustRejoin = _ref6.mustRejoin;

          // Even after becoming leader we must add the peers from the waitlist, in case they never got
          // a snapshot from the previous leader.
          // This means that reconnecting clients will keep getting snapshots from new leaders until the add
          // ttl runs out, so it should not be too long.
          _this4._raftState.addPeer({ peerId: peerId, mustRejoin: mustRejoin });
        });
      } else if (this._raftState instanceof __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["c" /* JoinerState */]) {
        this._stopElectionTimeout();
      } else {
        this._resetElectionTimeout();
      }
      if (this._onLeadershipChange) {
        var isLeader = this._raftState instanceof __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["a" /* LeaderState */];
        if (wasLeader !== isLeader) {
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].info(TAG, this, 'changed leadership status');
          this._onLeadershipChange(isLeader);
        }
      }
    }
  }, {
    key: 'handleMessage',
    value: function handleMessage(peerId, body) {
      if (!this._raftState) {
        return;
      }
      var message = __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["a" /* default */].parse(body);
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, this, 'receive message from \'' + peerId + '\': ' + message);
      if (message.term && message.term < this._raftState._term) {
        // Old responses are always silently ignored
        // Old requests are always rejected, but send reply so the peer can be updated
        if (message.isRequest) {
          this._send(peerId, message.response({ term: this._raftState._term }));
        }
      } else {
        var newState;
        switch (message.constructor) {
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["b" /* AppendEntriesRequest */]:
            newState = this._raftState.handleAppendEntriesRequest(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["c" /* AppendEntriesResponse */]:
            newState = this._raftState.handleAppendEntriesResponse(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["d" /* RequestVoteRequest */]:
            newState = this._raftState.handleRequestVoteRequest(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["e" /* RequestVoteResponse */]:
            newState = this._raftState.handleRequestVoteResponse(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["f" /* PreVoteRequest */]:
            newState = this._raftState.handlePreVoteRequest(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["g" /* PreVoteResponse */]:
            newState = this._raftState.handlePreVoteResponse(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["h" /* SnapshotRequest */]:
            newState = this._raftState.handleSnapshotRequest(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["i" /* SnapshotResponse */]:
            newState = this._raftState.handleSnapshotResponse(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["j" /* StateOpRequest */]:
            newState = this._raftState.handleStateOpRequest(peerId, message);
            break;
          case __WEBPACK_IMPORTED_MODULE_13_conference_raftMessages__["k" /* StateOpResponse */]:
            // StateOp responses are handled by the state machine, since the state
            // doesn't have any use for it anyway, and the state machine uses
            // it for quicker feedback.
            this._stateMachine.handleStateOpResponse(peerId, message);
            break;
        }
        // _raftState is not set we were stopped in the handler
        if (newState && this._raftState) {
          this._setState(newState);
        }
      }
    }
  }, {
    key: '_resetElectionTimeout',
    value: function _resetElectionTimeout() {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, this, 'election timer restarted');
      if (this._electionTimeoutId) {
        this._electionTimeoutTriggerCount = 0;
        clearTimeout(this._electionTimeoutId);
      }
      var timeoutMs = __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["d" /* EXPECTED_RTT_MS */] * 8 + __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["d" /* EXPECTED_RTT_MS */] * 12 * Math.random();
      this._electionTimeoutId = setTimeout(this._onElectionTimeout, timeoutMs);
    }
  }, {
    key: '_stopElectionTimeout',
    value: function _stopElectionTimeout() {
      if (this._electionTimeoutId) {
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].verbose(TAG, this, 'election timer stopped');
        clearTimeout(this._electionTimeoutId);
        this._electionTimeoutId = null;
      }
    }
  }, {
    key: '_onElectionTimeout',
    value: function _onElectionTimeout() {
      this._electionTimeoutId = null;
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].info(TAG, this, 'election timeout');
      // We timed out waiting for heartbeat, start campaigning for leadership of next term
      if (this.log.configuration.hasMajority(new __WEBPACK_IMPORTED_MODULE_9_conference_raftConfiguration__["d" /* Votes */](this._id))) {
        this._setState(this._raftState.toLeader(this._raftState._term + 1));
      } else {
        this._electionTimeoutTriggerCount += 1;
        if (this._electionTimeoutTriggerCount > ELECTION_DEADLOCK_LIMIT) {
          this._onReplicationDeadlock();
        } else {
          this._setState(this._raftState.toCandidate(this._raftState._term + 1, false));
        }
      }
    }
  }, {
    key: '_onConfigurationCommitted',
    value: function _onConfigurationCommitted() {
      var _this5 = this;

      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].debug(TAG, this, 'committed new configuration');

      this._waitList.deleteAll(this.log.configuration.members);
      if (this._onMembersChange) {
        __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject().catch(function () {
          _this5._onMembersChange(_this5.log.configuration.members);
        });
      }
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'log',
    get: function get() {
      return this._log;
    }
  }, {
    key: 'isLeader',
    get: function get() {
      return this._raftState instanceof __WEBPACK_IMPORTED_MODULE_12_conference_raftState__["a" /* LeaderState */];
    }
  }, {
    key: 'members',
    get: function get() {
      return this._log.configuration.members;
    }
  }, {
    key: 'term',
    get: function get() {
      if (!this._raftState) {
        return 0;
      }
      return this._raftState._term;
    }
  }]);

  return Raft;
}();

/* harmony default export */ __webpack_exports__["a"] = (Raft);

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_utils__ = __webpack_require__(13);












/**
 * Emitted when any account data entry changes.
 *
 * @event AccountData#update
 * @param {Object} change
 * @param {string} change.key - The key whose value was changed.
 * @param {JsonTypes} change.value - The new value that the key is now associated with.
 * @param {JsonTypes} change.oldValue - The value that the key was previously associated with, if any.
 */

/**
 * Emitted when the value associated with the given key is changed.
 *
 * @event AccountData#update:&lt;key&gt;
 * @param {JsonTypes} value - The new value that the key is now associated with.
 * @param {JsonTypes} oldValue - The value that the key was previously associated with, if any.
 */

/**
 * Represents account data that is persistent and unique to each client.
 * It is synchronized between all clients of the same user, and can be
 * used for e.g. settings or unread notifications.
 *
 * Account data can be scoped either to the user or to a room. It is accessed
 * through {@link Client.accountData} and {@link Room.accountData}.
 *
 * Each account data is a key-value pair store that emits events when values are changed.
 *
 * @abstract
 * @class AccountData
 * @extends EventEmitter
 */

var AccountData = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(AccountData, _EmitterMixin);

  function AccountData(priv, setData) {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, AccountData);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AccountData.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(AccountData)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["assertPriv"])('AccountData', priv);
    _this._values = {};
    _this._setData = setData;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(AccountData, [{
    key: 'toString',
    value: function toString() {
      return 'accountData{keys=' + this.keys + '}';
    }

    /**
     * A list of all keys that have been set.
     *
     * @readonly
     * @member {string[]} AccountData#keys
     */

  }, {
    key: 'has',


    /**
     * Returns true if the key has been set.
     *
     * @param {string} key - The key to test if it has been set.
     * @returns {boolean} - True if the key has been set, false otherwise.
     */
    value: function has(key) {
      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].stringOrEmpty('AccountData.has', 'key', key);
      return key in this._values;
    }

    /**
     * Gets the value for the corresponding key.
     *
     * @param {string} key - The key whose associated value should be returned.
     * @returns {JsonTypes} - The value associated with the key.
     */

  }, {
    key: 'get',
    value: function get(key) {
      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].stringOrEmpty('AccountData.get', 'key', key);
      return this._values[key];
    }

    // eslint-disable-next-line jsdoc/require-description-complete-sentence
    /**
     * Sets the value that a key should be associated with. This will override any
     * existing association with the key.
     *
     * NOTE: It is best to avoid relying on the returned promise to modify application state,
     * e.g. UI updates, as that will lead to race conditions and undefined behaviour.
     * It is better to use the returned promise for feedback that the state was changed
     * was successfully, and tie application state changes an 'update' event handler.
     * This is due to the fact that state changes are received via the event stream, but
     * the returned promise is resolved when the request is returned, and those two events
     * can happen in any order.
     * ##### Errors:
     * - {@link GuestAccessError} - Guests are not allowed to set account data.
     * - {@link AuthenticationError} - The client must be authenticated to use this method.
     *
     * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
     *
     * @param {string} key - The key that should be associated with the value.
     * @param {JsonTypes} value - The value that should be associated with the key.
     * @returns {Promise<AccountData, CctError>} - The account data.
     */

  }, {
    key: 'set',
    value: function set(key, value) {
      var _this2 = this;

      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].stringOrEmpty('AccountData.set', 'key', key);
      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].count('AccountData.set', 2, arguments.length);
      if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["isObject"])(value)) {
        value = { __value__: value };
      }
      return this._setData(key, value).then(function () {
        return _this2;
      });
    }
  }, {
    key: '_set',
    value: function _set(key, value) {
      if (value.__value__) {
        value = value.__value__;
      }
      var oldValue = this._values[key];
      this._values[key] = value;
      this._emit('update:' + key, value, oldValue);
      this._emit('update', {
        key: key,
        value: value,
        oldValue: oldValue
      });
    }
  }, {
    key: '_clear',
    value: function _clear() {
      this._values = {};
    }
  }, {
    key: 'keys',
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(this._values);
    }
  }]);

  return AccountData;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_emitter__["a" /* default */])(null));

/* harmony default export */ __webpack_exports__["a"] = (AccountData);


AccountData.tag = 'account-data';

/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = PowerLevelsEdit;
/* harmony export (immutable) */ __webpack_exports__["b"] = PowerLevelsReader;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_entries__ = __webpack_require__(234);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_entries___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_entries__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_matrix_ids__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_matrix_userRegistry__ = __webpack_require__(197);











/**
 * A class which provides a fluent API for modifying a power levels object.
 * It cannot be instantiated directly and can only be created through the
 * static factory methods as well as {@link Room#editPowerLevels}.
 *
 * Many methods are verbs, but they simply set the power level required to
 * execute the matching action, with the exception of {@link PowerLevelsEdit#commit}.
 *
 * No actual action is taken until the commit method is called. The commit
 * method is only available if the instance was obtained from a
 * {@link Room#editPowerLevels} call. It is also possible to create an
 * instance with one of the static factory methods and then pass the instance
 * to setPowerLevels.
 *
 * @example
 * room.editPowerLevels()
 *     .kick(60)
 *     .addState(0)
 *     .user(promotedUser, 60)
 *     .event('my.custom.event', 20)
 *     .commit()
 *     .then(function () {
 *         console.log("Power levels updated!");
 *     });
 *
 * @example
 * room.setPowerLevels(PowerLevelsEdit.fromDefault(client.user))
 *     .then(function () {
 *         console.log("Power levels reset");
 *     });
 *
 * @class PowerLevelsEdit
 * @abstract
 */

function PowerLevelsEdit(priv, powerLevels, options) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["assertPriv"])('PowerLevelsEdit', priv);
  __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].optOptions('PowerLevelsReader', 'options', options).optString('serverName');

  powerLevels.ban = powerLevels.kick;
  this._powerLevels = JSON.parse(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(powerLevels));
  this._serverName = options && options.serverName;
}

PowerLevelsEdit.prototype = {
  constructor: PowerLevelsEdit,
  toString: function toString() {
    return 'powerLevelsEdit' + __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(this._powerLevels);
  },
  toJSON: function toJSON() {
    if (this._serverName) {
      return this.toRawForServer(this._serverName);
    } else {
      throw new TypeError("Can't serialize power levels without a server name set");
    }
  },

  toRawForServer: function toRawForServer(serverName) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('PowerLevelsEdit.toRawForServer', 'serverName', serverName);
    var powerLevels = JSON.parse(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(this._powerLevels));
    powerLevels.users = convertUsersToMatrix(powerLevels.users, serverName);
    return powerLevels;
  },


  /**
   * Commits the current state of the power levels edit by updating the
   * power levels of the room to the current values. This method is only
   * present if the instance was obtained via {@link Room#editPowerLevels}.
   *
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function PowerLevelsEdit#commit
   * @returns {Promise<Room, CctError>}
   */

  /**
   * Sets the power level of a user.
   *
   * @param {UserId|User} user - The userId or {@link User} instance.
   * @param {number} level - The new power level of the user.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  user: function user(_user, level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.user', 2, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.user', 'level', level);
    var matrixId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_matrix_userRegistry__["a" /* toUserId */])('PowerLevelsEdit.user', _user, this._serverName);
    var userId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_matrix_ids__["a" /* parseIdForServer */])('PowerLevelsEdit.user', matrixId, this._serverName || '-', 'user');
    this._powerLevels.users[userId] = level;
    return this;
  },

  /**
   * Sets the power level required to send an event of a specific
   * type or set a state of the same type.
   *
   * @param {EventType} eventType - The type of the event.
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  event: function event(eventType, level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.event', 2, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('PowerLevelsEdit.event', 'eventType', eventType);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.event', 'level', level);
    this._powerLevels.events[eventType] = level;
    return this;
  },

  /**
   * Sets the power level required to change the name of a room.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  setName: function setName(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.setName', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.setName', 'level', level);
    return this.event('m.room.name', level);
  },

  /**
   * Sets the power level required to change the topic of a room.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  setTopic: function setTopic(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.setTopic', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.setTopic', 'level', level);
    return this.event('m.room.topic', level);
  },

  /**
   * Sets the power level required to change the type of a room.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  setType: function setType(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.setType', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.setType', 'level', level);
    return this.event('com.ericsson.room.type', level);
  },

  /**
   * Sets the power level required to change the power levels of a room.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  setPowerLevels: function setPowerLevels(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.setPowerLevels', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.setPowerLevels', 'level', level);
    return this.event('m.room.power_levels', level);
  },

  /**
   * Sets the power level required to kick a user from the room.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  kick: function kick(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.kick', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.kick', 'level', level);
    this._powerLevels.kick = level;
    this._powerLevels.ban = level;
    return this;
  },

  /**
   * Sets the power level required to invite a user to the room.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  invite: function invite(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.invite', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.invite', 'level', level);
    this._powerLevels.invite = level;
    return this;
  },

  /**
   * Sets the power level required to redact and event in the room.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  redact: function redact(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.redact', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.redact', 'level', level);
    this._powerLevels.redact = level;
    return this;
  },

  /**
   * Sets the default power level for users in the room. If a specific
   * power level hasn't been set for a user this value will be used.
   *
   * @param {number} level - The new default power level.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  userDefault: function userDefault(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.userDefault', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.userDefault', 'level', level);
    this._powerLevels.users_default = level;
    return this;
  },

  /**
   * Sets the default power level for all event types in the room.
   * If a specific power level hasn't been set for an event type
   * this value will be used.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  eventDefault: function eventDefault(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.eventDefault', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.eventDefault', 'level', level);
    this._powerLevels.events_default = level;
    return this;
  },

  /**
   * Sets the power level required to add a new state to the room.
   *
   * @param {number} level - The new power level requirement.
   * @returns {PowerLevelsEdit} Returns itself to allow chaining.
   */
  addState: function addState(level) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('PowerLevelsEdit.addState', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].number('PowerLevelsEdit.addState', 'level', level);
    this._powerLevels.state_default = level;
    return this;
  }
};

/**
 * Creates a new {@link PowerLevelsEdit} object with the default
 * power levels.
 *
 * The creator of the room can optionally be specified, in which case
 * the creators power level will be set to the default power level
 * of the creator.
 *
 * @param {(UserId|User)?} [creator] - An optional creator of the room.
 * @param {Object} [options] - An options object.
 * @param {string} [options.serverName] - The server name that the IDs in the edit will be relative to.
 * @returns {PowerLevelsEdit} A new power levels edit instance.
 */
PowerLevelsEdit.fromDefault = function (creator, options) {
  var edit = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["priv"])(PowerLevelsEdit, PowerLevelsEdit._DEFAULT_POWER_LEVELS, options);
  if (creator) {
    edit.user(creator, PowerLevelsEdit._DEFAULT_CREATOR_LEVEL);
  }
  return edit;
};

/**
 * Creates a new {@link PowerLevelsEdit} object with all power levels set to 0.
 *
 * @param {Object} [options] - An options object.
 * @param {string} [options.serverName] - The server name that the IDs in the edit will be relative to.
 * @returns {PowerLevelsEdit} A new power levels edit instance.
 */
PowerLevelsEdit.fromZero = function (options) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["priv"])(PowerLevelsEdit, PowerLevelsEdit._ZERO_POWER_LEVELS, options);
};

PowerLevelsEdit._DEFAULT_CREATOR_LEVEL = 100;

PowerLevelsEdit._DEFAULT_POWER_LEVELS = {
  users: {},
  users_default: 0,
  events: {
    'm.room.name': 50,
    'm.room.power_levels': 100,
    'm.room.history_visibility': 100,
    'm.room.canonical_alias': 50,
    'm.room.avatar': 50
  },
  events_default: 0,
  state_default: 50,
  kick: 50,
  redact: 50,
  invite: 0
};

PowerLevelsEdit._ZERO_POWER_LEVELS = {
  users: {},
  users_default: 0,
  events: {},
  events_default: 0,
  state_default: 0,
  kick: 0,
  redact: 0,
  invite: 0
};

function convertUsersToServer(users, serverName) {
  if (!users) {
    return users;
  }
  var userLevels = {};
  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_entries___default()(users).forEach(function (_ref) {
    var _ref2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_ref, 2),
        matrixId = _ref2[0],
        level = _ref2[1];

    var userId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_matrix_ids__["a" /* parseIdForServer */])('PowerLevels rawToUsers', matrixId, serverName || '-', 'user');
    userLevels[userId] = level;
  });
  return userLevels;
}

function convertUsersToMatrix(users, serverName) {
  if (!users) {
    return users;
  }
  var matrixUserLevels = {};
  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_entries___default()(users).forEach(function (_ref3) {
    var _ref4 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_ref3, 2),
        userId = _ref4[0],
        level = _ref4[1];

    var matrixId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_matrix_ids__["b" /* toMatrixIdForServer */])('PowerLevels usersToRaw', userId, serverName, 'user');
    matrixUserLevels[matrixId] = level;
  });
  return matrixUserLevels;
}

/**
 * A class which provides convenience accessors for the internal representation
 * of a power levels structure.
 *
 * This will usually be accessed through {@link Room#powerLevels}, but
 * can also be instantiated with {@link PowerLevelsReader.fromRaw}.
 *
 * @class PowerLevelsReader
 * @abstract
 */

function PowerLevelsReader(priv, powerLevels, options) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["assertPriv"])('PowerLevelsReader', priv);
  __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].options('PowerLevelsReader', 'powerLevels', powerLevels).object('users').object('events').number('kick').number('invite').number('users_default').number('events_default').number('state_default').number('redact');
  __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].optOptions('PowerLevelsReader', 'options', options).optString('serverName');

  powerLevels.ban = powerLevels.kick;
  this._powerLevels = powerLevels;
  this._serverName = options && options.serverName;
}

PowerLevelsReader.prototype = {
  constructor: PowerLevelsReader,
  toString: function toString() {
    return 'powerLevelsReader' + __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(this._powerLevels);
  },
  toJSON: function toJSON() {
    if (this._serverName) {
      return this.toRawForServer(this._serverName);
    } else {
      throw new TypeError("Can't serialize power levels without a server name set");
    }
  },

  toRawForServer: function toRawForServer(serverName) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('PowerLevelsEdit.toRawForServer', 'serverName', serverName);
    var powerLevels = JSON.parse(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(this._powerLevels));
    powerLevels.users = convertUsersToMatrix(powerLevels.users, serverName);
    return powerLevels;
  },


  /**
   * An object where the key is a userId and the value is that user's power level.
   *
   * @readonly
   * @member {object<UserId,number>} PowerLevelsReader#users
   */
  get users() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["shallowCopy"])(this._powerLevels.users) || {};
  },
  /**
   * An object where the key is an event type and the value is that event type's required power level.
   *
   * @readonly
   * @member {object<EventType,number>} PowerLevelsReader#events
   */
  get events() {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["shallowCopy"])(this._powerLevels.events) || {};
  },
  /**
   * Looks up the power level required for a specific event.
   *
   * @param {EventType} eventType - The event type to look up the required power level for.
   * @returns {number} The power level required for the given event type.
   */
  event: function event(eventType) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('PowerLevelsReader.event', 'eventType', eventType);
    if (this._powerLevels.events.hasOwnProperty(eventType)) {
      return this._powerLevels.events[eventType];
    } else {
      return this._powerLevels.events_default;
    }
  },

  /**
   * Looks up the effective power level of a user.
   *
   * @param {UserId|User} user - The user to look up the power level for.
   * @returns {number} The effective power level of the user.
   */
  user: function user(_user2) {
    var matrixId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_matrix_userRegistry__["a" /* toUserId */])('PowerLevelsReader.user', _user2, this._serverName);
    var userId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_matrix_ids__["a" /* parseIdForServer */])('PowerLevelsReader.user', matrixId, this._serverName || '-', 'user');
    if (this._powerLevels.users.hasOwnProperty(userId)) {
      return this._powerLevels.users[userId];
    } else {
      return this._powerLevels.users_default;
    }
  },

  /**
   * The power level required to set the name of the room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#setName
   */
  get setName() {
    return this._powerLevels.events['m.room.name'];
  },
  /**
   * The power level required to set the topic of the room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#setTopic
   */
  get setTopic() {
    return this._powerLevels.events['m.room.topic'];
  },
  /**
   * The power level required to set the type of the room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#setType
   */
  get setType() {
    return this._powerLevels.events['com.ericsson.room.type'];
  },
  /**
   * The power level required to set the power levels in a room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#setPowerLevels
   */
  get setPowerLevels() {
    return this._powerLevels.events['m.room.power_levels'];
  },
  /**
   * The power level required to kick a user form the room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#kick
   */
  get kick() {
    return this._powerLevels.kick;
  },
  /**
   * The power level required to invite a user to the room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#invite
   */
  get invite() {
    return this._powerLevels.invite;
  },
  /**
   * The power level required to redact an event from the room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#redact
   */
  get redact() {
    return this._powerLevels.redact;
  },
  /**
   * The default power level for users in the room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#userDefault
   */
  get userDefault() {
    return this._powerLevels.users_default;
  },
  /**
   * The default power level for events in the room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#eventDefault
   */
  get eventDefault() {
    return this._powerLevels.events_default;
  },
  /**
   * The power level required to add a new state to a room.
   *
   * @readonly
   * @member {number} PowerLevelsReader#addState
   */
  get addState() {
    return this._powerLevels.state_default;
  }
};

/**
 * Creates a new {@link PowerLevelsReader} from a raw power levels object.
 *
 * @param {Object} object - A plain object with power levels.
 * @param {Object} [options] - An options object.
 * @param {string} [options.serverName] - The server name that the IDs in the reader will be relative to.
 * @returns {PowerLevelsReader} A new power levels reader instance.
 */
PowerLevelsReader.fromRaw = function (object, options) {
  var powerLevels = JSON.parse(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(object));
  powerLevels.users = convertUsersToServer(powerLevels.users, options && options.serverName);
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["priv"])(PowerLevelsReader, powerLevels, options);
};

/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Room;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_request__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_queue__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_errors__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_matrix_accountData__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_matrix_resources__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_matrix_roomState__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_matrix_user__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_matrix_ids__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_matrix_errors__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_matrix_powerLevels__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_matrix_userRegistry__ = __webpack_require__(197);






















var membershipNameMap = {
  join: 'member',
  kick: 'kicked',
  ban: 'kicked',
  invite: 'invited',
  leave: 'left'
};

var userCollectionNameMap = {
  invited: 'invited',
  member: 'members'
};

/**
 * Represents a room.
 *
 * @abstract
 * @class Room
 * @extends EventEmitter
 */

function Room(privToken, config, dependencies) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["assertPriv"])('Room', privToken);
  var self = this;

  var ownUser = dependencies.ownUser;
  var delegate = dependencies.delegate;
  var baseRequest = dependencies.baseRequest;
  var userRegistry = dependencies.userRegistry;
  var callRegistry = dependencies.callRegistry;
  var imageResourceFactory = dependencies.imageResourceFactory;

  if (!(ownUser instanceof __WEBPACK_IMPORTED_MODULE_13_matrix_user__["a" /* default */])) {
    throw new TypeError('room has to be passed a user');
  }
  if (!baseRequest) {
    throw new TypeError('room has to be passed a base request object');
  }

  var matrixId = config.matrixId;
  var id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14_matrix_ids__["a" /* parseIdForServer */])('Room constructor', config.matrixId, dependencies.serverName, 'room');
  var roomType = null;
  var creator = null;
  var creationContent = null;
  var name = null;
  var topic = null;
  var avatar = null;
  var historyVisibility = null;
  var alias = null;
  var membership = null;
  var joinRule = null;
  var guestAccessRule = null;
  var invitedBy = null;
  var typingUsers = [];
  var memberships = {};
  var members = [];
  var memberCount = NaN;
  var invited = [];
  var events = [];
  var eventsStart = null;
  var states = {};
  var setTypingRequest = null;
  var setTypingEndTime = 0;
  var loadQueue = new __WEBPACK_IMPORTED_MODULE_7_common_queue__["a" /* default */]();
  var queries = [];
  var powerLevel = 0;
  var powerLevelsReader = null;
  var waitForJoined = null;
  var awaitingJoin = null;
  var replyEventSnatchers = null;

  this._setAccountData = this._setAccountData.bind(this);
  this._accountData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_10_matrix_accountData__["a" /* default */], this._setAccountData);
  var roomRequest = baseRequest.client(new __WEBPACK_IMPORTED_MODULE_6_common_request__["a" /* SerializedJsonRetryClient */]()).params('roomId', matrixId);
  var request = roomRequest.path('rooms', '{roomId}');
  request.send = request.path('send');
  request.state = request.path('state');
  request.invite = request.path('invite');
  request.join = request.path('join');
  request.kick = request.path('kick');
  request.leave = request.path('leave');
  request.typing = request.path('typing', '{userId}');
  request.initialSync = request.path('initialSync');
  request.setAccountData = roomRequest.path('user', '{userId}', 'rooms', '{roomId}', 'account_data');
  request.events = request.client(new __WEBPACK_IMPORTED_MODULE_6_common_request__["b" /* JsonRetryClient */]()).errorHandler(__WEBPACK_IMPORTED_MODULE_15_matrix_errors__["a" /* parseSynapseErrorResponse */]).path('messages').query('dir', 'b');

  this._request = request;

  function addPublicInfo(info) {
    if (membership === 'member') {
      return;
    }
    name = info.name;
    self._emit('name', name);
    topic = info.topic;
    self._emit('topic', topic);
    alias = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14_matrix_ids__["a" /* parseIdForServer */])('Room.addPublicInfo', info.canonical_alias, dependencies.serverName, 'alias');
    self._emit('alias', alias);
    memberCount = info.num_joined_members;
    queries = queries.filter(function (fn) {
      return !fn();
    });
  }

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["hiddenProp"])(this, '_addPublicInfo', addPublicInfo);

  var eventHandlers = {
    'com.ericsson.room.type': function comEricssonRoomType(simple) {
      simple.content = simple.content.type;
      return simple;
    },
    'm.room.topic': function mRoomTopic(simple) {
      simple.content = simple.content.topic;
      return simple;
    },
    'm.room.avatar': function mRoomAvatar(simple) {
      var url = simple.content.url;
      if (url) {
        simple.content = imageResourceFactory(url);
      } else {
        simple.content = null;
      }
      return simple;
    },
    'm.room.history_visibility': function mRoomHistory_visibility(simple) {
      simple.content = simple.content.history_visibility;
      return simple;
    },
    'm.room.name': function mRoomName(simple) {
      simple.content = simple.content.name;
      return simple;
    },
    'm.room.canonical_alias': function mRoomCanonical_alias(simple) {
      simple.content = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14_matrix_ids__["a" /* parseIdForServer */])('Room.eventHandler', simple.content.alias, dependencies.serverName, 'alias');
      return simple;
    },
    'm.room.member': function mRoomMember(simple, event) {
      var name = event.content.displayname || null;
      var avatarUrl = event.content.avatar_url || null;
      var membership = event.content.membership;

      simple.content = {
        user: userRegistry.getUser(event.state_key),
        name: name,
        avatarUrl: avatarUrl,
        membership: membershipNameMap[membership]
      };

      var prev = event.unsigned && event.unsigned.prev_content;
      if (prev) {
        var oldContent = simple.oldContent = {};
        oldContent.name = prev.displayname || null;
        oldContent.avatarUrl = prev.avatar_url || null;
        oldContent.membership = membershipNameMap[prev.membership] || null;
      }
      return simple;
    }
  };

  function toSimpleEvent(event) {
    var id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14_matrix_ids__["a" /* parseIdForServer */])('event conversion', event.event_id, dependencies.serverName, 'event');
    var simple = {
      id: id,
      content: event.content,
      type: event.type,
      isPastEvent: event.isPastEvent,
      sender: userRegistry.getUser(event.sender),
      timestamp: event.origin_server_ts
    };
    simple.isOwnEvent = simple.sender === ownUser;
    if ('state_key' in event) {
      if (event.state_key !== '') {
        simple.stateKey = event.state_key;
      } else {
        simple.stateKey = null;
      }
      simple.isStateChange = true;
    } else {
      simple.isStateChange = false;
    }
    if (simple.content && simple.content.__value__) {
      simple.content = simple.content.__value__;
    }
    if (event.unsigned && event.unsigned.prev_content) {
      simple.oldContent = event.unsigned.prev_content;
      if (simple.oldContent.__value__) {
        simple.oldContent = simple.oldContent.__value__;
      }
    }
    simple.room = self;
    var handler = eventHandlers[event.type];
    if (handler) {
      simple = handler(simple, event);
    }
    if (true) {
      callRegistry._handleEvent(simple);
    }
    return simple;
  }

  var overrideEventHandlers = {};

  function processEvent(event) {
    var overrideEventHandler = overrideEventHandlers[event.type];
    if (overrideEventHandler) {
      overrideEventHandler(event);
      return;
    }

    if (replyEventSnatchers && event.type.slice(-6) === '.reply') {
      var eventId = event.content.eventId;
      var deferred = replyEventSnatchers.get(eventId);
      if (deferred) {
        if (deferred.senderId !== event.sender) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error('room', 'reply with invalid sender: \'' + event.sender + '\', expected \'' + deferred.senderId + '\'');
        } else if (deferred.eventType !== event.type) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error('room', 'reply with invalid type: \'' + event.type + '\', expected \'' + deferred.eventType + '\'');
        } else {
          deferred.resolve(event.content);
          replyEventSnatchers.delete(eventId);
        }
      }
      return;
    }
    var simple = toSimpleEvent(event);
    if (simple) {
      if (events[simple.id]) {
        var index = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["find"])(events, function (event) {
          return event.id === simple.id;
        });
        if (index !== null) {
          events[index] = simple;
        } else {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error('room', 'failed to find existing event with id match:', simple);
        }
      } else {
        events.unshift(simple);
        events[simple.id] = simple;
      }
      self._emit('event:' + simple.type, simple);
      self._emit('event', simple);
      self._emit('events', self);
    }
    return simple;
  }

  this._processEphemeralEvent = function (event) {
    if (event.type === 'm.typing') {
      typingUsers = event.content.user_ids.map(function (userId) {
        return userRegistry.getUser(userId);
      });
      self._emit('typing');
    }
  };

  var stateHandlers = {
    'com.ericsson.room.type': function comEricssonRoomType(event) {
      if (roomType !== event.content.type) {
        roomType = event.content.type;
        self._emit('type', roomType);
      }
    },
    'm.room.create': function mRoomCreate(event, isFromTimeline) {
      if (isFromTimeline) {
        eventsStart = null;
      }
      if (event.content.cctRoomType) {
        roomType = event.content.cctRoomType;
        self._emit('type', roomType);
      }
      creator = userRegistry.getUser(event.content.creator);
      if ('c3Content' in event.content) {
        // backwards compatability
        creationContent = event.content.c3Content;
      } else {
        creationContent = event.content;
      }
      self._emit('creator', creator);
      self._emit('creationContent', creationContent);
    },
    'm.room.topic': function mRoomTopic(event) {
      topic = event.content.topic;
      self._emit('topic', topic);
    },
    'm.room.avatar': function mRoomAvatar(event) {
      var url = event.content.url;
      if (url) {
        avatar = imageResourceFactory(url);
      } else {
        avatar = null;
      }
      self._emit('avatar', avatar);
    },
    'm.room.history_visibility': function mRoomHistory_visibility(event) {
      historyVisibility = event.content.history_visibility;
      self._emit('historyVisibility', historyVisibility);
    },
    'm.room.name': function mRoomName(event) {
      name = event.content.name;
      self._emit('name', name);
    },
    'm.room.canonical_alias': function mRoomCanonical_alias(event) {
      alias = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14_matrix_ids__["a" /* parseIdForServer */])('Room.stateHandler', event.content.alias, dependencies.serverName, 'alias');
      self._emit('alias', alias);
    },
    'm.room.power_levels': function mRoomPower_levels(event) {
      var powerLevels = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["shallowCopy"])(event.content);
      ['users_default', 'events', 'events_default', 'state_default', 'kick', 'redact', 'invite'].forEach(function (key) {
        if (!(key in powerLevels)) {
          powerLevels[key] = __WEBPACK_IMPORTED_MODULE_16_matrix_powerLevels__["a" /* PowerLevelsEdit */]._DEFAULT_POWER_LEVELS[key];
        }
      });
      if (!('users' in powerLevels)) {
        powerLevels.users = {};
      }
      if (!('events' in powerLevels)) {
        powerLevels.events = {};
      }
      powerLevelsReader = __WEBPACK_IMPORTED_MODULE_16_matrix_powerLevels__["b" /* PowerLevelsReader */].fromRaw(powerLevels, { serverName: dependencies.serverName });
      var newPowerLevel = null;
      var users = powerLevels.users;
      if (users && ownUser._matrixId in users) {
        newPowerLevel = users[ownUser._matrixId];
      } else {
        newPowerLevel = powerLevels.user_default || 0;
      }
      if (powerLevel !== newPowerLevel) {
        powerLevel = newPowerLevel;
        self._emit('powerLevel', powerLevel);
      }
      self._emit('powerLevels', powerLevelsReader);
    },
    'm.room.join_rules': function mRoomJoin_rules(simple) {
      var oldJoinRule = joinRule;
      joinRule = simple.content.join_rule;
      if (joinRule === 'public') {
        joinRule = 'open';
      }
      if (oldJoinRule !== joinRule) {
        self._emit('joinRule', joinRule, oldJoinRule);
      }
    },
    'm.room.guest_access': function mRoomGuest_access(simple) {
      var oldGuestAccessRule = guestAccessRule;
      guestAccessRule = simple.content.guest_access;
      if (guestAccessRule === 'can_join') {
        guestAccessRule = 'open';
      } else if (guestAccessRule === 'forbidden') {
        guestAccessRule = 'closed';
      }
      if (oldGuestAccessRule !== guestAccessRule) {
        self._emit('guestAccessRule', guestAccessRule, oldGuestAccessRule);
      }
    },
    'm.room.member': function mRoomMember(event) {
      var user = userRegistry.getUser(event.state_key);
      var changedBy = userRegistry.getUser(event.sender);
      var content = event.content;

      if (content.membership === 'join') {
        user._membershipEventUpdate(event);
      }
      changeMembership(content.membership, user, changedBy);
    }
  };

  function processState(event, isFromTimeline) {
    var state = states[event.type] = states[event.type] || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_12_matrix_roomState__["a" /* default */], event.type, self, setState.bind(self, event.type));
    state._set(event.state_key, event.content);
    self._emit('state:' + event.type, state);
    self._emit('state', state);

    var handler = stateHandlers[event.type];
    if (handler) {
      handler(event, isFromTimeline);
    }
  }

  this._logEvent = function (type, event) {
    var category = event.sender === ownUser._matrixId ? 'own-events' : 'events';
    __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].verbose(category, 'got ' + type + ' event: ' + event.type, event);
  };

  this._handleRoomSync = function (roomData, membership, isFirstSync) {
    var i;

    if (membership === 'invite') {
      var inviteState = roomData.invite_state.events;
      for (i in inviteState) {
        this._logEvent('invite state', inviteState[i]);
        processState(inviteState[i]);
      }
      this._setOwnMembership(membership);
      eventsStart = null;
    } else if (membership === 'join') {
      var transitionedToJoin = this._setOwnMembership(membership);
      if (transitionedToJoin) {
        isFirstSync = true;
      }
      var stateEvents = roomData.state.events;
      var accountDataEvents = roomData.account_data.events;
      var ephemeralEvents = roomData.ephemeral && roomData.ephemeral.events;
      var timelineEvents = roomData.timeline.events;
      var timelineIsLimited = roomData.timeline.limited;
      var prevToken = roomData.timeline.prev_batch;

      if (!eventsStart && timelineIsLimited) {
        eventsStart = prevToken;
      }
      for (i in ephemeralEvents) {
        this._logEvent('ephemeral', ephemeralEvents[i]);
        this._processEphemeralEvent(ephemeralEvents[i]);
      }
      for (i in accountDataEvents) {
        var accountDataEvent = accountDataEvents[i];
        this._logEvent('account data', accountDataEvent);
        this._accountData._set(accountDataEvent.type, accountDataEvent.content);
      }
      for (i in stateEvents) {
        this._logEvent('state', stateEvents[i]);
        processState(stateEvents[i]);
      }
      for (i in timelineEvents) {
        var event = timelineEvents[i];
        event.isPastEvent = !!isFirstSync;
        this._logEvent('timeline', event);
        var roomEvent = processEvent(event);
        if ('state_key' in event) {
          processState(event, true /* isFromTimeline */);
        }
        if (roomEvent) {
          delegate._onRoomEvent(roomEvent);
        }
      }
      if (waitForJoined) {
        waitForJoined.resolve(this);
        waitForJoined = null;
      }
    } else if (membership === 'leave') {
      this._close();
      var membershipEvents = roomData.timeline.events.filter(function (event) {
        return event.state_key === ownUser._matrixId;
      }).slice(-1);
      if (membershipEvents.length) {
        var membershipEvent = membershipEvents[0];
        this._logEvent('leave event', membershipEvent);
        var leaveMembership = membershipEvent.content.membership;
        if (leaveMembership === 'leave' && membershipEvent.sender !== ownUser._matrixId) {
          leaveMembership = 'kick';
        }
        this._setOwnMembership(leaveMembership);
      }
    }
    queries = queries.filter(function (fn) {
      return !fn();
    });
  };

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["hiddenProp"])(this, '_close', function () {
    callRegistry.closeCallsInRoom(this);
    var conference = callRegistry.getConferenceInRoom(this);
    if (conference) {
      conference.close();
    }
    roomType = null;
    creator = null;
    creationContent = null;
    name = null;
    topic = null;
    avatar = null;
    historyVisibility = null;
    alias = null;
    membership = null;
    joinRule = null;
    guestAccessRule = null;
    invitedBy = null;
    memberCount = NaN;
    memberships = {};
    members = [];
    invited = [];
    events = [];
    eventsStart = null;
    states = {};
    typingUsers = [];
    setTypingRequest = null;
    setTypingEndTime = 0;
    loadQueue.clear();
    powerLevel = 0;
    powerLevelsReader = null;
    if (waitForJoined) {
      waitForJoined.reject(new Error('room closed before it was joined'));
    }
    waitForJoined = null;
    awaitingJoin = null;
    replyEventSnatchers = null;
    queries = queries.filter(function (fn) {
      return !fn();
    });
  });

  var memberCollections = {
    get invited() {
      return invited;
    },
    get member() {
      return members;
    }
  };

  this._setOwnMembership = function (_newMembership) {
    var newMembership = membershipNameMap[_newMembership];
    if (newMembership === this.membership) {
      return false;
    }
    var prevMembership = membership;
    membership = newMembership;
    this._emit('membership:' + membership, this);
    this._emit('membership', membership, prevMembership);
    delegate._onRoomMembership(this, _newMembership);
    return newMembership === 'member';
  };

  function changeMembership(next, user, changedBy) {
    var index;

    var prevName = memberships[user.id];
    var nextName = membershipNameMap[next];
    if (prevName === nextName) {
      return;
    }

    if (nextName === 'left') {
      delete memberships[user.id];
    } else {
      memberships[user.id] = nextName;
    }

    var prevCollection = memberCollections[prevName];
    var nextCollection = memberCollections[nextName];

    var prevCollectionName = userCollectionNameMap[prevName];
    var nextCollectionName = userCollectionNameMap[nextName];

    if (prevCollection) {
      index = prevCollection.indexOf(user);
      if (index !== -1) {
        prevCollection.splice(index, 1);
      } else {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error('room', 'failed to remove user from old membership collection:', prevCollection, user);
        return;
      }
    }

    if (nextCollection) {
      nextCollection.push(user);
    }
    if (user === ownUser) {
      if (nextName === 'invited') {
        invitedBy = changedBy;
      } else {
        invitedBy = null;
      }
    }

    if (next === 'join' && awaitingJoin && awaitingJoin.has(user._matrixId)) {
      awaitingJoin.get(user._matrixId).resolve();
      awaitingJoin.delete(user._matrixId);
    }

    self._emit(next, user, changedBy);
    self._emit('memberships', memberships);
    if (prevCollectionName && prevCollectionName !== nextCollectionName) {
      self._emit(prevCollectionName);
    }
    if (nextCollectionName) {
      self._emit(nextCollectionName);
    }
    if (nextCollectionName === 'members' && user !== ownUser) {
      self._emit('otherMembers');
    }
  }

  function returnSelf() {
    return self;
  }

  function throwAuthErrorIfNotFound(error) {
    if (error.name === 'NotFoundError') {
      throw new __WEBPACK_IMPORTED_MODULE_8_common_errors__["c" /* NotAllowedError */]('Not allowed to kick users from this room, ' + error.message);
    } else {
      throw error;
    }
  }

  /**
   * The id of the room
   * @readonly
   * @member {RoomId} Room#id
   */
  Object.defineProperty(this, 'id', {
    enumerable: true,
    value: id
  });

  /**
   * The type of membership that the authenticated user has
   * @readonly
   * @member {Room~Membership} Room#membership
   */
  Object.defineProperty(this, 'membership', {
    enumerable: true,
    get: function get() {
      return membership;
    }
  });

  /**
   * The type of memberships that all the users in the room have.
   *
   * **NOTE:** The returned object is read only and must not be modified.
   *
   * @readonly
   * @member {Object.<UserId,Room~Membership>} Room#memberships
   */
  Object.defineProperty(this, 'memberships', {
    enumerable: true,
    get: function get() {
      return memberships;
    }
  });

  /**
   * The alias of the room
   * @readonly
   * @member {RoomAlias} Room#alias
   */
  Object.defineProperty(this, 'alias', {
    enumerable: true,
    get: function get() {
      return alias;
    }
  });

  /**
   * The users in the room that are currently typing
   * @readonly
   * @member {User[]} Room#typing
   */
  Object.defineProperty(this, 'typing', {
    enumerable: true,
    get: function get() {
      return typingUsers.slice();
    }
  });

  /**
   * Sets whether the user is currently typing or not, with an optional timeout and margin.
   * The timeout can be used to temporarily set typing to true, while the margin allows throttling of requests.
   *
   * The margin permits setTyping to be called at a high rate without actually sending
   * any requests to the server. A request is sent only if the end of the previous
   * request's timeout has been reached or if the time until then is smaller than the margin.
   *
   * ```e.i. if (current time + margin) > (previous (request time + timeout))```
   *
   * Specifying a timeout is only valid when setting typing to true,
   *  as setting it to false will always do so indefinetly.
   *
   * Setting the typing state will cause any previous state, including timeouts, to be overwritten.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function Room#setTyping
   * @param {boolean} [isTyping=true] - The new typing state
   * @param {number} [timeout=10000] - Timeout in milliseconds
   * @param {number} [margin=1000] - Margin in milliseconds, or -1 to always send a request
   * @returns {Promise<Room, CctError>} - The room.
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["prop"])(this, 'setTyping', function (isTyping, timeout, margin) {
    if (arguments.length === 0) {
      isTyping = true;
    }
    if (arguments.length < 2) {
      __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].boolean('room.setTyping', 'isTyping', isTyping);
      timeout = 10000;
    }
    if (arguments.length < 3) {
      __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].number('room.setTyping', 'timeout', timeout);
      margin = 1000;
    } else {
      __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].number('room.setTyping', 'margin', margin);
    }
    if (!isTyping) {
      setTypingRequest = null;
      setTypingEndTime = 0;
      return request.typing.put({
        typing: !!isTyping,
        timeout: timeout
      });
    }
    if (setTypingEndTime) {
      var timeToEnd = setTypingEndTime - new Date().getTime();
      if (timeToEnd < margin || margin === -1) {
        setTypingRequest = null;
      }
    }
    if (!setTypingRequest) {
      setTypingEndTime = new Date().getTime() + timeout;
      setTypingRequest = request.typing.put({
        typing: !!isTyping,
        timeout: timeout
      }).then(returnSelf);
    }
    return setTypingRequest;
  });

  /**
   * The members of the room
   * @readonly
   * @member {User[]} Room#members
   */
  Object.defineProperty(this, 'members', {
    enumerable: true,
    get: function get() {
      return members.slice();
    }
  });

  /**
   * All members of the room except for the authenticated user
   * @readonly
   * @member {User[]} Room#otherMembers
   */
  Object.defineProperty(this, 'otherMembers', {
    enumerable: true,
    get: function get() {
      return members.filter(function (member) {
        return member !== ownUser;
      });
    }
  });

  Object.defineProperty(this, '_memberCount', {
    enumerable: true,
    get: function get() {
      if (isNaN(memberCount)) {
        return members.length;
      } else {
        return memberCount;
      }
    }
  });

  /**
   * Users that have been invited to the room
   * @readonly
   * @member {User[]} Room#invited
   */
  Object.defineProperty(this, 'invited', {
    enumerable: true,
    get: function get() {
      return invited.slice();
    }
  });

  /**
   * The joinRule of the room
   * @readonly
   * @member {Room~JoinRule} Room#joinRule
   */
  Object.defineProperty(this, 'joinRule', {
    enumerable: true,
    get: function get() {
      return joinRule;
    }
  });

  /**
   * Sets how other users are able to join this room. An `'open'`` room can
   * be joined with anyone that has the room id or an alias of the room,
   * while a room with the `'invite'` rule only allows users to join after
   * first being invited to the room by an existing member.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function Room#setJoinRule
   * @param {Room~JoinRule} joinRule - The new join rule for this room.
   * @returns {Promise<Room, CctError>} The room.
   */
  this.setJoinRule = function (joinRule) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].values('room.setJoinRule', 'joinRule', joinRule, ['open', 'invite']);
    if (joinRule === 'open') {
      joinRule = 'public';
    }
    return setState('m.room.join_rules', {
      join_rule: joinRule
    });
  };

  /**
   * The guestAccessRule of the room
   * @readonly
   * @member {Room~GuestAccessRule} Room#guestAccessRule
   */
  Object.defineProperty(this, 'guestAccessRule', {
    enumerable: true,
    get: function get() {
      return guestAccessRule;
    }
  });

  /**
   * Sets how guests are allowed to join the room. If set to `'open'`, guests
   * are allowed to join the rule, although they are still subject to
   * the join rule of the room. If set to `'closed'`, guests are not allowed
   * to join the room at all.
   *
   * The default guest access rule is `'closed'`.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function Room#setGuestAccessRule
   * @param {Room~GuestAccessRule} guestAccessRule - The new guest access rule for this room.
   * @returns {Promise<Room, CctError>} The room.
   */
  this.setGuestAccessRule = function (guestAccessRule) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].values('room.setGuestAccessRule', 'guestAccessRule', guestAccessRule, ['open', 'closed']);
    if (guestAccessRule === 'open') {
      guestAccessRule = 'can_join';
    } else if (guestAccessRule === 'closed') {
      guestAccessRule = 'forbidden';
    }
    return setState('m.room.guest_access', {
      guest_access: guestAccessRule
    });
  };

  /**
   * The type of the room.
   * @readonly
   * @member {string} Room#type
   */
  Object.defineProperty(this, 'type', {
    enumerable: true,
    get: function get() {
      return roomType;
    }
  });

  /**
   * The creator of the room.
   * @readonly
   * @member {User} Room#creator
   */
  Object.defineProperty(this, 'creator', {
    enumerable: true,
    get: function get() {
      return creator;
    }
  });

  /**
   * The creation content of the room.
   * @readonly
   * @member {JsonTypes} Room#creationContent
   */
  Object.defineProperty(this, 'creationContent', {
    enumerable: true,
    get: function get() {
      return creationContent;
    }
  });

  /**
   * The current topic of the room.
   * @readonly
   * @member {string} Room#topic
   */
  Object.defineProperty(this, 'topic', {
    enumerable: true,
    get: function get() {
      return topic;
    }
  });

  // eslint-disable-next-line jsdoc/require-description-complete-sentence
  /**
   * Sets the topic of the room.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
   *
   * @function Room#setTopic
   * @param {string} topic - The new topic for this room.
   * @returns {Promise<Room, CctError>} The room.
   */
  this.setTopic = function (topic) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].optString('room.setTopic', 'topic', topic);
    return setState('m.room.topic', {
      topic: topic || null
    });
  };

  /**
   * The current avatar of the room.
   * @readonly
   * @member {ImageResource} Room#avatar
   */
  Object.defineProperty(this, 'avatar', {
    enumerable: true,
    get: function get() {
      return avatar;
    }
  });

  // eslint-disable-next-line jsdoc/require-description-complete-sentence
  /**
   * Sets the avatar of the room.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
   *
   * @function Room#setAvatar
   * @param {MatrixContentUri|ImageResource} avatar - The new avatar for this room.
   * @returns {Promise<Room, CctError>} The room.
   */
  this.setAvatar = function (avatar) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].count('room.setAvatar', 1, arguments.length);
    var url = null;
    if (avatar) {
      if (!(avatar instanceof __WEBPACK_IMPORTED_MODULE_11_matrix_resources__["a" /* default */])) {
        __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].string('room.setAvatar', 'avatar', avatar);
        avatar = imageResourceFactory(avatar);
      }
      url = avatar.resourceUri;
    }
    return setState('m.room.avatar', {
      url: url
    });
  };

  /**
   * The current history visibility of the room.
   * @readonly
   * @member {Room~HistoryVisibility} Room#historyVisibility
   */
  Object.defineProperty(this, 'historyVisibility', {
    enumerable: true,
    get: function get() {
      return historyVisibility;
    }
  });

  /**
   * Sets the history visibility of the room.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function Room#setHistoryVisibility
   * @param {Room~HistoryVisibility} historyVisibility - The new history visibility of this room.
   * @returns {Promise<Room, CctError>} The room.
   */
  this.setHistoryVisibility = function (historyVisibility) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].values('room.setHistoryVisibility', 'historyVisibility', historyVisibility, ['shared', 'invited', 'joined', 'public']);
    return setState('m.room.history_visibility', {
      history_visibility: historyVisibility
    });
  };

  /**
   * The current name of the room.
   * @readonly
   * @member {string} Room#name
   */
  Object.defineProperty(this, 'name', {
    enumerable: true,
    get: function get() {
      return name;
    }
  });

  // eslint-disable-next-line jsdoc/require-description-complete-sentence
  /**
   * Sets the name of the room.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
   *
   * @function Room#setName
   * @param {string} name - The new name for this room.
   * @returns {Promise<Room, CctError>} The room.
   */
  this.setName = function (name) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].optString('room.setName', 'name', name);
    return setState('m.room.name', {
      name: name || null
    });
  };

  /**
   * The events of the room.
   * @readonly
   * @member {Room~Event[]} Room#events
   */
  Object.defineProperty(this, 'events', {
    enumerable: true,
    get: function get() {
      return events.slice();
    }
  });

  /**
   * The user that invited the client to the room.
   * @readonly
   * @member {Room~Event[]} Room#invitedBy
   */
  Object.defineProperty(this, 'invitedBy', {
    enumerable: true,
    get: function get() {
      return invitedBy;
    }
  });

  /**
   * A list of state types that are present in this room.
   * @readonly
   * @member {EventType[]} Room#states
   */
  Object.defineProperty(this, 'states', {
    enumerable: true,
    get: function get() {
      return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_keys___default()(states).map(function (key) {
        return states[key];
      });
    }
  });

  /**
   * Retrieves the state access object for a state of a specific type in the room.
   *
   * @function Room#state
   * @param {EventType} type - The state type.
   * @returns {RoomState} - A room state object for interacting with the state.
   */
  this.state = function (type) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].string('room.state', 'type', type);
    var state = states[type] = states[type] || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_12_matrix_roomState__["a" /* default */], type, self, setState.bind(self, type));
    return state;
  };

  // eslint-disable-next-line jsdoc/require-description-complete-sentence
  /**
   * Send an event.
   *
   * If two arguments are passed, they are treated as eventType + content.
   *
   * If only one argument is passed, it is treated as the body for a message event,
   *  the type of the message is inferred from the argument that was passed.
   * ##### Errors:
   * - {@link TooLargeError} - The serialized content is too large, as in it occupies too many bytes.
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
   *
   * @function Room#send
   * @param {EventType|*} eventType - The type of the event,
   *  or if only one arguments is passed, the message body.
   * @param {Object} [content] - The content of the event.
   * @returns {Promise<Room, CctError>} The room.
   */
  function send(eventType, content) {
    if (membership !== 'member') {
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject(new Error('Room.send: not a member of the room: ', self.id, membership));
    }
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].count('room.send', 1, arguments.length);
    if (arguments.length === 1) {
      content = eventType;
      if (typeof content !== 'string') {
        throw new TypeError('room.send: could not infer message type from', content);
      }
      return request.send.path('m.room.message').post({
        body: content,
        msgtype: 'm.text'
      }).then(returnSelf);
    } else {
      __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].string('room.send', 'eventType', eventType);
      __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].object('room.send', 'content', content);
      return request.send.path(eventType).post(content).then(returnSelf);
    }
  }

  function setState(stateType, stateKey, content) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].count('room.setState', 2, arguments.length);
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].string('room.setState', 'stateType', stateType);
    if (arguments.length === 2) {
      content = stateKey;
      stateKey = null;
    }
    var req = request.state.path(stateType);
    if (stateKey) {
      req = req.path(stateKey);
    }
    return req.put(content).then(returnSelf);
  }

  /**
   * The power levels in the room.
   * @readonly
   * @member {PowerLevelsReader} Room#powerLevels
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["getter"])(this, 'powerLevels', function () {
    return powerLevelsReader;
  });

  /**
   * Sets the entire power level state of the room to that of a power
   * level container object.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function Room#setPowerLevels
   * @param {PowerLevelsEdit|PowerLevelsReader} powerLevels - A power level container.
   * @returns {Promise<Room, CctError>} The room.
   */
  this.setPowerLevels = function (powerLevels) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].object('room.setPowerLevels', 'powerLevels', powerLevels);
    if (powerLevels.toRawForServer) {
      powerLevels = powerLevels.toRawForServer(dependencies.serverName);
    }
    return setState('m.room.power_levels', powerLevels);
  };

  /**
   * The power level of the own user in this room. Or null
   * if not a member of the room.
   * @readonly
   * @member {?number} Room#powerLevel
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["getter"])(this, 'powerLevel', function () {
    return powerLevel;
  });

  /**
   * Start editing the power levels of this room using a {@link PowerLevelsEdit}.
   *
   * @function Room#editPowerLevels
   * @returns {PowerLevelsEdit}
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["prop"])(this, 'editPowerLevels', function () {
    if (powerLevelsReader === null) {
      return null;
    }
    var serverName = dependencies.serverName;
    var transaction = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_16_matrix_powerLevels__["a" /* PowerLevelsEdit */], powerLevelsReader._powerLevels, { serverName: serverName });
    transaction.commit = function () {
      return setState('m.room.power_levels', transaction.toRawForServer(serverName));
    };
    return transaction;
  });

  /**
   * This callback is used to help decide how many events are loaded in.
   *  It is called once for every event that is loaded.
   *
   * @callback Room~LoadFilterFunction
   * @param {Room~Event} event - Event which has been loaded.
   * @param {number} index - The number of events that were loaded before this one.
   * @returns {boolean} - True if the event should count towards the total load count, false otherwise.
   */

  /**
   * Load in old events. If multiple requests are sent at once they will be queued after eachother.
   *
   * By passing a filterFunction, it is possible to filter whether each event should
   *  count towards the total count, and keep loading in events until the total count has been reached.
   * Events that are filtered out by the filter function are not discarded,
   *  they simply don't count towards the load count.
   *
   * If a filter function is used the number of matching events might exceed the requested count,
   * since events are loaded in chunks and no events will be ignored.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room.
   *
   * @function Room#load
   * @param {number} count - The number of events to load.
   * @param {number} [chunkSize=10] - Only valid if a filter function is given. It specifies how many events
   *  are loaded and filtered with each request.
   * @param {Room~LoadFilterFunction} [filterFunction] - Function used to
   *  filter out events that should count towards the event count.
   * @returns {Promise<Room~Event[], CctError>} List of events that were loaded, sorted newest to oldest.
   */
  this.load = function (count, chunkSize, filterFunction) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].count('room.load', 1, arguments.length);
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].number('room.load', 'count', count);
    if (eventsStart === null) {
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve([]);
    }
    var previousStart = eventsStart;
    if (arguments.length === 2) {
      filterFunction = chunkSize;
      chunkSize = 10;
    } else if (arguments.length > 2) {
      __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].number('room.load', 'chunkSize', chunkSize);
    }
    if (arguments.length > 1) {
      __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].func('room.load', 'filterFunction', filterFunction);
      var loaded = [];
      var index = 0;
      var filteredCount = 0;

      return loadQueue.push(function () {
        return new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
          recursiveFetch(resolve, reject);
        });
      });
    }
    return loadQueue.push(function () {
      if (eventsStart === null) {
        return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject('EOS');
      }
      return request.events.query({
        limit: count,
        from: '' + eventsStart
      }).get();
    }).then(function (response) {
      var addedEvents = addEvents(response);
      self._emit('events', self);
      return addedEvents;
    }).catch(function (err) {
      if (err === 'EOS') {
        return [];
      }
      throw err;
    });

    function recursiveFetch(resolve, reject) {
      return request.events.query({
        limit: chunkSize,
        from: '' + eventsStart
      }).get().then(function (response) {
        var addedEvents = addEvents(response);
        addedEvents.forEach(function (event) {
          var counted = true;
          try {
            counted = filterFunction(event, index);
          } catch (e) {
            __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error('room', 'Room.load: error thrown by filter function: ', e);
          }
          if (counted) {
            filteredCount += 1;
          }
          index += 1;
        });
        loaded = loaded.concat(addedEvents);
        self._emit('events', self);
        if (filteredCount >= count || self.allEventsLoaded) {
          resolve(loaded);
        } else {
          return recursiveFetch(resolve, reject);
        }
      }).catch(reject);
    }

    function addEvents(response) {
      var body = response.body;
      eventsStart = body.end;
      if (eventsStart === previousStart) {
        eventsStart = null;
      }
      previousStart = eventsStart;
      return body.chunk.map(function (event) {
        event.isPastEvent = true;
        var simple = toSimpleEvent(event);
        if (simple) {
          if (events[simple.id]) {
            var index = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["find"])(events, function (event) {
              return event.id === simple.id;
            });
            if (index !== null) {
              events[index] = simple;
            } else {
              __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error('room', 'failed to find existing event with id match:', simple);
            }
          } else {
            events.push(simple);
            events[simple.id] = simple;
          }
        }
        return simple;
      }).filter(function (x) {
        return x;
      });
    }
  };

  /**
   * True if all past events have been loaded
   *
   * @readonly
   * @member {boolean} Room#allEventsLoaded
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["getter"])(this, 'allEventsLoaded', function () {
    return eventsStart === null;
  });

  /**
   * True if more events are currently being loaded in
   *
   * @readonly
   * @member {boolean} Room#isLoading
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["getter"])(this, 'isLoading', function () {
    return !!loadQueue.executing;
  });

  /**
   * Invites a user to this room.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function Room#invite
   * @param {UserId|User} user - A user or a user id.
   * @returns {Promise<Room, CctError>} - The room.
   */
  this.invite = function (user) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].count('room.invite', 1, arguments.length);
    return request.invite.post({
      user_id: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_matrix_userRegistry__["a" /* toUserId */])('room.invite', user, dependencies.serverName)
    }).then(returnSelf).catch(throwAuthErrorIfNotFound);
  };

  /**
   * Join this room.
   * ##### Errors:
   * - {@link NotFoundError} - If the room does not exist, e.g. after using {@link Client#getRoom}.
   * - {@link NotAllowedError} - The user must be invited or the room join rule needs to be open.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function Room#join
   * @returns {Promise<Room, CctError>} - The room.
   */
  this.join = function () {
    if (membership === 'member') {
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve(self);
    } else if (waitForJoined) {
      return waitForJoined.promise;
    } else {
      waitForJoined = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["defer"])();
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.all([waitForJoined.promise, request.join.post().catch(function (err) {
        waitForJoined = null;
        throw err;
      })]).then(returnSelf);
    }
  };

  /**
   * Leave this room.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room.
   *
   * @function Room#leave
   * @returns {Promise<Room, CctError>} - The room.
   */
  this.leave = function () {
    if (membership === 'invited') {
      self._close();
      return request.leave.post().then(returnSelf).catch(throwAuthErrorIfNotFound);
    } else if (membership !== 'member') {
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve(self);
    } else {
      return request.leave.post().then(returnSelf).catch(throwAuthErrorIfNotFound);
    }
  };

  /**
   * Kick a user from this room.
   * ##### Errors:
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   *
   * @function Room#kick
   * @param {UserId|User} user - The user to kick.
   * @returns {Promise<Room, CctError>} - The room.
   */
  this.kick = function (user) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].count('room.kick', 1, arguments.length);
    var userId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_matrix_userRegistry__["a" /* toUserId */])('room.kick', user, dependencies.serverName);
    return request.kick.post({
      user_id: userId
    }).then(returnSelf).catch(throwAuthErrorIfNotFound);
  };

  /**
   * Initiate a call in the room.
   *
   * @function Room#startCall
   * @param {UserId|User} peer - The user to call as either a user instance or user id.
   * @returns {Call} - The call.
   */
  this.startCall = function (peer) {
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].count('room.startCall', 1, arguments.length);

    peer = userRegistry.getUser(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_matrix_userRegistry__["a" /* toUserId */])('room.startCall', peer, dependencies.serverName));
    __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug('room', 'starting call to peer', peer);

    return callRegistry.startCall(self, peer);
  };

  /**
   * Starts a new passive call in the room. A passive call works much like a normal call,
   * except that it does not initiate any new call, it only accepts incoming calls.
   *
   * This is typically used in the scenario where the creator of a room wants to start
   * setting up a call before knowing who the peer will be.
   *
   * Passive calls will always accept incoming calls from new peers, and hang up the
   * call to old ones. Whenever the call connects to a new peer, a 'peer' event will be
   * emitted from the call.
   *
   * @function Room#startPassiveCall
   * @returns {Call} - The call.
   */
  this.startPassiveCall = function () {
    __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug('room', 'starting passive call');
    return callRegistry.startCall(self);
  };

  /**
   * Start or join a conference call in the room. All clients that call this method within
   * a room will end up in the same conference.
   *
   * @function Room#startConference
   * @param {Object} options - Options object.
   * @param {ConferenceSwitcherMode} [options.switcherMode] - The default switcher mode for the conference.
   * @returns {ConferenceCall} - The conference call.
  */
  this.startConference = function (options) {
    __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug('room', 'starting conference call');
    return callRegistry.startConference(self, options);
  };

  /**
   * The active conference in the room, if there is one
   *
   * @readonly
   * @member {Conference} Room#conference
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["getter"])(this, 'conference', function () {
    return callRegistry.getConferenceInRoom(this);
  });

  /**
   * All active calls in the room. Each key-value pair is the other user and
   * the call object.
   * @readonly
   * @member {object<UserId,Call>} Room#calls
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["getter"])(this, 'calls', function () {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["assign"])({}, callRegistry.getCallsInRoom(this));
  });

  /**
   * Get the passive call in a room, if there is one.
   * @readonly
   * @member {Call?} Room#passiveCall
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["getter"])(this, 'passiveCall', function () {
    return callRegistry.getPassiveCallInRoom(this);
  });

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["hiddenProp"])(this, '_registerQuery', function (query) {
    queries.push(query);
  });

  this.send = send;

  this._serviceRequest = function (serviceLocalId, eventType) {
    var content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var timeoutMs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10000;

    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].string('room._serviceRequest', 'serviceLocalId', serviceLocalId);
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].string('room._serviceRequest', 'eventType', eventType);
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].optObject('room._serviceRequest', 'content', content);
    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].optNumber('room._serviceRequest', 'timeoutMs', timeoutMs);

    var serviceId = '@' + serviceLocalId + ':' + dependencies.serverName;

    var deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["defer"])();
    deferred.senderId = serviceId;
    deferred.eventType = eventType + '.reply';

    var waitForService;

    if (memberships[serviceLocalId] !== 'member') {
      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug('room', 'need to wait for \'' + serviceId + '\' before sending service request');
      if (!awaitingJoin) {
        awaitingJoin = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
      }
      if (awaitingJoin.has(serviceId)) {
        waitForService = awaitingJoin.get(serviceId).promise;
      } else {
        var _deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["defer"])();
        awaitingJoin.set(serviceId, _deferred);
        setTimeout(function () {
          if (awaitingJoin.get(serviceId)) {
            _deferred.reject(new Error('timed out waiting for service to join'));
            awaitingJoin.delete(serviceId);
          }
        }, timeoutMs);
        waitForService = _deferred.promise;
      }
    } else {
      waitForService = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve();
    }

    return waitForService.then(function () {
      return request.send.path(eventType).post(content);
    }).then(function (response) {
      var eventId = response.body && response.body.event_id;
      if (!eventId) {
        throw new Error('No event_id in response');
      }
      if (!replyEventSnatchers) {
        replyEventSnatchers = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
      }
      replyEventSnatchers.set(eventId, deferred);
      setTimeout(function () {
        deferred.reject(new Error('request timed out'));
        replyEventSnatchers.delete(eventId);
      }, timeoutMs);
      return deferred.promise.then(function (content) {
        var error = content.error;

        if (error) {
          var _name = error.name,
              message = error.message,
              extra = error.extra;

          var newError = new Error(message);
          newError.name = _name;
          if (extra) {
            newError.extra = extra;
          }
          throw newError;
        } else {
          return content;
        }
      });
    });
  };
}

Room.prototype = {
  constructor: Room,
  tag: 'room',

  toString: function toString() {
    return this.id;
  },

  get banned() {
    throw new Error('room.banned has been removed');
  },

  get ban() {
    throw new Error('room.ban has been removed');
  },

  get aliases() {
    throw new Error('room.aliases has been replaced by room.alias');
  },

  get setType() {
    throw new Error('room.setType has been removed, type is immutable');
  },

  /**
   * Account data object that is used to access room scoped account data.
   *
   * @readonly
   * @member {AccountData} Room#accountData
   */
  get accountData() {
    return this._accountData;
  },

  _setAccountData: function _setAccountData(key, value) {
    return this._request.setAccountData.path(key).put(value);
  }
};

__WEBPACK_IMPORTED_MODULE_5_common_emitter__["a" /* default */].call(Room.prototype);

/**
 * @typedef {object} Room~Event
 * @property {EventType} type - The event type
 * @property {object} content - The content of the event
 * @property {object} [oldContent] - The previous content of a state, if any.
 * @property {boolean} isStateChange - Whether or not this event is a state change event
 *  that changes the state of the room, as opposed to a message event which doesn't change any state.
 * @property {string} [stateKey] - The state key for a state change event or null if the default value was changed.
 *  Only defined for state events.
 * @property {User} sender - The user that sent the event
 * @property {Room} room - The room that event was received from
 * @property {boolean} isOwnEvent - True if the event was triggered by the authenticated user
 * @property {boolean} isPastEvent - True if the event was received before the client connected.
 * @property {number} timestamp - Unix timestamp in milliseconds
 */

/**
 * A string describing the users membership in a room.
 * @typedef {"member"|"kicked"|"invited"|null} Room~Membership
 */

/**
 * A string describing the visibility rules for events in a room.
 *
 * - `'shared'` - Any member of the room can read the entire history.
 * - `'invited'` - Members can only read the history from the point they
 * where invited to the room.
 * - `'joined'` - Members can only read the history from the point they
 * joined the room.
 * - `'public'` - All events in the room can be read by anyone, including guest accounts.
 *
 * **NOTE:** The visibility rules apply when an event is sent, for each event.
 * The visibility of events cannot be changed retrospectively.
 *
 * @typedef {"invited"|"joined"|"shared"|"public"} Room~HistoryVisibility
 */

/**
 * The join rule of a room determines how users are able to join the room.
 * - `'open'` - the user can be joined by anyone that has the room id or an
 * alias of the room.
 * - `'invite'` - only allows users to join after first being invited to the
 * room by an existing member.
 * @typedef {'open'|'invite'} Room~JoinRule
 */

/**
 * The guest access rule of a room determines how guests are able to join the room.
 * - `'open'` - guests are allowed to join the room, but are still subject to the
 * join rule of the room.
 * - `'closed'` - guests are not allowed to join the room.
 * @typedef {'open'|'closed'} Room~GuestAccessRule
 */

/**
 * Emitted when the alias of the room changes
 * @event Room#alias
 * @param {RoomAlias[]} alias - The new alias of the room.
 */

/**
 * Emitted when there is an incoming call to this room. Incoming calls are stopped and
 * need to be started with {@link Call#start} before a connection is set up.
 * @event Room#call
 * @param {Call} call - The call object
 */

/**
 * Emitted when a new {@link Room~Event} is triggered in the room.
 * Will not trigger when loading old events.
 * @event Room#event
 * @param {Room~Event} event - The event
 */

/**
 * Same as {@link Room#event:event}, but listens to a specific event type
 * @event Room#event:&lt;type&gt;
 * @param {Room~Event} event - The event
 */

/**
 * Emitted when the list of {@link Room~Event}s in the room change
 * @event Room#events
 * @param {Room~Event[]} events - The list of events for the room
 */

/**
 * Emitted when a user is invited to the room
 * @event Room#invite
 * @param {User} user - The user that was invited
 * @param {User} doneBy - The user responsible for the membership change
 */

/**
 * Emitted when the `invited` user collection is changed.
 *
 * This event does not have any parameters, the updated list of users
 * can instead be accessed via the {@link Room#invited}.
 *
 * @event Room#invited
 */

/**
 * Emitted when a user joins the room
 * @event Room#join
 * @param {User} user - The user that joined
 * @param {User} doneBy - The user responsible for the membership change
 */

/**
 * Emitted when a user leaves the room
 * @event Room#leave
 * @param {User} user
 * @param {User} doneBy - The user responsible for the membership change
 */

/**
 * Emitted when the `members` user collection is changed.
 *
 * This event does not have any parameters, the updated list of users
 * can instead be accessed via the {@link Room#members}.
 *
 * @event Room#members
 */

/**
 * Emitted when the `otherMembers` user collection is changed.
 *
 * This event does not have any parameters, the updated list of users
 * can instead be accessed via the {@link Room#otherMembers}.
 *
 * @event Room#otherMembers
 */

/**
 * Emitted when the membership of any user in the room is changed.
 * @event Room#memberships
 * @param {Object.<UserId,Room~Membership>} memberships - The new memberships
 */

/**
 * Emitted when the authenticated users membership of the room is changed
 * @event Room#membership
 * @param {Room~Membership} membership - The new membership of the room
 * @param {Room~Membership} prev - The previous membership of the room
 */

/**
 * Emitted when the name of the room is changed
 * @event Room#name
 * @param {string} name - The new name
 */

/**
 * Emitted when the power levels of the room change
 * @event Room#powerLevels
 * @param {PowerLevelsReader} powerLevels - The new power levels in the room
 */

/**
 * Emitted when a state of the room is changed
 * @event Room#state
 * @param {RoomState} state - The state that was changed
 */

/**
 * Same as {@link Room#event:state}, but listens to a specific state type
 * @event Room#state:&lt;stateType&gt;
 * @param {RoomState} state - The state that was changed
 */

/**
 * Emitted when the topic of the room is changed
 * @event Room#topic
 * @param {string} topic - The new topic
 */

/**
 * Emitted when the avatar of the room is changed
 * @event Room#avatar
 * @param {ImageResource} avatar - The new avatar
 */

/**
 * Emitted when the history visibility of the room changes.
 * @event Room#historyVisibility
 * @param {Room~HistoryVisibility} historyVisibility - The new history visibility
 */

/**
 * Emitted when the type of the room is changed
 * @event Room#type
 * @param {string} roomType - The new room type
 */

/**
 * Emitted when the creator of the room is changed
 * @event Room#creator
 * @param {User} creator - The new room creator
 */

/**
 * Emitted when the creation content of the room is changed
 * @event Room#creationContent
 * @param {JsonTypes} creationContent - The new room creationContent
 */

/**
 * Emitted when the list of users who are currently typing is changed.
 *
 * This event does not have any parameters, the updated list of users
 * can instead be accessed via the {@link Room#typing}.
 *
 * @event Room#typing
 */

/**
 * Emitted when the join rule of the room changes.
 * @event Room#joinRule
 * @param {Room~JoinRule} joinRule - The new join rule
 * @param {Room~JoinRule} oldJoinRule - The old join rule of the room
 */

/**
 * Emitted when the guest access rule of the room changes.
 * @event Room#guestAccessRule
 * @param {Room~GuestAccessRule} guestAccessRule - The new guest access rule
 * @param {Room~GuestAccessRule} oldGuestAccessRule - The old guest access rule
 */

/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = User;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_matrix_ids__ = __webpack_require__(168);








// eslint-disable-next-line
/**
 * Represents a user.
 *
 * @abstract
 * @class User
 * @extends EventEmitter
 */
function User(priv, config, imageResourceFactory) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["assertPriv"])('User', priv);
  var self = this;

  var id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_matrix_ids__["a" /* parseIdForServer */])('User constructor', config.matrixId, config.serverName, 'user');
  var matrixId = config.matrixId;

  this._membershipUpdateTime = 0;

  var name = null;
  var avatar = null;
  var presence = 'offline';
  var statusMessage = null;
  var lastActive = null;

  function applyUpdate(config) {
    var newName = config.displayname;
    if (!('displayname' in config)) {
      newName = config.name;
    }
    if (newName !== undefined && newName !== name) {
      name = newName;
      self._emit('name', name);
    }
    var newAvatarUrl = config.avatar_url || config.avatarUrl;
    if (newAvatarUrl !== undefined) {
      if (newAvatarUrl === null) {
        if (avatar !== null) {
          avatar = null;
          self._emit('avatar', avatar);
        }
      } else {
        var newAvatar = imageResourceFactory(newAvatarUrl);
        if (newAvatar !== avatar) {
          avatar = newAvatar;
          self._emit('avatar', avatar);
        }
      }
    }
    if ('avatar' in config) {
      avatar = config.avatar;
      self._emit('avatar', avatar);
    }
    var newPresence = config.presence;
    if (newPresence !== undefined && newPresence !== presence) {
      presence = newPresence;
      self._emit('presence', presence);
    }
    var newStatusMessage = config.status_msg;
    if (!('status_msg' in config)) {
      newStatusMessage = config.statusMessage;
    }
    if (newStatusMessage !== undefined && newStatusMessage !== statusMessage) {
      statusMessage = newStatusMessage;
      self._emit('statusMessage', statusMessage);
    }
    var lastActiveAgo = config.last_active_ago || config.lastActiveAgo;
    if (lastActiveAgo !== undefined) {
      if (isNaN(lastActiveAgo)) {
        if (lastActive !== null) {
          lastActive = null;
          self._emit('lastActive', lastActive);
        }
      } else {
        var time = new Date().getTime() - (lastActiveAgo || 0);
        if (Math.abs(time - (lastActive || 0)) > 1000) {
          lastActive = new Date(time);
          self._emit('lastActive', lastActive);
        }
      }
    }
  }

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["hiddenProp"])(this, '_applyUpdate', applyUpdate);
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["hiddenProp"])(this, '_matrixId', matrixId);

  /**
   * The id of the user
   * @readonly
   * @member {string} User#id
   */
  Object.defineProperty(this, 'id', {
    enumerable: true,
    value: id
  });

  Object.defineProperty(this, 'localId', {
    enumerable: false,
    get: function get() {
      __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].warning('user', 'user.localId is deprecated, use user.id instead');
      return id;
    }
  });

  /**
   * The name of the user
   * @readonly
   * @member {string} User#name
   */
  Object.defineProperty(this, 'name', {
    enumerable: true,
    get: function get() {
      return name;
    }
  });

  /**
   * The url to the user's avatar
   * @readonly
   * @member {ImageResource} User#avatar
   */
  Object.defineProperty(this, 'avatar', {
    enumerable: true,
    get: function get() {
      return avatar;
    }
  });

  /**
   * The users presence type
   * @readonly
   * @member {"online"|"unavailable"|"offline"} User#presence
   */
  Object.defineProperty(this, 'presence', {
    enumerable: true,
    get: function get() {
      return presence;
    }
  });

  /**
   * A message set by the user
   * @readonly
   * @member {string} User#statusMessage
   */
  Object.defineProperty(this, 'statusMessage', {
    enumerable: true,
    get: function get() {
      return statusMessage;
    }
  });

  /**
   * The last time the user was active
   * @readonly
   * @member {?Date} User#lastActive
   */
  Object.defineProperty(this, 'lastActive', {
    enumerable: true,
    get: function get() {
      return lastActive;
    }
  });

  applyUpdate(config);
}

User.prototype = {
  constructor: 'User',
  tag: 'user',

  toString: function toString() {
    return this.id;
  },

  _update: function _update(info) {
    this._applyUpdate(info);
  },

  _membershipEventUpdate: function _membershipEventUpdate(event) {
    if (this._membershipUpdateTime < event.origin_server_ts) {
      this._membershipUpdateTime = event.origin_server_ts;
      this._applyUpdate(event.content);
    }
  }
};

__WEBPACK_IMPORTED_MODULE_0_common_emitter__["a" /* default */].call(User.prototype);

/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_mediaSink__ = __webpack_require__(153);











/**
 * A callback that will be called whenever the input stream is changed.
 *
 * @callback StreamSink~OnStreamCallback
 * @param {MediaStream} stream - The new stream.
 */

/**
 * A simple media sink that emits a stream event and provides a stream property. Mainly useful for testing.
 *
 * @class StreamSink
 * @extends MediaSink
 * @extends EventEmitter
 * @param {Object} [options] - Optional options object.
 * @param {StreamSink~OnStreamCallback} [options.onStream] - Callback that will be called whenever the stream changes.
 */

var StreamSink = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(StreamSink, _EmitterMixin);

  function StreamSink() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        onStream = _ref.onStream;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, StreamSink);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StreamSink.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(StreamSink)).call(this));

    if (onStream) {
      _this._onStream = onStream;
    }
    return _this;
  }

  /**
   * Emitted whenever the stream is changed.
   *
   * @event MediaTee#stream
   * @param {?MediaStream} stream - The media stream, or null.
   */

  // eslint-disable-next-line
  /**
   * @private
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(StreamSink, [{
    key: 'onStream',
    value: function onStream(stream) {
      if (this._onStream) {
        this._onStream(stream);
      }
      this._emit('stream', stream);
    }
  }]);

  return StreamSink;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_6_media_mediaSink__["a" /* default */]));

/* harmony default export */ __webpack_exports__["a"] = (StreamSink);

/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_media_mediaSource__ = __webpack_require__(144);








/**
 * A simple media node that forwards a single media stream. Useful for testing and bridging with other libraries.
 *
 * @class StreamSource
 * @extends MediaSource
 * @param {Object} [options] - Optional options object.
 * @param {?MediaStream} [options.stream] - The media stream.
 */

var StreamSource = function (_MediaSource) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(StreamSource, _MediaSource);

  function StreamSource() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        stream = _ref.stream;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, StreamSource);

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StreamSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(StreamSource)).call(this));

    if (stream) {
      _this.setStream(stream);
    }
    return _this;
  }

  // Override superclass docs
  /**
   * Sets the current media stream.
   *
   * @function StreamSource#setStream
   * @param {?MediaStream} stream - The media stream.
   */


  return StreamSource;
}(__WEBPACK_IMPORTED_MODULE_4_media_mediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (StreamSource);

/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_mediaNodeOutput__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaSink__ = __webpack_require__(153);












/**
 * A media node that splits a single media stream into one stream with the audio track, and another stream
 * with the video track.
 *
 * @class StreamSplitter
 * @extends MediaSink
 */

var StreamSplitter = function (_MediaSink) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(StreamSplitter, _MediaSink);

  function StreamSplitter() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, StreamSplitter);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StreamSplitter.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(StreamSplitter)).call(this));

    _this._audioOutput = new __WEBPACK_IMPORTED_MODULE_6_media_mediaNodeOutput__["a" /* default */]({
      name: 'audio',
      parent: _this
    });
    _this._videoOutput = new __WEBPACK_IMPORTED_MODULE_6_media_mediaNodeOutput__["a" /* default */]({
      name: 'video',
      parent: _this
    });
    return _this;
  }

  /**
   * The output that will contain the audio track.
   *
   * @readonly
   * @member {MediaNodeOutput} StreamSplitter#audioOutput
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(StreamSplitter, [{
    key: 'onStream',


    // eslint-disable-next-line
    /**
     * @private
     */
    value: function onStream(stream) {
      if (!stream) {
        this._audioOutput.setStream(null);
        this._videoOutput.setStream(null);
        return;
      }

      if (stream.getAudioTracks().length) {
        var newStream = new __WEBPACK_IMPORTED_MODULE_5_webrtc_utils__["MediaStream"]();
        newStream.addTrack(stream.getAudioTracks()[0]);
        this._audioOutput.setStream(newStream);
      } else {
        this._audioOutput.setStream(null);
      }

      if (stream.getVideoTracks().length) {
        var _newStream = new __WEBPACK_IMPORTED_MODULE_5_webrtc_utils__["MediaStream"]();
        _newStream.addTrack(stream.getVideoTracks()[0]);
        this._videoOutput.setStream(_newStream);
      } else {
        this._videoOutput.setStream(null);
      }
    }
  }, {
    key: 'audioOutput',
    get: function get() {
      return this._audioOutput;
    }

    /**
     * The output that will contain the video track.
     *
     * @readonly
     * @member {MediaNodeOutput} StreamSplitter#videoOutput
     */

  }, {
    key: 'videoOutput',
    get: function get() {
      return this._videoOutput;
    }
  }]);

  return StreamSplitter;
}(__WEBPACK_IMPORTED_MODULE_7_media_mediaSink__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (StreamSplitter);

/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RtcPeer; });
/* unused harmony export AttachPoint */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_values__ = __webpack_require__(289);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_values___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_values__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_webrtc_rtcComponent__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_webrtc_channelControllers__ = __webpack_require__(231);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_webrtc_utils__ = __webpack_require__(66);





















/**
 * This class provides a point of interaction with remote peers of an attached {@link RtcComponent}.
 * Peers are accessed either through {@link AttachPoint#peers}, or via the overridable methods of {@link AttachPoint}.
 *
 * @abstract
 * @class RtcPeer
 * @extends MediaNode
 * @extends ConnectMixin
 */
var RtcPeer = function (_MediaNode$connectMix) {
  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_inherits___default()(RtcPeer, _MediaNode$connectMix);

  function RtcPeer(_ref) {
    var id = _ref.id,
        onUpdate = _ref.onUpdate,
        onCreateChannel = _ref.onCreateChannel;

    __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, RtcPeer);

    var _this = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default()(this, (RtcPeer.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(RtcPeer)).call(this));

    _this._id = id;
    _this._onUpdate = onUpdate;
    _this._onCreateChannel = onCreateChannel;

    _this._remoteChannels = [];
    _this._inputs = new __WEBPACK_IMPORTED_MODULE_12_media_mediaNode__["b" /* InputMap */]({ parent: _this });
    _this._outputs = new __WEBPACK_IMPORTED_MODULE_12_media_mediaNode__["c" /* OutputMap */]({ parent: _this });

    _this.createChannel = _this.createChannel.bind(_this);
    return _this;
  }

  /**
   * The id of the remote peer.
   *
   * @readonly
   * @member {string} RtcPeer#id
   */


  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(RtcPeer, [{
    key: 'onStream',


    /**
     * @private
     */
    value: function onStream() {
      this._onUpdate();
    }

    // Docs from mixin

  }, {
    key: 'connect',
    value: function connect(target) {
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get___default()(RtcPeer.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(RtcPeer.prototype), 'connect', this).call(this, target);
    }

    // Docs from mixin

  }, {
    key: 'disconnect',
    value: function disconnect(target) {
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_get___default()(RtcPeer.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(RtcPeer.prototype), 'disconnect', this).call(this, target);
    }

    /**
     * @private
     * @returns {Object<MediaStream>} Returns the local streams for this peer.
     */

  }, {
    key: '_getLocalStreams',
    value: function _getLocalStreams() {
      this._checkValid();
      var streams = {};
      this.inputs.forEach(function (input, name) {
        if (input.stream) {
          streams[name] = input.stream;
        }
      });
      return streams;
    }

    /**
     * Sets the remote media streams for this peer.
     *
     * @private
     * @param {Object<MediaStream>} streams - A set of remote streams, where the key is the name of the stream.
     */

  }, {
    key: '_setRemoteStreams',
    value: function _setRemoteStreams(streams) {
      this._checkValid();
      this.outputs.forEach(function (output, name) {
        if (!streams.hasOwnProperty(name)) {
          output.setStream(null);
        }
      });
      for (var name in streams) {
        var output = this.outputs.get(name);
        output.setStream(streams[name]);
      }
    }

    /**
     * Creates a new data channel to the peer, see {@link DataChannel}.
     *
     * The default behavior when creating a channel is that a local channel is created,
     * and a remote version of the channel will be received in the
     * {@link RtcComponent#rtcComponentReceivedChannel} method. This means that the
     * channel setup is asymmetric, one side creates a new channel, and the other
     * side receives it. This works best in request-type scenarios, where the component
     * that receives the channel doesn't know about it ahead of time.
     *
     * The other way to set up a channel is by specifying a pairingId, which is a quite
     * simple and symmetrical way of setting up channels. If both components specify
     * the same pairingId when creating a channel, the channels will pair up and connect
     * to each other. The label and protocol of paired channels must also match.
     * Paired channels will not be received in {@link RtcComponent#rtcComponentReceivedChannel}.
     * It's also not possible to close paired channels.
     *
     * Created and received channels are closed whenever the peer is lost. So paired channels
     * need to be recreated whenever a new peer is received.
     *
     * @param {Object} config - Configuration object.
     * @param {string} config.label - A label describing the data channel.
     * @param {string} [config.protocol] - A protocol that can be used to identify the purpose of the channel.
     * @param {string} [config.paringId] - The id used to pair the channel with a remote one.
     * @returns {DataChannel} The newly created data channel.
     */

  }, {
    key: 'createChannel',
    value: function createChannel(config) {
      this._checkValid();
      return this._onCreateChannel(config);
    }

    /**
     * Sets the remote channels for this peer.
     *
     * @private
     * @param {Array<DataChannel>} channels - An array of data channels.
     */

  }, {
    key: '_setRemoteChannels',
    value: function _setRemoteChannels(channels) {
      var newChannels = channels.slice(this._remoteChannels.length);
      this._remoteChannels = channels.slice();
      return newChannels;
    }

    /**
     * Checks if the RtcPeer is still valid and can be used. Throws an error if it is not.
     *
     * @private
     */

  }, {
    key: '_checkValid',
    value: function _checkValid() {
      if (this._id === null) {
        throw new Error('Tried to access invalidated RtcPeer');
      }
    }

    /**
     * Cleans up and invalidates the peer, any methods called afterwards will throw an error.
     *
     * @private
     */

  }, {
    key: '_invalidate',
    value: function _invalidate() {
      this._id = null;
      this._remoteChannels = null;
      this._inputs.clear();
      this._outputs.clear();
      this._inputs = null;
      this._outputs = null;
    }
  }, {
    key: 'id',
    get: function get() {
      this._checkValid();
      return this._id;
    },
    set: function set(value) {
      throw new TypeError('RtcPeer.id is read-only');
    }

    /**
     * The default media input for this peer.
     *
     * This is provided as a convenience to be able to connect directly to the peer when only a
     * single media stream is needed. Using this input is the same as using the input named
     * `'media'` from the inputs collection.
     *
     * @readonly
     * @member {MediaNodeInput} RtcPeer#input
     */

  }, {
    key: 'input',
    get: function get() {
      return this.inputs.get('media');
    }

    /**
     * The default media output for this peer.
     *
     * This is provided as a convenience to be able to connect directly from the peer when only a
     * single media stream is needed. Using this output is the same as using the output named
     * `'media'` from the outputs collection.
     *
     * @readonly
     * @member {MediaNodeOutput} RtcPeer#output
     */

  }, {
    key: 'output',
    get: function get() {
      return this.outputs.get('media');
    }

    /**
     * A collection of media inputs. The inputs functions as a media pipe to the peer, as the streams
     * sent to each input can be retrived from the outputs on the peers end.
     *
     * @readonly
     * @member {InputMap} RtcPeer#inputs
     */

  }, {
    key: 'inputs',
    get: function get() {
      this._checkValid();
      return this._inputs;
    }

    /**
     * A collection of media outputs. The outputs will forward the streams that the peer sent in via
     * it's inputs.
     *
     * @readonly
     * @member {OutputMap} RtcPeer#outputs
     */

  }, {
    key: 'outputs',
    get: function get() {
      this._checkValid();
      return this._outputs;
    }
  }]);

  return RtcPeer;
}(__WEBPACK_IMPORTED_MODULE_12_media_mediaNode__["a" /* default */].connectMixin(__WEBPACK_IMPORTED_MODULE_12_media_mediaNode__["a" /* default */]));

/**
 * A class which provides an interface for RtcComponents that are attached to a call or conference.
 * Should not be constructed directly.
 *
 * The lifetime of the attach point is tied to the attachment of the component. The attach point can
 * only be accessed while the components is attached to something, if it isn't an error will be thrown.
 *
 * @class AttachPoint
 * @abstract
 */
var AttachPoint = function () {
  function AttachPoint(_ref2) {
    var type = _ref2.type,
        ownId = _ref2.ownId,
        data = _ref2.data,
        component = _ref2.component,
        onUpdate = _ref2.onUpdate,
        onCreateChannel = _ref2.onCreateChannel;

    __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, AttachPoint);

    this.tag = 'attach-point';
    this._type = type;
    this._ownId = ownId;
    this._data = data;
    this._component = component;
    this._onUpdate = onUpdate;
    this._onCreateChannel = onCreateChannel;

    this._peers = new __WEBPACK_IMPORTED_MODULE_11_common_utils__["ReadOnlyMap"]();
    this._streams = {};
  }

  /**
   * The identitfy of the own user, this will always be equal to what other users will see as the
   * `peerId`. This is usually equal to the userId, but that is not guaranteed.
   *
   * @readonly
   * @member {string} AttachPoint#ownId
   */


  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(AttachPoint, [{
    key: '_getPeer',
    value: function _getPeer(id) {
      this._checkValid();
      if (!this._peers.has(id)) {
        this._addPeer(id);
      }
      return this._peers.get(id);
    }
  }, {
    key: '_addPeer',
    value: function _addPeer(id) {
      var _this2 = this;

      this._checkValid();
      var peer = new RtcPeer({
        id: id,
        onUpdate: this._onUpdate.bind(null, id), // peer updates are always specific to the peer
        onCreateChannel: function onCreateChannel(config) {
          return _this2._onCreateChannel(id, config);
        }
      });
      this._peers._set(id, peer);
      try {
        this._component.rtcComponentDidReceivePeer(peer);
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(this.tag, 'Error thrown in rtcComponentDidReceivePeer: ' + error);
      }
    }
  }, {
    key: '_setPeerChannels',
    value: function _setPeerChannels(peer, channels) {
      var _this3 = this;

      var added = peer._setRemoteChannels(channels);
      added.forEach(function (channel) {
        try {
          _this3._component.rtcComponentReceivedChannel(peer, channel);
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(_this3.tag, 'Error thrown in rtcComponentReceivedChannel: ' + error);
        }
      });
    }
  }, {
    key: '_removePeer',
    value: function _removePeer(id) {
      this._checkValid();
      var peer = this._peers.get(id);
      if (!peer) {
        return __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].debug(this.tag, 'peer ' + id + ' not present, nothing to remove');
      }

      peer._setRemoteStreams({});

      if (!this._peers._delete(id)) {
        __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(this.tag, 'Error when removing peer, peer \'' + id + '\' was not removed from the peer map.');
      }
      try {
        this._component.rtcComponentDidLosePeer(peer);
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(this.tag, 'Error thrown in rtcComponentDidLosePeer: ' + error);
      }
      peer._invalidate();
    }
  }, {
    key: '_checkValid',
    value: function _checkValid() {
      if (this._type === null) {
        throw new Error('Tried to access invalidated AttachPoint');
      }
    }
  }, {
    key: '_invalidate',
    value: function _invalidate() {
      this._type = null;
      this._ownId = null;
      this._data = null;
      this._component = null;
      this._onUpdate = null;
      this._peers = null;
      this._streams = null;
    }
  }, {
    key: 'ownId',
    get: function get() {
      this._checkValid();
      return this._ownId;
    },
    set: function set(value) {
      throw new TypeError('AttachPoint.ownId is read-only');
    }

    /**
     * The type of the object that the component is attached to.
     *
     * @readonly
     * @member {'call'|'conference'} AttachPoint#type
     */

  }, {
    key: 'type',
    get: function get() {
      this._checkValid();
      return this._type;
    },
    set: function set(value) {
      throw new TypeError('AttachPoint.type is read-only');
    }

    /**
     * A map of remote peers that we can interact with. Only peers we have an active connection to and
     * who have mounted a compatible component to the same point will be visible in this collection.
     *
     * @readonly
     * @member {ReadOnlyMap<string,RtcPeer>} AttachPoint#peers
     */

  }, {
    key: 'peers',
    get: function get() {
      this._checkValid();
      return this._peers;
    },
    set: function set(value) {
      throw new TypeError('AttachPoint.peers is read-only');
    }

    /**
     * Data that is synchronized between all peers.
     *
     * @member {AttachData} AttachPoint#data
     */

  }, {
    key: 'data',
    get: function get() {
      this._checkValid();
      return this._data;
    },
    set: function set(value) {
      throw new TypeError('AttachPoint.data is read-only');
    }
  }]);

  return AttachPoint;
}();

/**
 * A class which manages a set of attachments. Used by {@link Call} and {@link Conference}.
 *
 * @class AttachmentManager
 * @private
 */

var AttachmentManager = function () {
  function AttachmentManager(_ref3) {
    var _this4 = this;

    var type = _ref3.type,
        ownId = _ref3.ownId,
        dataHub = _ref3.dataHub,
        onUpdate = _ref3.onUpdate;

    __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, AttachmentManager);

    this.tag = 'attachment-manager';

    this._onAttachPointUpdate = this._onAttachPointUpdate.bind(this);

    this._type = type;
    this._ownId = ownId;
    this._dataHub = dataHub;
    this._onUpdate = onUpdate;

    if (dataHub) {
      dataHub.setOnUpdateListener(this._onDataUpdate.bind(this));
    }

    this._attachSignaler = new __WEBPACK_IMPORTED_MODULE_14_webrtc_channelControllers__["a" /* JsonChannelBroadcastController */]({
      onPeerChannelOpen: function onPeerChannelOpen(peerId) {
        var attachMap = _this4._getAttachMapForPeer(peerId);
        if (!_this4._attachSignaler.sendMessageToPeer(peerId, attachMap)) {
          __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(_this4.tag, 'failed to send attach map just after channel was opened');
        }
      },
      onPeerChannelClose: function onPeerChannelClose(peerId) {
        return _this4.cleanupPeer(peerId);
      },
      onMessageFromPeer: function onMessageFromPeer(peerId, attachMap) {
        __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].debug(_this4.tag, 'got remote source map:', attachMap);
        _this4._setAttachMapForPeer(peerId, attachMap);
      }
    });

    this._pausedPeers = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default.a();
    this._attachPoints = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    this._peerDatamuxes = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    this._peerAttachMaps = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    this._peerChannelMaps = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    this._peerRemoteStreams = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
  }

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(AttachmentManager, [{
    key: 'setDatamuxForPeer',
    value: function setDatamuxForPeer(peerId, datamux, channels) {
      if (this._attachSignaler) {
        this._attachSignaler.addPeer(peerId, channels.negotiationChannel);
      }
      if (this._dataHub) {
        this._dataHub.setChannelForPeer(peerId, channels.dataHubChannel);
      }
      this._peerDatamuxes.set(peerId, datamux);
    }
  }, {
    key: 'handlePeerChannel',
    value: function handlePeerChannel(peerId, channel) {
      if (channel._namespaceId.indexOf('attach-') !== 0) {
        return;
      }

      var name = channel._namespaceId.slice(7); // 'attach-'.length
      var channelMap = this._peerChannelMaps.get(peerId) || {};
      var channels = channelMap[name] || [];
      channels.push(channel);
      channelMap[name] = channels;
      this._peerChannelMaps.set(peerId, channelMap);
      this._updateAttachmentsForPeer(peerId);

      return true;
    }
  }, {
    key: 'attach',
    value: function attach(name, component) {
      var _this5 = this;

      __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].verbose(this.tag, this, 'attaching to ' + name + ': ' + component);
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].string('attach()', 'name', name);
      if (!(component instanceof __WEBPACK_IMPORTED_MODULE_13_webrtc_rtcComponent__["a" /* default */])) {
        throw new TypeError('Attach to ' + this._type + ' at ' + name + ' failed, ' + component + ' is not an RtcComponent instance.');
      }
      if (this._attachPoints.has(name)) {
        throw new TypeError('A component is already attached to \'' + name + '\'');
      }
      var attachPoint = new AttachPoint({
        component: component,
        type: this._type,
        ownId: this._ownId,
        data: this._dataHub && this._dataHub.get(name),
        onUpdate: this._onAttachPointUpdate,
        onCreateChannel: function onCreateChannel(peerId, config) {
          // using attach- for forwards compatibility to not reserve all namespace names
          config.namespaceId = 'attach-' + name;
          var datamux = _this5._peerDatamuxes.get(peerId);
          return datamux.createChannel(config);
        }
      });
      try {
        component.rtcComponentWillAttach(attachPoint);
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(this.tag, 'Error thrown in rtcComponentWillAttach, component was not attached: ' + error);
        attachPoint._invalidate();
        return false;
      }
      this._attachPoints.set(name, attachPoint);
      component._internalAttach(attachPoint);
      this._updateAttachments();
      this._onAttachPointUpdate();
      return true;
    }
  }, {
    key: 'detach',
    value: function detach(name) {
      var _this6 = this;

      var component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].verbose(this.tag, this, 'detaching from ' + name + ': ' + component);
      if (component && !(component instanceof __WEBPACK_IMPORTED_MODULE_13_webrtc_rtcComponent__["a" /* default */])) {
        throw new TypeError("Called detach with a second argument that isn't an RtcComponent.");
      }
      var attachPoint = this._attachPoints.get(name);
      if (!attachPoint) {
        throw new TypeError('Failed to detach \'' + name + '\', no component was attached.');
      }
      if (component && attachPoint._component !== component) {
        throw new TypeError('Failed to detach \'' + name + '\', currently attached component did not match.');
      }
      attachPoint.peers.forEach(function (_, peerId) {
        var datamux = _this6._peerDatamuxes.get(peerId);
        if (datamux) {
          datamux.closeChannelsInNamespace('attach-' + name);
        }
        attachPoint._removePeer(peerId);
      });
      var detachedComponent = attachPoint._component;
      try {
        detachedComponent.rtcComponentWillDetach(attachPoint);
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(this.tag, 'Error thrown in rtcComponentWillDetach: ' + error);
      }
      this._attachPoints.delete(name);
      attachPoint._invalidate();
      this._updateAttachments();
      this._onAttachPointUpdate();
    }
  }, {
    key: 'getAttachments',
    value: function getAttachments() {
      var attachments = {};
      this._attachPoints.forEach(function (attachPoint, name) {
        attachments[name] = attachPoint._component;
      });
      return attachments;
    }
  }, {
    key: 'getLocalStreamsForPeer',
    value: function getLocalStreamsForPeer(peerId) {
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].string('AttachManager.getLocalStreamsForPeer', 'peerId', peerId);
      var streams = [];

      if (!this._pausedPeers.has(peerId)) {
        this._attachPoints.forEach(function (attachPoint) {
          var peer = attachPoint.peers.get(peerId);
          if (peer) {
            __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_values___default()(peer._getLocalStreams()).forEach(function (stream) {
              if (stream && streams.indexOf(stream) === -1) {
                streams.push(stream);
              }
            });
          }
        });
      }

      return streams;
    }
  }, {
    key: 'setRemoteStreamsForPeer',
    value: function setRemoteStreamsForPeer(peerId, streams) {
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].string('AttachManager.setRemoteStreamsForPeer', 'peerId', peerId);
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].array('AttachManager.setRemoteStreamsForPeer', 'streams', streams);
      var streamMap = {};
      streams.forEach(function (stream) {
        streamMap[__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15_webrtc_utils__["getMediaStreamId"])(stream)] = stream;
      });
      this._peerRemoteStreams.set(peerId, streamMap);
      this._updateAttachmentsForPeer(peerId);
    }
  }, {
    key: 'setPeerPausedState',
    value: function setPeerPausedState(peerId, isPaused) {
      var changed;
      if (isPaused) {
        changed = !this._pausedPeers.has(peerId);
        if (changed) {
          this._pausedPeers.add(peerId);
        }
      } else {
        changed = this._pausedPeers.delete(peerId);
      }

      if (changed) {
        this._updateAttachmentsForPeer(peerId);
        this._onAttachPointUpdate(peerId);
      }
    }
  }, {
    key: 'cleanupPeer',
    value: function cleanupPeer(peerId) {
      this._attachPoints.forEach(function (attachPoint) {
        attachPoint._removePeer(peerId);
      });

      if (this._attachSignaler) {
        this._attachSignaler.removePeer(peerId);
      }
      if (this._dataHub) {
        this._dataHub.setChannelForPeer(peerId, null);
      }

      this._peerAttachMaps.delete(peerId);
      this._peerChannelMaps.delete(peerId);
      this._peerRemoteStreams.delete(peerId);
      this._peerDatamuxes.delete(peerId);
    }
  }, {
    key: 'cleanup',
    value: function cleanup() {
      var _this7 = this;

      // Updates are disabled here, so the called is responsible for updating or cleaning
      // up local streams, etc.
      this._onUpdate = null;

      this._attachPoints.forEach(function (attachPoint, name) {
        _this7.detach(name, attachPoint._component);
      });
      if (this._attachSignaler) {
        this._attachSignaler.cleanup();
        this._attachSignaler = null;
      }
      if (this._dataHub) {
        this._dataHub.cleanup();
        this._dataHub = null;
      }
    }

    // If peerId is set we know that the update only affected a single peer, so we only send
    // the updated map to that peer.

  }, {
    key: '_onAttachPointUpdate',
    value: function _onAttachPointUpdate() {
      var _this8 = this;

      var peerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (!this._attachSignaler) {
        return;
      }
      if (peerId) {
        var attachMap = this._getAttachMapForPeer(peerId);
        this._attachSignaler.sendMessageToPeer(peerId, attachMap);
      } else {
        this._peerAttachMaps.forEach(function (_, peerId) {
          var attachMap = _this8._getAttachMapForPeer(peerId);
          _this8._attachSignaler.sendMessageToPeer(peerId, attachMap);
        });
      }
      if (this._onUpdate) {
        this._onUpdate();
      }
    }
  }, {
    key: '_onDataUpdate',
    value: function _onDataUpdate(name, update) {
      var attachPoint = this._attachPoints.get(name);
      if (attachPoint) {
        attachPoint._component.rtcComponentUpdatedData(update);
      }
    }
  }, {
    key: '_getAttachMapForPeer',
    value: function _getAttachMapForPeer(peerId) {
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].string('AttachManager._getAttachMapForPeer', 'peerId', peerId);
      var attachMap = {};
      this._attachPoints.forEach(function (attachPoint, name) {
        var attachData = {
          label: attachPoint._component._label,
          streams: {}
        };
        var peer = attachPoint.peers.get(peerId);
        if (peer) {
          attachData.streams = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["mapValues"])(peer._getLocalStreams(), function (stream) {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15_webrtc_utils__["getMediaStreamId"])(stream);
          });
        }
        attachMap[name] = attachData;
      });
      return attachMap;
    }
  }, {
    key: '_setAttachMapForPeer',
    value: function _setAttachMapForPeer(peerId, attachMap) {
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].string('AttachManager._setAttachMapForPeer', 'peerId', peerId);
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].object('AttachManager._setAttachMapForPeer', 'attachMap', attachMap);
      this._peerAttachMaps.set(peerId, attachMap);
      this._updateAttachmentsForPeer(peerId);
    }
  }, {
    key: '_updateAttachments',
    value: function _updateAttachments() {
      var _this9 = this;

      this._peerAttachMaps.forEach(function (_, peerId) {
        _this9._updateAttachmentsForPeer(peerId);
      });
    }
  }, {
    key: '_updateAttachmentsForPeer',
    value: function _updateAttachmentsForPeer(peerId) {
      var _this10 = this;

      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].string('AttachManager._updateAttachmentsForPeer', 'peerId', peerId);
      var streams = this._peerRemoteStreams.get(peerId);
      var attachMap = this._peerAttachMaps.get(peerId);
      var attachChannelMap = this._peerChannelMaps.get(peerId);
      var missingPoints = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_set___default.a(this._attachPoints.keys());

      // Paused peers are peers who we have a connection to and we would like to maintain the state for,
      // but currently we don't want them to be present in attachments. e.g. non-raft members in conferences.
      if (this._pausedPeers.has(peerId)) {
        attachMap = {};
      }

      var _loop = function _loop(name) {
        var localPoint = _this10._attachPoints.get(name);
        if (!localPoint) {
          return 'continue';
        }

        var label = attachMap[name].label;
        var ownLabel = localPoint._component._label;
        var ownRemoteLabel = localPoint._component._remoteLabel;
        if (ownRemoteLabel) {
          if (typeof ownRemoteLabel === 'string') {
            if (ownRemoteLabel !== label) {
              __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(_this10.tag, 'peer label \'' + label + '\' does not match own remote label \'' + ownRemoteLabel + '\'');
              return 'continue';
            }
          } else if (!label.match(ownRemoteLabel)) {
            __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(_this10.tag, 'peer label \'' + label + '\' does not match own remote label pattern \'' + ownRemoteLabel + '\'');
            return 'continue';
          }
        } else if (ownLabel !== label) {
          __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(_this10.tag, 'peer label \'' + label + '\' does not match own label \'' + ownLabel + '\'');
          return 'continue';
        }
        var streamMap = {};
        // merge objects {[name]: streamId} + {[streamId]: stream} -> {[name]: stream}
        if (streams) {
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["forEach"])(attachMap[name].streams, function (streamId, name) {
            var stream = streams[streamId];
            if (stream) {
              streamMap[name] = stream;
            }
          });
        }

        try {
          var peer = localPoint._getPeer(peerId);
          peer._setRemoteStreams(streamMap);
          var channels = attachChannelMap ? attachChannelMap[name] || [] : [];
          localPoint._setPeerChannels(peer, channels);
          missingPoints.delete(name);
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_10_common_log__["default"].error(_this10.tag, 'Error updating component peer: ' + error);
        }
      };

      for (var name in attachMap) {
        var _ret = _loop(name);

        if (_ret === 'continue') continue;
      }

      missingPoints.forEach(function (name) {
        // When the remote peer detaches a component we close all the channels
        // and remove the peer.
        var datamux = _this10._peerDatamuxes.get(peerId);
        if (datamux) {
          datamux.closeChannelsInNamespace('attach-' + name);
        }

        var localPoint = _this10._attachPoints.get(name);
        localPoint._removePeer(peerId);
      });
    }
  }]);

  return AttachmentManager;
}();

/* harmony default export */ __webpack_exports__["b"] = (AttachmentManager);

/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export OP_SET */
/* unused harmony export OP_DELETE */
/* unused harmony export OP_NAME */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AttachData; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_entries__ = __webpack_require__(234);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_entries___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_entries__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_symbol_iterator__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_symbol_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_symbol_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_webrtc_channelControllers__ = __webpack_require__(231);



















function randomSeq() {
  return Math.random() * 1000000000 | 0;
}

var OP_SET = 1;
var OP_DELETE = 2;
var OP_NAME = [undefined, 'set', 'delete'];

/**
 * A class which provides a way to read and modify a set of data that is synchronized between all
 * the peers of an {@link RtcComponent}.
 *
 * @abstract
 * @class AttachData
 * @extends Map
 */
var AttachData = function (_Map) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(AttachData, _Map);

  function AttachData(_ref) {
    var onUpdate = _ref.onUpdate,
        onSendUpdate = _ref.onSendUpdate;

    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, AttachData);

    var _this = __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AttachData.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData)).call(this));

    _this.tag = 'attach-data';
    _this._seqs = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();
    _this._ownerIds = new __WEBPACK_IMPORTED_MODULE_13_common_utils__["ReadOnlyMap"]();
    _this._ownOwnerIds = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

    _this._onUpdate = onUpdate;
    _this._onSendUpdate = onSendUpdate;
    return _this;
  }

  /**
   * A collection of all owner ids for the data in this map. If an owner id exists for a given key
   * a entry must exist in the map as well, although the opposite is not always true.
   *
   * See {@link AttachData#setWithOwnership} for more information about ownership.
   *
   * @readonly
   * @member {ReadOnlyMap<string,string>} AttachData#owners
   */


  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(AttachData, [{
    key: 'keys',


    /**
     * @returns {Iterator<string>} An iterator of all the keys in the map.
     */
    value: function keys() {
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'keys', this).call(this);
    }

    /**
     * @returns {Iterator<JsonTypes>} An iterator of all the values in the map.
     */

  }, {
    key: 'values',
    value: function values() {
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'values', this).call(this);
    }

    /**
     * @returns {Iterator<Array<*>>} An iterator of all the values in the map.
     */

  }, {
    key: 'entries',
    value: function entries() {
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'entries', this).call(this);
    }

    /**
     * @param {string} key - The key to look for.
     * @returns {boolean} True if there is an entry for the given key.
     */

  }, {
    key: 'has',
    value: function has(key) {
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('AttachData.has', 'key', key);
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'has', this).call(this, key);
    }

    /**
     * @param {string} key - The key of the value to retrive.
     * @returns {JsonTypes} Returns the value for the given key.
     */

  }, {
    key: 'get',
    value: function get(key) {
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('AttachData.get', 'key', key);
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'get', this).call(this, key);
    }

    /**
     * Sets set value for the given key.
     *
     * Setting a local value will **not** trigger a {@link RtcComponent#rtcComponentUpdatedData} call,
     * that only happens for remote updates.
     *
     * @param {string} key - The key of the value.
     * @param {JsonTypes} value - The value to set.
     */

  }, {
    key: 'set',
    value: function set(key, value) {
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].count('AttachData.set', 2, arguments.length);
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('AttachData.set', 'key', key);
      return this.setWithOwnership(key, value, null);
    }

    /**
     * Sets set value for the given key, along with an ownership id.
     *
     * Setting the ownership allows data to be transparently overridden by users that are joining or
     * rejoining the data synchronization network. Usually the `ownerId` will be set to the id of the user,
     * but it can sometimes be useful to use other values, such as the role of the user, e.g. `'moderator'`.
     *
     * Since values can be updated while a call is not connected, the values that are set when disconnected
     * may be updated once you are connected with the rest of the users. When relaying some kind of state
     * to other peers this can cause problems, as the updates that you sent out before a reconnect will
     * cause an update to your local values. By tagging data with an owner id, it is possible to rejoin
     * a data synchronization group and transparently update your exsting values with the new state, without
     * causing a local update to trigger.
     *
     * Setting a local value will not trigger a {@link RtcComponent#rtcComponentUpdatedData} call,
     * that only happens for remote updates.
     *
     * @param {string} key - The key of the value.
     * @param {JsonTypes} value - The value to set.
     * @param {?string} ownerId - The owner id to use when setting the value.
     */

  }, {
    key: 'setWithOwnership',
    value: function setWithOwnership(key, value, ownerId) {
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].count('AttachData.setWithOwnership', 3, arguments.length);
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('AttachData.setWithOwnership', 'key', key);
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].optString('AttachData.setWithOwnership', 'ownerId', ownerId);
      this._checkValid();
      var ret = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'set', this).call(this, key, value);

      var seq = this._seqs.get(key) || 0;
      seq += randomSeq();
      this._seqs.set(key, seq);
      if (ownerId) {
        this._ownerIds._set(key, ownerId);
        this._ownOwnerIds.set(key, ownerId);
      }
      this._onSendUpdate(this._toSetMessage(seq, ownerId, key, value));
      return ret;
    }

    /**
     * Deletes an existing value of the corresponding key.
     *
     * Deleting a local value will not trigger a {@link RtcComponent#rtcComponentUpdatedData} call,
     * that only happens for remote updates.
     *
     * @param {string} key - The key to delete the value for.
     * @returns {boolean} True if a value existed.
     */

  }, {
    key: 'delete',
    value: function _delete(key) {
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].count('AttachData.delete', 1, arguments.length);
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('AttachData.delete', 'key', key);
      return this.deleteWithOwnership(key, null);
    }

    /**
     * Deletes an existing value of the corresponding key, using an ownership id.
     *
     * See {@link AttachData#setWithOwnership} for more information about ownership.
     *
     * Deleting a local value will not trigger a {@link RtcComponent#rtcComponentUpdatedData} call,
     * that only happens for remote updates.
     *
     * @param {string} key - The key to delete the value for.
     * @param {?string} ownerId - The owner id to use when deleting the value.
     * @returns {boolean} True if a value existed.
     */

  }, {
    key: 'deleteWithOwnership',
    value: function deleteWithOwnership(key, ownerId) {
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].count('AttachData.deleteWithOwnership', 2, arguments.length);
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].string('AttachData.deleteWithOwnership', 'key', key);
      __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].optString('AttachData.deleteWithOwnership', 'ownerId', ownerId);
      this._checkValid();
      var ret = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'delete', this).call(this, key);

      var seq = this._seqs.get(key) || 0;
      seq += randomSeq();
      this._seqs.set(key, seq);
      if (ownerId) {
        this._ownerIds._set(key, ownerId);
        this._ownOwnerIds.set(key, ownerId);
      }
      this._onSendUpdate(this._toDeleteMessage(seq, ownerId, key));
      return ret;
    }

    /**
     * Clears all the data in the map.
     *
     * Clearing the map locally will not trigger a {@link RtcComponent#rtcComponentUpdatedData} call,
     * that only happens for remote updates.
     */

  }, {
    key: 'clear',
    value: function clear() {
      var _this2 = this;

      // TODO: This could be more efficient
      this._checkValid();
      __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'forEach', this).call(this, function (key) {
        return _this2.delete(key);
      });
    }

    /**
     * Clears all the data in the map, using an ownership.
     *
     * See {@link AttachData#setWithOwnership} for more information about ownership.
     *
     * Clearing the map locally will not trigger a {@link RtcComponent#rtcComponentUpdatedData} call,
     * that only happens for remote updates.
     *
     * @param {?string} ownerId - The owner id to use when clearing the map.
     */

  }, {
    key: 'clearWithOwnership',
    value: function clearWithOwnership(ownerId) {
      var _this3 = this;

      this._checkValid();
      __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'forEach', this).call(this, function (key) {
        return _this3.deleteWithOwnership(key, ownerId);
      });
    }

    /**
     * The iterator function passed to {@link ReadOnlyMap#forEach}.
     *
     * @callback AttachData~ForEachCallback
     * @param {*} key - The key of the current entry.
     * @param {JsonTypes} value - The value of the current entry.
     * @param {AttachData} map - The map itself.
     */

    /**
     * Synchronously calls an interator function once for each entry in the map.
     *
     * Errors thrown inside the iterator function will cancel the iteration.
     *
     * @param {AttachData~ForEachCallback} func - The iterator function.
     * @param {*} [thisArg] - The value to use as `this` inside the iterator function.
     */

  }, {
    key: 'forEach',
    value: function forEach(func, thisArg) {
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'forEach', this).call(this, func, thisArg);
    }

    /**
     * This symbol allows the map to be used directly inside a `for..of` loop.
     *
     * @function AttachData#@@iterator
     * @returns {Object} An iterator for all the entries in this map.
     */

  }, {
    key: __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_symbol_iterator___default.a,
    value: function value() {
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_symbol_iterator___default.a, this).call(this);
    }

    // A local update uses the form {key, value, oldValue, ownerId}
    // An update that is sent over the wire uses an array to keep the json form more compact
    //   [op, key, value, seq] | [op, key, value, seq, ownerId]
    //   where op is either 1 for set

  }, {
    key: '_toDeleteMessage',
    value: function _toDeleteMessage(seq, ownerId, key) {
      return [OP_DELETE, seq, ownerId || 0, key];
    }
  }, {
    key: '_toSetMessage',
    value: function _toSetMessage(seq, ownerId, key, value) {
      return [OP_SET, seq, ownerId || 0, key, value];
    }

    // returns an array of updates

  }, {
    key: '_getCurrentState',
    value: function _getCurrentState() {
      var _this4 = this;

      var states = [];
      this._seqs.forEach(function (seq, key) {
        var value = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'get', _this4).call(_this4, key);
        var ownerId = _this4._ownerIds.get(key);
        states.push(_this4._toSetMessage(seq, ownerId, key, value));
      });
      return states;
    }

    // Handles a received update

  }, {
    key: '_onReceiveUpdate',
    value: function _onReceiveUpdate(peerId, _ref2) {
      var _ref3 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_slicedToArray___default()(_ref2, 5),
          op = _ref3[0],
          seq = _ref3[1],
          ownerId = _ref3[2],
          key = _ref3[3],
          value = _ref3[4];

      __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].verbose(this.tag, 'message from \'' + peerId + '\' op=' + OP_NAME[op] + ' key=\'' + key + '\' seq=' + seq + ' ownerId=\'' + ownerId + '\'');
      if (!(op === OP_SET || op === OP_DELETE)) {
        __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].error(this.tag, 'update had invalid op code: \'' + op + '\', ignoring');
        return;
      }
      var localSeq = this._seqs.get(key) || 0;
      var ownOwnerId = this._ownOwnerIds.get(key);
      var receivedOwnValue = ownerId && ownOwnerId && ownerId === ownOwnerId;
      var receivedIsNewer = localSeq < seq;

      if (receivedOwnValue && receivedIsNewer) {
        // Own value, so we increment seq and send update without signaling a local change
        seq += randomSeq();
        this._seqs.set(key, seq);
        if (__WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'has', this).call(this, key)) {
          var _value = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'get', this).call(this, key);
          this._onSendUpdate(this._toSetMessage(seq, ownerId, key, _value));
        } else {
          // If key is not present in main map, then it's been deleted
          this._onSendUpdate(this._toDeleteMessage(seq, ownerId, key));
        }
      } else if (receivedIsNewer) {
        this._seqs.set(key, seq);
        if (ownerId) {
          this._ownerIds._set(key, ownerId);
        }
        var oldValue = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'get', this).call(this, key);
        if (op === OP_SET) {
          __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'set', this).call(this, key, value);
        } else {
          __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'delete', this).call(this, key);
          value = undefined;
        }
        this._onUpdate({ key: key, value: value, oldValue: oldValue, ownerId: ownerId });
      }
    }
  }, {
    key: '_invalidate',
    value: function _invalidate() {
      this._seqs.clear();
      this._ownerIds._clear();
      this._seqs = null;
      this._ownerIds = null;
    }
  }, {
    key: '_checkValid',
    value: function _checkValid() {
      if (!this._seqs) {
        throw new TypeError('AttachData was accessed after the component was detached.');
      }
    }
  }, {
    key: 'owners',
    get: function get() {
      return this._ownerIds;
    }

    /**
     * The number of entries in the map.
     *
     * @readonly
     * @member {number} AttachData#size
     */

  }, {
    key: 'size',
    get: function get() {
      this._checkValid();
      return __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_get___default()(AttachData.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_object_get_prototype_of___default()(AttachData.prototype), 'size', this);
    }
  }]);

  return AttachData;
}(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a);

/**
 * A class that keeps track of a set of {@link AttachData}. Used by {@link AttachmentManager}.
 *
 * @private
 * @class DataHub
 */

var DataHub = function () {
  function DataHub() {
    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, DataHub);

    this.attachDatas = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a();

    this.onUpdateListener = null;

    this.controller = new __WEBPACK_IMPORTED_MODULE_14_webrtc_channelControllers__["a" /* JsonChannelBroadcastController */]({
      onPeerChannelOpen: this.onPeerChannelOpen.bind(this),
      onMessageFromPeer: this.onMessageFromPeer.bind(this)
    });
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(DataHub, [{
    key: 'get',
    value: function get(name) {
      var _this5 = this;

      var attachData = this.attachDatas.get(name);
      if (!attachData) {
        attachData = new AttachData({
          onUpdate: function onUpdate(update) {
            return _this5.onUpdate(name, update);
          },
          onSendUpdate: function onSendUpdate(update) {
            return _this5.onSendUpdate(name, update);
          }
        });
        this.attachDatas.set(name, attachData);
      }
      return attachData;
    }
  }, {
    key: 'setOnUpdateListener',
    value: function setOnUpdateListener(listener) {
      this.onUpdateListener = listener;
    }
  }, {
    key: 'onUpdate',
    value: function onUpdate(name, update) {
      if (this.onUpdateListener) {
        this.onUpdateListener(name, update);
      }
    }
  }, {
    key: 'onSendUpdate',
    value: function onSendUpdate(name, update) {
      var updatesMap = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default()({}, name, [update]);
      this.controller.sendMessage({ map: updatesMap });
    }
  }, {
    key: 'setChannelForPeer',
    value: function setChannelForPeer(peerId, channel) {
      if (channel) {
        this.controller.addPeer(peerId, channel);
      } else {
        this.controller.removePeer(peerId);
      }
    }
  }, {
    key: 'onPeerChannelOpen',
    value: function onPeerChannelOpen(peerId) {
      var updatesMap = {};
      this.attachDatas.forEach(function (attachData, name) {
        var updates = attachData._getCurrentState();
        updatesMap[name] = updates;
      });
      this.controller.sendMessageToPeer(peerId, { map: updatesMap });
    }
  }, {
    key: 'onMessageFromPeer',
    value: function onMessageFromPeer(peerId, message) {
      var _this6 = this;

      var updatesMap = message.map;
      if (updatesMap) {
        __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_entries___default()(updatesMap).forEach(function (_ref4) {
          var _ref5 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_slicedToArray___default()(_ref4, 2),
              name = _ref5[0],
              updates = _ref5[1];

          var attachData = _this6.get(name);
          updates.forEach(function (update) {
            return attachData._onReceiveUpdate(peerId, update);
          });
        });
      }
    }
  }, {
    key: 'cleanup',
    value: function cleanup() {
      this.onUpdateListener = null;
      this.controller.cleanup();
      this.controller = null;
      this.attachDatas.forEach(function (attachData) {
        attachData._invalidate();
      });
      this.attachDatas.clear();
      this.attachDatas = null;
    }
  }]);

  return DataHub;
}();

/* harmony default export */ __webpack_exports__["b"] = (DataHub);

/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_conference_raftConfiguration__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_conference_raftMessages__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_conference_raftLogEntry__ = __webpack_require__(133);












var TAG = 'raft';

var RaftLog = function () {
  function RaftLog(_ref) {
    var stateMachine = _ref.stateMachine,
        meshTopology = _ref.meshTopology,
        configuration = _ref.configuration;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, RaftLog);

    this._stateMachine = stateMachine;
    this._meshTopology = meshTopology;
    this._configuration = configuration;

    this._entries = [];
    this._offset = 0;
    this._commitIndex = 0;
    this._lastApplied = 0;
    this._snapshot = null;
    this._configurationIndex = 0;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(RaftLog, [{
    key: 'toString',
    value: function toString() {
      var entries = this._entries.slice(this._lastApplied - this._offset).join(',');
      return 'log{lli=' + this.lastLogIndex + ',llt=' + this.lastLogTerm + ',ci=' + this.commitIndex + (',la=' + this._lastApplied + ',' + this._configuration + ',es=[' + entries + ']}');
    }
  }, {
    key: 'entryAtIndex',
    value: function entryAtIndex(index) {
      if (index === 0) {
        return null;
      }
      return this._entries[index - 1 - this._offset] || null;
    }
  }, {
    key: 'entryTermAtIndex',
    value: function entryTermAtIndex(index) {
      if (this._snapshot) {
        if (index < this._snapshot.lastIndex) {
          throw new Error("can't get term for entry ahead of local snapshot");
        } else if (index === this._snapshot.lastIndex) {
          return this._snapshot.lastTerm;
        }
      }
      if (index > this._entries.length + this._offset || index < 1) {
        return 0;
      }
      return this.entryAtIndex(index).term;
    }

    // from fromIndex, to, but not including toIndex

  }, {
    key: 'sliceEntries',
    value: function sliceEntries(fromIndex, toIndex) {
      fromIndex = Math.max(fromIndex - 1 - this._offset, 0);
      toIndex = Math.max(toIndex - 1 - this._offset, 0);
      return this._entries.slice(fromIndex, toIndex);
    }
  }, {
    key: 'handleAppendEntriesRequest',
    value: function handleAppendEntriesRequest(message) {
      if (message.prevIndex > this.lastLogIndex) {
        // Appending these entries would leave a gap
        return message.response({ meshTopology: this._meshTopology });
      }

      // Check if we have a snapshot installed and and the request is older, in that
      // case we just ignore it since it must be a delayed/repeated message and the leader
      // should know to send a post-snapshot append
      if (this._snapshot && message.prevIndex < this._offset) {
        return;
      }

      var localPrevTerm = this.entryTermAtIndex(message.prevIndex);
      var remoteEntries = message.entries;
      if (localPrevTerm === message.prevTerm) {
        // Loop through remote entries until we don't have a local one or find a term mismatch
        for (var index = 0; index < remoteEntries.length; index += 1) {
          var remoteEntry = remoteEntries[index];
          // +1 since prevIndex is the entry before the one we want to match against
          var localIndex = message.prevIndex + index + 1;
          if (localIndex > this.lastLogIndex) {
            // We've run out of local entires to match against, append the rest
            this._pushEntries(remoteEntries.slice(index));
            break;
          }
          var localTerm = this.entryTermAtIndex(localIndex);
          if (localTerm !== remoteEntry.term) {
            // if an entry term doesn't match, delete the rest and append all
            this._revertEntries(localIndex);
            this._pushEntries(remoteEntries.slice(index));
            break;
          }
        }
        var matchIndex = message.prevIndex + remoteEntries.length;
        if (message.commitIndex > this._commitIndex) {
          // increase commit index to the remote one, but not higher than the last entry we received
          var newCommitIndex = Math.min(message.commitIndex, matchIndex);
          this._incrementCommitIndex(newCommitIndex);
        }
        return message.response({ success: true, matchIndex: matchIndex, meshTopology: this._meshTopology });
      } else {
        return message.response({ meshTopology: this._meshTopology });
      }
    }
  }, {
    key: 'getCommittedConfigurationData',
    value: function getCommittedConfigurationData() {
      var committedEntries = this.sliceEntries(0, this.commitIndex + 1);
      for (var index = committedEntries.length - 1; index >= 0; index -= 1) {
        var entry = committedEntries[index];
        if (entry instanceof __WEBPACK_IMPORTED_MODULE_7_conference_raftLogEntry__["b" /* ConfigurationEntry */]) {
          return entry.data;
        }
      }
      if (this._snapshot) {
        return this._snapshot.configuration;
      }
      return new __WEBPACK_IMPORTED_MODULE_5_conference_raftConfiguration__["b" /* ConfigurationData */](new __WEBPACK_IMPORTED_MODULE_5_conference_raftConfiguration__["c" /* Members */]());
    }
  }, {
    key: 'tryCommitIndexForTerm',
    value: function tryCommitIndexForTerm(newCommitIndex, expectedTerm) {
      if (newCommitIndex <= this._commitIndex) {
        return [];
      }
      var actualTerm = this.entryTermAtIndex(newCommitIndex);
      if (actualTerm !== expectedTerm) {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, 'Commit index ' + newCommitIndex + ' rejected, expected term was ' + expectedTerm + ', got ' + actualTerm);
        return [];
      }
      return this._incrementCommitIndex(newCommitIndex);
    }
  }, {
    key: 'createConfigurationEntry',
    value: function createConfigurationEntry(_ref2) {
      var term = _ref2.term,
          data = _ref2.data;

      var index = this.lastLogIndex + 1;
      var entry = new __WEBPACK_IMPORTED_MODULE_7_conference_raftLogEntry__["b" /* ConfigurationEntry */]({ term: term, index: index, data: data });
      this._configuration.set(data);
      this._configurationIndex = index;
      this._entries.push(entry);
      return entry;
    }
  }, {
    key: 'createOpEntry',
    value: function createOpEntry(_ref3) {
      var term = _ref3.term,
          id = _ref3.id,
          op = _ref3.op,
          args = _ref3.args;

      var index = this.lastLogIndex + 1;
      var entry = new __WEBPACK_IMPORTED_MODULE_7_conference_raftLogEntry__["d" /* OpEntry */]({ term: term, index: index, id: id, op: op, args: args });
      this._entries.push(entry);
      return entry;
    }
  }, {
    key: '_incrementCommitIndex',
    value: function _incrementCommitIndex(newCommitIndex) {
      this._commitIndex = newCommitIndex;
      var fromApplied = this._lastApplied;
      if (this._lastApplied < newCommitIndex) {
        this._lastApplied = newCommitIndex;
      }
      var committed = this.sliceEntries(fromApplied + 1, newCommitIndex + 1);
      this._stateMachine.commitEntries(committed);
      return committed;
    }
  }, {
    key: '_revertEntries',
    value: function _revertEntries(fromIncludingIndex) {
      if (fromIncludingIndex <= this.commitIndex) {
        throw new Error('tried to revert committed entries, ci=' + this.commitIndex + ', revert=' + fromIncludingIndex);
      }
      if (fromIncludingIndex <= this._lastApplied) {
        throw new Error('tried to revert applied entries, la=' + this._lastApplied + ', revert=' + fromIncludingIndex);
      }
      var reverted = this._entries.splice(fromIncludingIndex - 1 - this._offset);
      reverted.reverse(); // newest first
      this._stateMachine.revertEntries(reverted);

      if (this._configurationIndex < fromIncludingIndex) {
        return; // no need to revert configuration
      }

      for (var index = fromIncludingIndex - 1; index > 0; index -= 1) {
        if (this._snapshot && this._snapshot.lastIndex === index) {
          this._configuration.set(this._snapshot.configuration);
          this._configurationIndex = index;
          return;
        }
        var entry = this.entryAtIndex(index);
        if (entry instanceof __WEBPACK_IMPORTED_MODULE_7_conference_raftLogEntry__["b" /* ConfigurationEntry */]) {
          this._configuration.set(entry.data);
          this._configurationIndex = index;
          return;
        }
      }

      // no configuration found
      this._configuration.set(new __WEBPACK_IMPORTED_MODULE_5_conference_raftConfiguration__["b" /* ConfigurationData */](new __WEBPACK_IMPORTED_MODULE_5_conference_raftConfiguration__["c" /* Members */]()));
      this._configurationIndex = 0;
    }
  }, {
    key: '_pushEntries',
    value: function _pushEntries(entries) {
      var _entries;

      (_entries = this._entries).push.apply(_entries, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(entries));

      for (var index = entries.length - 1; index >= 0; index -= 1) {
        var entry = entries[index];
        if (entry instanceof __WEBPACK_IMPORTED_MODULE_7_conference_raftLogEntry__["b" /* ConfigurationEntry */]) {
          this._configuration.set(entry.data);
          this._configurationIndex = index;
          break;
        }
      }
    }
  }, {
    key: 'createSnapshot',
    value: function createSnapshot(term) {
      return __WEBPACK_IMPORTED_MODULE_6_conference_raftMessages__["h" /* SnapshotRequest */].create({
        term: term,
        lastTerm: this.entryTermAtIndex(this._lastApplied),
        lastIndex: this._lastApplied,
        configuration: this._configuration.get(),
        state: this._stateMachine.state
      });
    }
  }, {
    key: 'loadSnapshot',
    value: function loadSnapshot(snapshot) {
      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].instance('RaftLog.loadSnapshot', 'snapshot', snapshot, __WEBPACK_IMPORTED_MODULE_6_conference_raftMessages__["h" /* SnapshotRequest */]);
      var lastIndex = snapshot.lastIndex,
          configuration = snapshot.configuration;


      this._entries = [];
      this._offset = lastIndex;
      this._commitIndex = lastIndex;
      this._lastApplied = lastIndex;
      this._configurationIndex = lastIndex;
      this._configuration.set(configuration);
      this._snapshot = snapshot;

      this._stateMachine.loadSnapshot(snapshot);
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._stateMachine.clear();
      this._entries = [];
      this._offset = 0;
      this._commitIndex = 0;
      this._lastApplied = 0;
      this._snapshot = null;
      this._configurationIndex = 0;
    }
  }, {
    key: 'meshTopology',
    get: function get() {
      return this._meshTopology;
    }
  }, {
    key: 'configuration',
    get: function get() {
      return this._configuration;
    }
  }, {
    key: 'lastEntry',
    get: function get() {
      return this.entryAtIndex(this.lastLogIndex);
    }
  }, {
    key: 'lastLogIndex',
    get: function get() {
      return this._offset + this._entries.length;
    }
  }, {
    key: 'lastLogTerm',
    get: function get() {
      return this.entryTermAtIndex(this.lastLogIndex);
    }
  }, {
    key: 'commitIndex',
    get: function get() {
      return this._commitIndex;
    }
  }]);

  return RaftLog;
}();

/* harmony default export */ __webpack_exports__["a"] = (RaftLog);

/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_conference_raftLogEntry__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_conference_raftMessages__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_conference_raftState__ = __webpack_require__(167);













var TAG = 'raft';

var TICK_INTERVAL = 100;
var TICK_APPLIED_FACTOR = 10;
var STATE_OP_APPLY_TTL_MS = 30 * 1000;
var RESEND_RTT_FACTOR = 6;

// The StateMachine keeps the local state of the Raft cluster, and applies
// committed entries to that state after deduplication. It is also responsible
// for keeping track of operations that have been requested by the local
// client, and to retry them if needed.
//
// This diagram describes the flow of a successful state operation where the
// local client is the leader.
//
//      Raft --3-> LeaderState --4b-> ...
//      |  ^            |
//      1  2            4a
//      v  |            v
// StateMachine <-5-- RaftLog
//
// 1. An operation is requested.
// 2. The state machine sends a request via the onStateOpRequest callback.
// 3. Raft forwards the request to the current state.
// 4a. Append the OpEntry to the log.
// 4b. Raft algorithm in action, which ends up committing the entry.
// 5. The log forwards committed entries to the state machine.
//
// And now a diagram for if we're a follower.
//
//      Raft --3-> FollowerState --4-> LeaderState --5a->
//      |  ^                                |
//      1  2                                5a
//      v  |                                v
// StateMachine <-7-- RaftLog <- - 6 - - RaftLog
//
// 1-3. Same as above.
// 4. Send StateOpRequest to the current leader.
// 5a 5b. Same as 4a 4b above.
// 6. Raft algorithm ends up committing the entry in the follower's log.
// 7. Same as 5 above.
//

var StateMachine = function () {
  function StateMachine(_ref) {
    var onStateChange = _ref.onStateChange,
        onStateOpRequest = _ref.onStateOpRequest,
        onConfigurationCommitted = _ref.onConfigurationCommitted;

    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, StateMachine);

    this._tick = this._tick.bind(this);

    this._state = {};
    this._tickMod = 0;

    // Client requests are tracked here, type is Map<opId, [expiryMs, deferred, StateOpRequest]>
    this._tuples = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();

    // All members keep track of all op entry IDs that have been applied.
    this._appliedIds = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    this._onStateChange = onStateChange;
    this._onStateOpRequest = onStateOpRequest;
    this._onConfigurationCommitted = onConfigurationCommitted;
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(StateMachine, [{
    key: 'toString',
    value: function toString() {
      return 'stateMachine{' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this.state) + '}';
    }
  }, {
    key: 'start',
    value: function start() {
      this.stop();
      this._tickMod = 0;
      this._intervalId = setInterval(this._tick, TICK_INTERVAL);
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.clear();
      if (this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._state = {};
      this._tuples.clear();
      this._appliedIds.clear();
    }
  }, {
    key: 'requestStateOp',
    value: function requestStateOp(_ref2) {
      var op = _ref2.op,
          args = _ref2.args,
          retryTtlMs = _ref2.retryTtlMs;

      var id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_common_utils__["randomString"])(__WEBPACK_IMPORTED_MODULE_6_conference_raftLogEntry__["d" /* OpEntry */].idSize);
      var request = __WEBPACK_IMPORTED_MODULE_7_conference_raftMessages__["j" /* StateOpRequest */].create({ id: id, op: op, args: args });
      var now = Date.now();
      var expiry = now + retryTtlMs;
      var nextResend = now + __WEBPACK_IMPORTED_MODULE_8_conference_raftState__["d" /* EXPECTED_RTT_MS */] * RESEND_RTT_FACTOR;
      var deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_common_utils__["defer"])();
      this._tuples.set(id, { expiry: expiry, nextResend: nextResend, deferred: deferred, request: request });
      this._onStateOpRequest(request);
      return deferred.promise;
    }
  }, {
    key: 'handleStateOpResponse',
    value: function handleStateOpResponse(peerId, message) {
      var id = message.id,
          errorCode = message.errorCode;

      var tuple = this._tuples.get();
      if (!tuple) {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].info(TAG, this, ' got StateOpResponse for unknown tuple, ' + id);
        return;
      }
      if (errorCode) {
        if (errorCode === __WEBPACK_IMPORTED_MODULE_7_conference_raftMessages__["k" /* StateOpResponse */].NOT_LEADER) {
          this._onStateOpRequest(tuple.request);
          tuple.nextResend = Date.now() + __WEBPACK_IMPORTED_MODULE_8_conference_raftState__["d" /* EXPECTED_RTT_MS */] * RESEND_RTT_FACTOR;
        } else {
          __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].error(TAG, this, ' got unknown StateOpResponse errorCode for ' + id + ', ' + errorCode);
        }
      } else {
        // Success, reset resend timeout
        tuple.nextResend = Date.now() + __WEBPACK_IMPORTED_MODULE_8_conference_raftState__["d" /* EXPECTED_RTT_MS */] * RESEND_RTT_FACTOR;
      }
    }
  }, {
    key: '_tick',
    value: function _tick() {
      var _this = this;

      var now = Date.now();
      // Applied ids don't need to be checked nearly as often as tuple resends, so
      // only do it every nth tick.
      this._tickMod = (this._tickMod + 1) % TICK_APPLIED_FACTOR;
      if (this._tickMod === 0) {
        this._appliedIds.forEach(function (expiry, entryId) {
          if (expiry < now) {
            _this._appliedIds.delete(entryId);
          }
        });
      }
      this._tuples.forEach(function (tuple, entryId) {
        if (tuple.expiry < now) {
          _this._tuples.delete(entryId);
          tuple.deferred.reject(new Error('Timed out'));
        } else if (tuple.nextResend < now) {
          _this._onStateOpRequest(tuple.request);
          tuple.nextResend = now + __WEBPACK_IMPORTED_MODULE_8_conference_raftState__["d" /* EXPECTED_RTT_MS */] * RESEND_RTT_FACTOR;
        }
      });
    }
  }, {
    key: 'commitEntries',
    value: function commitEntries(entries) {
      var _this2 = this;

      var updated = false;
      entries.forEach(function (entry) {
        if (entry instanceof __WEBPACK_IMPORTED_MODULE_6_conference_raftLogEntry__["d" /* OpEntry */]) {
          if (_this2._appliedIds.has(entry.id)) {
            __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, _this2, 'ignored duplicate entry, ' + entry);
          } else {
            var expiry = Date.now() + STATE_OP_APPLY_TTL_MS;
            if (entry.id) {
              _this2._appliedIds.set(entry.id, expiry);
            }
            var newState = entry.apply(_this2._state);
            if (newState) {
              updated = true;
              _this2._state = newState;
            }
          }
          var tuple = _this2._tuples.get(entry.id);
          if (tuple) {
            tuple.deferred.resolve();
            _this2._tuples.delete(entry.id);
          }
        } else if (entry instanceof __WEBPACK_IMPORTED_MODULE_6_conference_raftLogEntry__["b" /* ConfigurationEntry */]) {
          _this2._onConfigurationCommitted && _this2._onConfigurationCommitted(entry.data);
        }
      });
      if (updated) {
        this._onStateChange && this._onStateChange();
      }
    }
  }, {
    key: 'revertEntries',
    value: function revertEntries(entries) {
      var _this3 = this;

      entries.forEach(function (entry) {
        var tuple = _this3._tuples.get(entry.id);
        if (tuple) {
          _this3._onStateOpRequest(tuple.request);
          tuple.nextResend = Date.now() + __WEBPACK_IMPORTED_MODULE_8_conference_raftState__["d" /* EXPECTED_RTT_MS */] * RESEND_RTT_FACTOR;
        }
      });
    }
  }, {
    key: 'loadSnapshot',
    value: function loadSnapshot(snapshot) {
      this._state = snapshot.state;

      this._onStateChange && this._onStateChange();
      this._onConfigurationCommitted && this._onConfigurationCommitted(snapshot.configuration);
    }
  }, {
    key: 'state',
    get: function get() {
      return this._state;
    }
  }]);

  return StateMachine;
}();

/* harmony default export */ __webpack_exports__["a"] = (StateMachine);

/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export BadRequestError */
/* unused harmony export TooLargeError */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return AuthenticationError; });
/* unused harmony export InvalidCaptchaError */
/* unused harmony export GuestAccessError */
/* unused harmony export ConflictError */
/* unused harmony export InvalidUsernameError */
/* unused harmony export InvalidPasswordError */
/* unused harmony export InvalidAliasError */
/* unused harmony export RateLimitError */
/* unused harmony export InternalServerError */
/* harmony export (immutable) */ __webpack_exports__["a"] = parseSynapseErrorResponse;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_errors__ = __webpack_require__(145);








/**
 * The request was malformed. This error shouldn't be encountered since input is validated
 * on the client-side.
 *
 * @class BadRequestError
 * @extends CctError
 */
var BadRequestError = function (_CctError) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(BadRequestError, _CctError);

  function BadRequestError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, BadRequestError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (BadRequestError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(BadRequestError)).apply(this, arguments));
  }

  return BadRequestError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
BadRequestError.errorName = 'BadRequestError';

/**
 * The request was too large, encountered e.g. when sending messages in a room.
 *
 * @class TooLargeError
 * @extends CctError
 */
var TooLargeError = function (_CctError2) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(TooLargeError, _CctError2);

  function TooLargeError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, TooLargeError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (TooLargeError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(TooLargeError)).apply(this, arguments));
  }

  return TooLargeError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
TooLargeError.errorName = 'TooLargeError';

/**
 * Authentication failed, or authentication is required to perform the action.
 *
 * @class AuthenticationError
 * @extends CctError
 */
var AuthenticationError = function (_CctError3) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(AuthenticationError, _CctError3);

  function AuthenticationError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, AuthenticationError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AuthenticationError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(AuthenticationError)).apply(this, arguments));
  }

  return AuthenticationError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
AuthenticationError.errorName = 'AuthenticationError';

/* placeholder */
var InvalidCaptchaError = function (_CctError4) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(InvalidCaptchaError, _CctError4);

  function InvalidCaptchaError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, InvalidCaptchaError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (InvalidCaptchaError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(InvalidCaptchaError)).apply(this, arguments));
  }

  return InvalidCaptchaError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
InvalidCaptchaError.errorName = 'InvalidCaptchaError';

/**
 * The requested action could not be performed because the authenticated user has a guest account.
 *
 * @class GuestAccessError
 * @extends CctError
 */
var GuestAccessError = function (_CctError5) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(GuestAccessError, _CctError5);

  function GuestAccessError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, GuestAccessError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (GuestAccessError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(GuestAccessError)).apply(this, arguments));
  }

  return GuestAccessError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
GuestAccessError.errorName = 'GuestAccessError';

/**
 * The requested action would result in a conflict, such as trying to create a room with an
 * alias that already exists, or registering a user with an existing username.
 *
 * @class ConflictError
 * @extends CctError
 */
var ConflictError = function (_CctError6) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ConflictError, _CctError6);

  function ConflictError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ConflictError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConflictError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ConflictError)).apply(this, arguments));
  }

  return ConflictError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
ConflictError.errorName = 'ConflictError';

/**
 * The requested username is invalid. Usernames must at most be 512 characters long
 * and may only contain `a-z`, `0-9`, and `_-./`.
 *
 * @class InvalidUsernameError
 * @extends CctError
 */
var InvalidUsernameError = function (_CctError7) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(InvalidUsernameError, _CctError7);

  function InvalidUsernameError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, InvalidUsernameError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (InvalidUsernameError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(InvalidUsernameError)).apply(this, arguments));
  }

  return InvalidUsernameError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
InvalidUsernameError.errorName = 'InvalidUsernameError';

/**
 * The requested password is invalid. Passwords must at most be 512 characters long.
 *
 * @class InvalidPasswordError
 * @extends CctError
 */
var InvalidPasswordError = function (_CctError8) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(InvalidPasswordError, _CctError8);

  function InvalidPasswordError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, InvalidPasswordError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (InvalidPasswordError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(InvalidPasswordError)).apply(this, arguments));
  }

  return InvalidPasswordError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
InvalidPasswordError.errorName = 'InvalidPasswordError';

/**
 * The requested room alias is invalid because it contains forbidden characters. Aliases are
 * not allowed to contain whitespace characters.
 *
 * @class InvalidAliasError
 * @extends CctError
 */
var InvalidAliasError = function (_CctError9) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(InvalidAliasError, _CctError9);

  function InvalidAliasError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, InvalidAliasError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (InvalidAliasError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(InvalidAliasError)).apply(this, arguments));
  }

  return InvalidAliasError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
InvalidAliasError.errorName = 'InvalidAliasError';

/**
 * The action could not be performed because it hit the rate limit of the server. This is
 * currently only used internally since requests are automatically retried if they hit the
 * rate limit.
 *
 * @class RateLimitError
 * @extends CctError
 */
var RateLimitError = function (_CctError10) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(RateLimitError, _CctError10);

  function RateLimitError(message, body) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, RateLimitError);

    var _this10 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (RateLimitError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(RateLimitError)).call(this, message));

    if (body && 'retry_after_ms' in body) {
      _this10.retryAfterMs = body.retry_after_ms;
    } else {
      _this10.retryAfterMs = RateLimitError.defaultRetryTimeoutMs;
    }
    return _this10;
  }

  return RateLimitError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
RateLimitError.errorName = 'RateLimitError';
RateLimitError.defaultRetryTimeoutMs = 1000;

/**
 * The server encountered an error because of an unexpected code path or an invalid state.
 *
 * @class InternalServerError
 * @extends CctError
 */
var InternalServerError = function (_CctError11) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(InternalServerError, _CctError11);

  function InternalServerError() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, InternalServerError);

    return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (InternalServerError.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(InternalServerError)).apply(this, arguments));
  }

  return InternalServerError;
}(__WEBPACK_IMPORTED_MODULE_4_common_errors__["a" /* default */]);
InternalServerError.errorName = 'InternalServerError';

var errorParsers = {
  M_UNKNOWN: {
    parse: function parse(message) {
      if (message.indexOf('Room alias') === 0 && message.indexOf('already exists') !== -1) {
        return ConflictError;
      } else if (message.indexOf('Room') === 0 && message.indexOf('does not exist') !== -1) {
        return __WEBPACK_IMPORTED_MODULE_4_common_errors__["b" /* NotFoundError */];
      }
    },

    exact: {
      'Room alias already taken': ConflictError,
      'HMAC incorrect': AuthenticationError,
      'Invalid username': InvalidUsernameError,
      'Invalid password': InvalidPasswordError,
      'Invalid characters in room alias': InvalidAliasError,
      'Registration has been disabled': __WEBPACK_IMPORTED_MODULE_4_common_errors__["c" /* NotAllowedError */],
      'Guest access is disabled': GuestAccessError,
      'Upload request body is too large': TooLargeError
    },
    Default: __WEBPACK_IMPORTED_MODULE_4_common_errors__["d" /* UnknownError */]
  },
  M_FORBIDDEN: {
    parse: function parse(message) {
      if (message.indexOf('is already in the room.') !== -1) {
        return ConflictError;
      }
    },

    exact: {
      'Guest access not allowed': GuestAccessError,
      'Invalid password': AuthenticationError,
      'Invalid token': AuthenticationError
    },
    Default: __WEBPACK_IMPORTED_MODULE_4_common_errors__["c" /* NotAllowedError */]
  },
  M_NOT_FOUND: { Default: __WEBPACK_IMPORTED_MODULE_4_common_errors__["b" /* NotFoundError */] },
  M_LIMIT_EXCEEDED: { Default: RateLimitError },
  M_UNAUTHORIZED: { Default: __WEBPACK_IMPORTED_MODULE_4_common_errors__["c" /* NotAllowedError */] },
  M_MISSING_TOKEN: { Default: BadRequestError },
  M_UNKNOWN_TOKEN: { Default: AuthenticationError },
  M_UNRECOGNIZED: { Default: BadRequestError },
  M_BAD_JSON: { Default: BadRequestError },
  M_NOT_JSON: { Default: BadRequestError },
  M_USER_IN_USE: { Default: ConflictError },
  M_ROOM_IN_USE: { Default: ConflictError },
  M_BAD_PAGINATION: { Default: BadRequestError },
  M_BAD_STATE: { Default: ConflictError }, // only for trying to ban/unban users
  M_GUEST_ACCESS_FORBIDDEN: { Default: GuestAccessError },
  M_CAPTCHA_NEEDED: { Default: BadRequestError },
  M_CAPTCHA_INVALID: { Default: InvalidCaptchaError },
  M_MISSING_PARAM: { Default: BadRequestError },
  M_TOO_LARGE: { Default: TooLargeError },
  M_EXCLUSIVE: { Default: ConflictError },
  M_THREEPID_AUTH_FAILED: { Default: __WEBPACK_IMPORTED_MODULE_4_common_errors__["d" /* UnknownError */] },
  M_THREEPID_IN_USE: { Default: __WEBPACK_IMPORTED_MODULE_4_common_errors__["d" /* UnknownError */] },
  M_THREEPID_NOT_FOUND: { Default: __WEBPACK_IMPORTED_MODULE_4_common_errors__["d" /* UnknownError */] },
  M_INVALID_USERNAME: { Default: InvalidUsernameError },
  M_SERVER_NOT_TRUSTED: { Default: AuthenticationError }
};

function parseSynapseErrorResponse(error) {
  if (error instanceof Error) {
    return error;
  }

  var status = error.status;
  var name = error.body && error.body.errcode;
  var message = error.body && error.body.error;

  if (!message && !name && typeof error.body === 'string') {
    name = 'M_UNKNOWN';
    message = error.body;
  }

  // console.error(`Synapse error: [${status}] ${name}: ${message}`)
  if (status === 404) {
    return new __WEBPACK_IMPORTED_MODULE_4_common_errors__["b" /* NotFoundError */](message || 'Not Found', error.body);
  }
  message = message || 'No message';
  if (status === 500) {
    return new InternalServerError(message, error.body);
  }

  var parser = errorParsers[name];
  if (!parser) {
    return new __WEBPACK_IMPORTED_MODULE_4_common_errors__["d" /* UnknownError */]('[' + name + '] ' + message, error.body);
  }
  var ExactMatch = parser.exact && parser.exact[message];

  if (ExactMatch) {
    return new ExactMatch(message, error.body);
  } else {
    if (parser.parse) {
      var Match = parser.parse(message);
      if (Match) {
        return new Match(message, error.body);
      }
    }
    if (parser.Default) {
      return new parser.Default(message, error.body);
    }
  }
  return new __WEBPACK_IMPORTED_MODULE_4_common_errors__["d" /* UnknownError */]('[' + name + '] ' + message, error.body);
}

/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = UserRegistry;
/* harmony export (immutable) */ __webpack_exports__["a"] = toUserId;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_matrix_ids__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_matrix_user__ = __webpack_require__(188);








function UserRegistry() {
  this._dependencies = null;
  this._users = {};
}

UserRegistry.prototype = {
  constructor: UserRegistry,
  tag: 'user-registry',
  toString: function toString() {
    return 'userRegistry{}';
  },
  getUser: function getUser(arg) {
    var matrixId = toUserId('UserRegistry.get', arg, this._dependencies.serverName);
    var user = this._users[matrixId];
    if (!user) {
      user = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_4_matrix_user__["a" /* default */], {
        matrixId: matrixId,
        serverName: this._dependencies.serverName
      }, this._dependencies.imageResourceFactory);
      this._users[matrixId] = user;
    }
    return user;
  },

  // dependencies.ownUserId
  // dependencies.imageResourceFactory
  init: function init(dependencies) {
    this._dependencies = dependencies;
    return this;
  },
  clear: function clear() {
    this._dependencies = null;
    this._users = {};
  },

  _handlePresenceSync: function _handlePresenceSync(presenceEvents) {
    for (var i in presenceEvents) {
      var event = presenceEvents[i];
      var content = event.content;
      var matrixId = event.sender;
      var user = this.getUser(matrixId);
      user._update(content);
      __WEBPACK_IMPORTED_MODULE_0_common_log__["default"].verbose('events', 'got presence event for user ' + matrixId, user);
    }
  }
};

function toUserId(context, user, serverName) {
  var id;
  if (user instanceof __WEBPACK_IMPORTED_MODULE_4_matrix_user__["a" /* default */]) {
    id = user._matrixId;
  } else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["isObject"])(user)) {
    id = user.user_id || user.userId || user.id;
  } else {
    id = user;
  }
  __WEBPACK_IMPORTED_MODULE_1_common_argCheck__["a" /* default */].string(context, 'id', id);
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_matrix_ids__["b" /* toMatrixIdForServer */])(context, id, serverName, 'user');
}

/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = attachPeerConnectionMonitor;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_webrtc_statsNormalizer__ = __webpack_require__(201);








// function MediaStreamTrackMonitor(pc, mst) {
//     this.pc = pc;
//     this.mst = mst;
//     mst.addEventListener('started', function () {
//         log.verbose('stats-monitor', 'mst: onstarted');
//     });
//     mst.addEventListener('mute', function () {
//         log.verbose('stats-monitor', 'mst: onmute');
//     });
//     mst.addEventListener('unmute', function () {
//         log.verbose('stats-monitor', 'mst: onunmute');
//     });
//     mst.addEventListener('overconstrained', function () {
//         log.verbose('stats-monitor', 'mst: onoverconstrained: ' + JSON.stringify(mst.getConstraints()));
//     });
//     mst.addEventListener('ended', function () {
//         log.verbose('stats-monitor', 'mst: onended');
//     });
// }
//
// function MediaStreamMonitor(pc, ms) {
//     var self = this;
//     this.pc = pc;
//     this.ms = ms;
//     this.mediaStreamTracks = {};
//     ms.addEventListener('active', function () {
//         log.verbose('stats-monitor', 'ms: onactive');
//     });
//     ms.addEventListener('addtrack', function (e) {
//         log.verbose('stats-monitor', 'ms: onaddtrack: ' + e.track.id);
//         self.mediaStreamTracks[e.track.id] = new MediaStreamTrackMonitor(self, e.track);
//     });
//     ms.addEventListener('ended', function () {
//         log.verbose('stats-monitor', 'ms: onended');
//     });
//     ms.addEventListener('inactive', function () {
//         log.verbose('stats-monitor', 'ms: oninactive');
//     });
//     ms.addEventListener('removetrack', function (e) {
//         log.verbose('stats-monitor', 'ms: onremovetrack: ' + e.track.id);
//         delete self.mediaStreamTracks[e.track.id];
//     });
// }

var WEBRTC_MONITOR_REGEX_MSID_CHROME = /^a=ssrc:(\d+) msid:([-a-zA-Z0-9]+) ([-a-zA-Z0-9]+)$/;
var WEBRTC_MONITOR_REGEX_MSID_FIREFOX = /^a=msid:{([-a-zA-Z0-9]+)} {([-a-zA-Z0-9]+)}$/;
var WEBRTC_MONITOR_REGEX_MSLABEL = /^a=ssrc:(\d+) mslabel:([-a-zA-Z0-9]+)$/;
var WEBRTC_MONITOR_REGEX_LABEL = /^a=ssrc:(\d+) label:(?:{)([-a-zA-Z0-9]+)(?:})$/;
var WEBRTC_MONITOR_REGEX_CNAME = /^a=ssrc:(\d+) cname:(?:{)([-a-zA-Z0-9]+)(?:})$/;

function parseIdentities(sdp, identities) {
  var ids = {};
  ids.ssrcs = [];
  var blocks = sdp.split(/(?=^m=)/mig);
  for (var block in blocks) {
    var lines = blocks[block].split(/\r?\n/);
    var msidTemp = {};
    for (var line = 0; line < lines.length; line += 1) {
      var sdpMsIdC = lines[line].match(WEBRTC_MONITOR_REGEX_MSID_CHROME);
      if (sdpMsIdC) {
        if (!(sdpMsIdC[1] in ids.ssrcs)) {
          ids.ssrcs.push(sdpMsIdC[1]);
        }
        ids.msid = sdpMsIdC[2];
        ids.mstid = sdpMsIdC[3];
      }
      var sdpMsIdF = lines[line].match(WEBRTC_MONITOR_REGEX_MSID_FIREFOX);
      if (sdpMsIdF) {
        if (ids.ssrc) {
          ids.msid = sdpMsIdF[1];
          ids.mstid = sdpMsIdF[2];
        } else {
          msidTemp.msid = sdpMsIdF[1];
          msidTemp.mstid = sdpMsIdF[2];
        }
      }
      var sdpMsLabel = lines[line].match(WEBRTC_MONITOR_REGEX_MSLABEL);
      if (sdpMsLabel) {
        if (!(sdpMsLabel[1] in ids.ssrcs)) {
          ids.ssrcs.push(sdpMsLabel[1]);
        }
        ids.msid = sdpMsLabel[2];
      }
      var sdpLabel = lines[line].match(WEBRTC_MONITOR_REGEX_LABEL);
      if (sdpLabel) {
        if (!(sdpLabel[1] in ids.ssrcs)) {
          ids.ssrcs.push(sdpLabel[1]);
        }
        ids.mstid = sdpLabel[2];
      }
      var sdpCname = lines[line].match(WEBRTC_MONITOR_REGEX_CNAME);
      if (sdpCname) {
        if (!(sdpCname[1] in ids.ssrcs)) {
          ids.ssrcs.push(sdpCname[1]);
        }
        ids.cname = sdpCname[2];
        if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(msidTemp).length) {
          ids.msid = msidTemp.msid;
          ids.mstid = msidTemp.mstid;
          msidTemp = {};
        }
      }
    }
    if (__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(ids.ssrcs).length) {
      for (var ssrc in ids.ssrcs) {
        identities[ids.ssrcs[ssrc]] = {};
        for (var id in ids) {
          if (id === 'ssrcs') {
            continue;
          }
          identities[ids.ssrcs[ssrc]][id] = ids[id];
        }
      }
    }
    ids = {};
    ids.ssrcs = [];
  }
  return identities;
}

function reportGenericStat(formatter, identities, stat) {
  var sample = {
    timestamp: Date.now(),
    pcId: identities.pcId
  };

  sample = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["assign"])(sample, stat);

  formatter.handleStats([sample]);
}

var PEER_CONNECTION_MONITOR_CANDIDATE_RE = new RegExp('' + '^candidate:(\\d+) (\\d) (UDP|TCP) ([\\d\\.]*) ([\\d\\.a-f\\:]*) (\\d*) ' + 'typ ([a-z]*)( raddr ([\\d\\.a-f\\:]*) rport (\\d*))?( tcptype (active|passive|so))?.*$', 'mi');

function parseCandidateString(candidateString) {
  var candidate = null;
  var candidateMatches = candidateString.match(PEER_CONNECTION_MONITOR_CANDIDATE_RE);
  if (candidateMatches) {
    candidate = {
      'foundation': candidateMatches[1],
      'componentId': parseInt(candidateMatches[2]),
      'transport': candidateMatches[3].toUpperCase(),
      'priority': parseInt(candidateMatches[4]),
      'address': candidateMatches[5],
      'port': parseInt(candidateMatches[6]),
      'type': candidateMatches[7]
    };
    if (candidateMatches[9]) {
      candidate.relatedAddress = candidateMatches[9];
    }
    if (!isNaN(candidateMatches[10])) {
      candidate.relatedPort = parseInt(candidateMatches[10]);
    }
    if (candidateMatches[12]) {
      candidate.tcpType = candidateMatches[12];
    } else if (candidate.transport === 'TCP') {
      if (candidate.port === 0 || candidate.port === 9) {
        candidate.tcpType = 'active';
        candidate.port = 9;
      } else {
        return;
      }
    }
  }
  return candidate;
}

function reportCandidate(formatter, identities, rtcicecandidate, localOrRemote) {
  var candidate = parseCandidateString(rtcicecandidate.candidate);
  if (!candidate) {
    return;
  }
  var report = {
    sourceId: 'candidates',
    localOrRemote: localOrRemote
  };
  report = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["assign"])(report, candidate);
  reportGenericStat(formatter, identities, report);
}

var PEER_CONNECTION_MONITOR_INTERNAL_MS = 1000;
var PEER_CONNECTION_MONITOR_ICE_CHECKING_TIMEOUT_MS = 15000;

function attachPeerConnectionMonitor(pc, formatter, reportIntervalMs) {
  var tag = 'stats-monitor';
  var callSucceeded = null;

  var reportInterval = 0;
  reportIntervalMs = reportIntervalMs || PEER_CONNECTION_MONITOR_INTERNAL_MS;

  var identities = {
    isRelay: false,
    pcId: pc.id
  };

  pc.addEventListener('signalingstatechange', function () {
    if (pc.signalingState === 'closed') {
      __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].debug(tag, 'stopped gather stats for ' + pc.id);
      return clearInterval(reportInterval);
    }

    if (pc._pc.localDescription) {
      identities = parseIdentities(pc._pc.localDescription.sdp, identities);
    }
    if (pc._pc.remoteDescription) {
      identities = parseIdentities(pc._pc.remoteDescription.sdp, identities);
    }
  });

  var normalizePeerConnectionStats = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_webrtc_statsNormalizer__["a" /* default */])();
  var iceCheckingTimeout;

  pc.addEventListener('iceconnectionstatechange', function () {
    var iceConnectionState = pc.iceConnectionState;
    reportGenericStat(formatter, identities, {
      sourceId: 'iceConnectionState',
      iceConnectionState: iceConnectionState
    });
    if (iceCheckingTimeout) {
      clearTimeout(iceCheckingTimeout);
      iceCheckingTimeout = null;
    }
    if (callSucceeded === null) {
      if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {
        callSucceeded = true;
        reportGenericStat(formatter, identities, {
          sourceId: 'events',
          eventType: 'callSetupResult',
          callSucceeded: true
        });

        pc.getStats(null).then(function (stats) {
          var normalizedStats = normalizePeerConnectionStats(stats, identities);
          for (var i in normalizedStats) {
            var stat = normalizedStats[i];
            if ('localIpAddress' in stat) {
              reportGenericStat(formatter, identities, stat);
              if ('localCandidateType' in stat) {
                identities.isRelay = stat.localCandidateType === 'relayed';
              }
            }
          }
        }).catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].warning(tag, 'getStats error:', error);
        });
      }
      if (iceConnectionState === 'failed') {
        callSucceeded = false;
        reportGenericStat(formatter, identities, {
          sourceId: 'events',
          eventType: 'callSetupResult',
          callSucceeded: false
        });
      }
      if (iceConnectionState === 'checking' && !iceCheckingTimeout) {
        iceCheckingTimeout = setTimeout(function () {
          callSucceeded = false;
          reportGenericStat(formatter, identities, {
            sourceId: 'events',
            eventType: 'callSetupResult',
            callSucceeded: false
          });
        }, PEER_CONNECTION_MONITOR_ICE_CHECKING_TIMEOUT_MS);
      }
    }
  });

  pc.addEventListener('icecandidate', function (event) {
    if (!event.candidate) {
      return;
    }
    reportCandidate(formatter, identities, event.candidate, 'local');
  });

  var realAddIceCandidate = pc.addIceCandidate;
  function addIceCandidate(candidate) {
    reportCandidate(formatter, identities, candidate, 'remote');
    return realAddIceCandidate.call(pc, candidate);
  }
  pc.addIceCandidate = addIceCandidate;

  reportInterval = setInterval(function () {
    pc.getStats(null).then(function (stats) {
      var normalizedStats = normalizePeerConnectionStats(stats, identities);
      formatter.handleStats(normalizedStats);
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].warning(tag, 'getStats error:', error);
    });
  }, reportIntervalMs);
}

/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = parseCandidateInfo;
/* harmony export (immutable) */ __webpack_exports__["c"] = filterSdpCandidates;
/* harmony export (immutable) */ __webpack_exports__["d"] = workaroundSdpBundleBug;
/* harmony export (immutable) */ __webpack_exports__["e"] = extractApplicationBlock;
/* harmony export (immutable) */ __webpack_exports__["i"] = injectApplicationBlock;
/* harmony export (immutable) */ __webpack_exports__["f"] = readMediaModeUnions;
/* harmony export (immutable) */ __webpack_exports__["g"] = overrideMediaModes;
/* harmony export (immutable) */ __webpack_exports__["h"] = rewriteBundleAttribute;
/* harmony export (immutable) */ __webpack_exports__["b"] = disableSendBandwidthEstimation;
/* harmony export (immutable) */ __webpack_exports__["j"] = removeChromeRetransmission;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);






var TAG = 'peer-connection';

var candidateRegExp = new RegExp('^candidate:(\\d+) (\\d) (UDP|TCP) ([\\d\\.]*) ([\\d\\.a-f\\:]*) (\\d*)' + ' typ ([a-z]*)( raddr ([\\d\\.a-f\\:]*) rport (\\d*))?' + '( tcptype (active|passive|so))?(.*)$', 'i');
var bundleAttributeRegExp = new RegExp('^a=group:BUNDLE (.*)$', 'mi');

/**
 * @typedef IceCandidateInfo
 *
 * An object containing information about an ICE candidate.
 *
 * More information can be found in [RFC 5245](https://tools.ietf.org/html/rfc5245) and
 * [RFC 6544](https://tools.ietf.org/html/rfc6544).
 *
 * @property {string} foundation - The candidate foundation.
 * @property {number} componentId - The candidate component id, will almost always be 1 because of RTCP multiplexing.
 * @property {string} transport - The transport used, `'TCP'` or `'UDP'`.
 * @property {number} priority - The candidate priority.
 * @property {string} address - The candidate address.
 * @property {number} port - The candidate port.
 * @property {string} type - The candidate type, `'host'`, `'srflx'`, `'prflx'`, or `'relay'`.
 * @property {string} candidate - The original candidate line, always without attribute prefix (`a=`).
 * @property {string} origin - The origin of the candidate, `'local'` or `'remote'`.
 * @property {string} [relatedAddress] - The candidate related address, not used in host candidates.
 * @property {number} [relatedPort] - The candidate related port, not used in host candidates.
 * @property {string} [tcpType] - The candidate tcp type, `'active'`, `'passive'`, simultaneous-open, `'so'`.
 */

function parseCandidateInfo(line, origin) {
  var match = line.match(candidateRegExp);
  if (!match) {
    throw new Error('Could not parse ' + origin + ' ice candidate: ' + line);
  }
  var info = {
    foundation: match[1],
    componentId: parseInt(match[2]),
    transport: match[3].toUpperCase(),
    priority: parseInt(match[4]),
    address: match[5],
    port: parseInt(match[6]),
    type: match[7],
    candidate: line,
    origin: origin
  };
  if (match[9]) {
    info.relatedAddress = match[9];
  }
  if (!isNaN(match[10])) {
    info.relatedPort = parseInt(match[10]);
  }
  if (match[12]) {
    info.tcpType = match[12];
  } else if (info.transport === 'TCP') {
    if (info.port === 0 || info.port === 9) {
      info.tcpType = 'active';
      info.port = 9;
    } else {
      return;
    }
  }
  return info;
}

function filterSdpCandidates(sdp, filter, origin) {
  if (!sdp) {
    return sdp;
  }
  return sdp.split(/\r\n/).filter(function (line) {
    if (line.indexOf('a=candidate:') === 0) {
      try {
        var candidate = line.slice(2);
        var info = parseCandidateInfo(candidate, origin);
        if (!filter(info)) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].verbose(TAG, 'ignored candidate due to being filtered out: ' + candidate);
          return false;
        }
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'ignoring candidate, error was thrown in candidate filter: ' + error);
        return false;
      }
    }
    return true;
  }).join('\r\n');
}

function workaroundSdpBundleBug(sdp) {
  if (sdp.match(bundleAttributeRegExp)) {
    // If the SDP already has a group attribute, we don't need to do anything
    return sdp;
  }
  return rewriteBundleAttribute(sdp);
}

function extractApplicationBlock(sdp) {
  var _sdp$split = sdp.split(blockSplitRegExp),
      _sdp$split2 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default()(_sdp$split),
      sessionBlock = _sdp$split2[0],
      mediaBlocks = _sdp$split2.slice(1);

  var applicationMBlockIndex = -1;
  for (var index in mediaBlocks) {
    if (mediaBlocks[index].indexOf('m=application') === 0) {
      applicationMBlockIndex = +index;
      break;
    }
  }

  if (applicationMBlockIndex === -1) {
    return [sdp, null];
  }

  var _ref = mediaBlocks[applicationMBlockIndex].match(/a=mid:(.*)/mi) || [],
      _ref2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_ref, 2),
      applicationMId = _ref2[1];

  if (!applicationMId) {
    throw new Error('sdp application block does not have an mId');
  }

  var newSessionBlock = sessionBlock.replace(bundleAttributeRegExp, function (_, mIdsStr) {
    var mIds = mIdsStr.split(' ');
    var index = mIds.indexOf(applicationMId);
    if (index === -1) {
      throw new Error('sdp group:BUNDLE attribute did not contain application block mId');
    }
    mIds.splice(index, 1);
    return 'a=group:BUNDLE ' + mIds.join(' ');
  });

  var applicationMBlock = mediaBlocks.splice(applicationMBlockIndex, 1)[0];
  var newSdp = newSessionBlock + mediaBlocks.join('');
  return [newSdp, {
    block: applicationMBlock,
    index: applicationMBlockIndex,
    applicationMId: applicationMId,
    needsInteropTranslation: !!mediaBlocks.length
  }];
}

function injectApplicationBlock(sdp, extractedBlock) {
  if (!extractedBlock) {
    return sdp;
  }

  var _sdp$split3 = sdp.split(blockSplitRegExp),
      _sdp$split4 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default()(_sdp$split3),
      sessionBlock = _sdp$split4[0],
      mediaBlocks = _sdp$split4.slice(1);

  var newSessionBlock = sessionBlock.replace(bundleAttributeRegExp, function (_, mIdsStr) {
    var mIds = mIdsStr ? mIdsStr.split(' ') : [];
    mIds.splice(extractedBlock.index, 0, extractedBlock.applicationMId);
    return 'a=group:BUNDLE ' + mIds.join(' ');
  });

  mediaBlocks.splice(extractedBlock.index, 0, extractedBlock.block);
  return newSessionBlock + mediaBlocks.join('');
}

var modeRegExp = new RegExp('^a=(inactive|recvonly|sendonly|sendrecv)$', 'mi');
var blockSplitRegExp = new RegExp('(?=m=(?:audio|video|application))', 'i');
var mediaTypeRegExp = new RegExp('^m=(audio|video|application)', 'i');

var modeValues = {
  inactive: 0,
  sendonly: 1,
  recvonly: 2,
  sendrecv: 3
};
var modeNames = {
  0: 'inactive',
  1: 'sendonly',
  2: 'recvonly',
  3: 'sendrecv'
};

function readMediaModeUnions(sdp) {
  var _sdp$split5 = sdp.split(blockSplitRegExp),
      _sdp$split6 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default()(_sdp$split5),
      sessionBlock = _sdp$split6[0],
      mediaBlocks = _sdp$split6.slice(1);
  // the mode above the media blocks is used if a media block doesn't have it's own mode


  var _ref3 = sessionBlock.match(modeRegExp) || [],
      _ref4 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_ref3, 2),
      _ref4$ = _ref4[1],
      defaultModeName = _ref4$ === undefined ? 'sendrecv' : _ref4$;

  var audioModeValue = modeValues.inactive;
  var videoModeValue = modeValues.inactive;
  var applicationModeValue = modeValues.inactive;

  mediaBlocks.forEach(function (mediaBlock) {
    var _mediaBlock$match = mediaBlock.match(mediaTypeRegExp),
        _mediaBlock$match2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_mediaBlock$match, 2),
        mediaType = _mediaBlock$match2[1];

    var _ref5 = mediaBlock.match(modeRegExp) || [],
        _ref6 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_ref5, 2),
        _ref6$ = _ref6[1],
        modeName = _ref6$ === undefined ? defaultModeName : _ref6$;

    var modeValue = modeValues[modeName];
    if (mediaType === 'audio') {
      audioModeValue |= modeValue;
    } else if (mediaType === 'video') {
      videoModeValue |= modeValue;
    } else if (mediaType === 'application') {
      applicationModeValue |= modeValue;
    }
  });

  return {
    audio: modeNames[audioModeValue],
    video: modeNames[videoModeValue],
    application: modeNames[applicationModeValue]
  };
}

function overrideMediaModes(sdp, mediaModes) {
  var _sdp$split7 = sdp.split(blockSplitRegExp),
      _sdp$split8 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default()(_sdp$split7),
      sessionBlock = _sdp$split8[0],
      mediaBlocks = _sdp$split8.slice(1);

  mediaBlocks = mediaBlocks.map(function (mediaBlock) {
    var _mediaBlock$match3 = mediaBlock.match(mediaTypeRegExp),
        _mediaBlock$match4 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_mediaBlock$match3, 2),
        mediaType = _mediaBlock$match4[1];

    var modeName = mediaModes[mediaType] || modeNames[3]; // default to sendrecv
    return mediaBlock.replace(modeRegExp, 'a=' + modeName);
  });

  return [sessionBlock].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(mediaBlocks)).join('');
}

// This rewrites the bundle attribute according to the actual media blocks in the sdp
function rewriteBundleAttribute(sdp) {
  var _sdp$split9 = sdp.split(blockSplitRegExp),
      _sdp$split10 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default()(_sdp$split9),
      sessionBlock = _sdp$split10[0],
      mediaBlocks = _sdp$split10.slice(1);

  var mIds = mediaBlocks.map(function (mediaBlock) {
    var _ref7 = mediaBlock.match(/^a=mid:(.+)$/mi) || [],
        _ref8 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_ref7, 2),
        mId = _ref8[1];

    if (!mId) {
      var _mediaBlock$match5 = mediaBlock.match(mediaTypeRegExp),
          _mediaBlock$match6 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_mediaBlock$match5, 2),
          mediaType = _mediaBlock$match6[1];

      throw new Error('media block of type ' + mediaType + ' did not contain mid attribute');
    }
    return mId;
  });

  mIds.unshift(''); // conditional padding weith space after BUNDLE
  var bundleAttribute = 'a=group:BUNDLE' + mIds.join(' ');

  if (sessionBlock.match(bundleAttributeRegExp)) {
    sessionBlock = sessionBlock.replace(bundleAttributeRegExp, bundleAttribute);
  } else {
    sessionBlock += bundleAttribute + '\r\n';
  }
  return [sessionBlock].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(mediaBlocks)).join('');
}

var bweRegExp = new RegExp('a=extmap:5 ' + 'http://www\\.ietf\\.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01' + '\r\n', 'gi');

// Chrome 58 and 59 has a broken bandwidth estimation implementation that
// doesn't detect when packets are sent using TURN/TCP. This results in
// the estimated bandwidth to always end up at 10kbps.
// The fix we use is to always disable the new bandwidth estimation algorithm
// for all connections.
function disableSendBandwidthEstimation(sdp) {
  return sdp.replace(bweRegExp, '');
}

var ssrcGroupRegExp = new RegExp('a=ssrc-group:.+\\s\\d+\\s(\\d+)' + '\r\n', 'gi');
var rtxPayloadTypeRegExp = new RegExp('a=(?:fmtp:\\d+\\sapt=\\d+|rtpmap:\\d+\\srtx/\\d+)' + '\r\n', 'gi');

// Removes retransmission information from a Chrome-style (Plan B) SDPs.
// This includes rtpmap and fmtp attributes with rtx/apt values, ssrc-group
// attributes, and the ssrc attributes for the ssrcs used for retransmission.
function removeChromeRetransmission(sdp) {
  var _sdp$split11 = sdp.split(blockSplitRegExp),
      _sdp$split12 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_toArray___default()(_sdp$split11),
      sessionBlock = _sdp$split12[0],
      mediaBlocks = _sdp$split12.slice(1);

  var modifiedMediaBlocks = mediaBlocks.map(function (mediaBlock) {
    var _mediaBlock$match7 = mediaBlock.match(mediaTypeRegExp),
        _mediaBlock$match8 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_mediaBlock$match7, 2),
        mediaType = _mediaBlock$match8[1];

    if (mediaType !== 'video') {
      return mediaBlock;
    }
    var removedSsrcs = [];

    var withoutSsrcGroups = mediaBlock.replace(ssrcGroupRegExp, function (_, ssrc) {
      // We assume the second SSRC is used for retransmission
      removedSsrcs.push(ssrc);
      return '';
    });
    var ssrcRegExp = new RegExp('a=ssrc:(?:' + removedSsrcs.join('|') + ')\\s.*\r\n', 'gi');
    var withoutSsrcs = withoutSsrcGroups.replace(ssrcRegExp, '');
    var withoutRtxPayloadTypes = withoutSsrcs.replace(rtxPayloadTypeRegExp, '');
    return withoutRtxPayloadTypes;
  });

  return [sessionBlock].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(modifiedMediaBlocks)).join('');
}

/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = StatsFormatter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_utils__ = __webpack_require__(13);




function StatsFormatter(context, reporter) {
  this.context = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_common_utils__["assign"])({}, context);
  this.context.contextId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_common_utils__["randomString"])(16);
  this.context.userAgent = navigator.userAgent;
  this.reporter = reporter;
  this.tag = 'stats-formatter';
}

StatsFormatter.prototype.setPeerId = function (peerId) {
  this.context.peerId = peerId;
};

StatsFormatter.prototype.handleStats = function (stats) {
  for (var i in stats) {
    stats[i] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_common_utils__["assign"])(stats[i], this.context);
  }
  this.reporter.handleStats(stats);
};

/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createPeerConnectionStatNormalizer;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_utils__ = __webpack_require__(13);





var STATS_OBJ_REGEX_FIREFOX = /(in|out)bound_(rtp|rtcp)_(audio|video)_(\d+)/;
var STATS_KEY_BLACKLIST_FIREFOX = ['id', 'type', 'isRemote', 'remoteId'];

var STATS_OBJ_REGEX_CHROME = /(ssrc)_(\d+)_(recv|send)/;
var STATS_KEY_BLACKLIST_CHROME = ['id', 'type', 'googTrackId', 'transportId'];

function normalizeStatsMatchFirefox(statKey, stat) {
  var sample = {};
  var matchFirefox = statKey.match(STATS_OBJ_REGEX_FIREFOX);
  if (matchFirefox) {
    switch (matchFirefox[1]) {
      case 'in':
        sample.role = 'receiver';
        break;
      case 'out':
        sample.role = 'sender';
        break;
      default:
        __WEBPACK_IMPORTED_MODULE_0_common_log__["default"].warning('stats-normalizer', 'No role match!');
        return null;
    }
    switch (matchFirefox[2]) {
      case 'rtp':
        sample.reportType = sample.role === 'receiver' ? 'receiver' : 'sender';
        break;
      case 'rtcp':
        sample.reportType = sample.role === 'receiver' ? 'sender' : 'receiver';
        break;
      default:
        __WEBPACK_IMPORTED_MODULE_0_common_log__["default"].warning('stats-normalizer', 'No reportType match!');
        return null;
    }

    for (var k in stat) {
      if (STATS_KEY_BLACKLIST_FIREFOX.indexOf(k) >= 0) {
        continue;
      }
      sample[k] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["maybeConvertStringToNumber"])(stat[k].toString());
    }
    return sample;
  }
}

function normalizeStatsMatchChrome(statKey, stat) {
  var sample = {};
  var matchChrome = statKey.match(STATS_OBJ_REGEX_CHROME);
  if (matchChrome) {
    switch (matchChrome[3]) {
      case 'recv':
        sample.role = 'receiver';
        sample.reportType = 'receiver';
        break;
      case 'send':
        sample.role = 'sender';
        sample.reportType = 'sender';
        break;
      default:
        __WEBPACK_IMPORTED_MODULE_0_common_log__["default"].warning('stats-normalizer', 'No role match!');
        return null;
    }

    for (var k in stat) {
      if (STATS_KEY_BLACKLIST_CHROME.indexOf(k) >= 0) {
        continue;
      }
      sample[k] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["maybeConvertStringToNumber"])(stat[k].toString());
      // FIXME - set the mediaType from an ssrc lookup after parsing the sdp
      if (k === 'audioInputLevel' || k === 'audioOutputLevel') {
        sample.mediaType = 'audio';
      } else if (k === 'googFrameHeightReceived' || k === 'googFrameHeightSent') {
        sample.mediaType = 'video';
      } else {
        continue;
      }
    }
    return sample;
  }
}

var candidatePairKeys = ['portNumber', 'ipAddress', 'transport', 'candidateType'];
function assignCandidatePairValues(stat, localOrRemote, sample) {
  for (var i in candidatePairKeys) {
    var key = candidatePairKeys[i];
    if (key in stat) {
      var destKey = localOrRemote + key.charAt(0).toUpperCase() + key.slice(1);
      sample[destKey] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["maybeConvertStringToNumber"])(stat[key]);
    }
  }
  return sample;
}

function getSelectedPairSampleFromStats(stats, stat, browser) {
  var localCandidateId = stat.localCandidateId;
  var remoteCandidateId = stat.remoteCandidateId;
  var localStat = stats[localCandidateId];
  var remoteStat = stats[remoteCandidateId];

  var sample = {};

  sample.sourceId = 'selectedPair';

  sample = assignCandidatePairValues(localStat, 'local', sample);
  sample = assignCandidatePairValues(remoteStat, 'remote', sample);
  if (browser === 'chrome') {
    sample.localPriority = +localStat.priority;
    sample.remotePriority = +remoteStat.priority;
  }
  if (browser === 'firefox') {
    sample.localPriority = +stat.priority;
    sample.remotePriority = +stat.priority;
  }

  return sample;
}

function createPeerConnectionStatNormalizer() {
  var selectedPairs = {};

  function normalizeSsrcStats(stats, identities) {
    var samples = [];
    var sampleTsMs = Date.now();

    for (var i in stats) {
      var stat = stats[i];
      var sample = null;
      var ssrc = stat.ssrc;
      if (!ssrc) {
        continue;
      }
      var identity = identities[ssrc];
      if (!identity) {
        __WEBPACK_IMPORTED_MODULE_0_common_log__["default"].warning('stat-normalizer', 'got stat without identity:', stat);
        continue;
      }

      if (__WEBPACK_IMPORTED_MODULE_1_common_utils__["isFirefox"]) {
        sample = normalizeStatsMatchFirefox(i, stat);
      }
      if (__WEBPACK_IMPORTED_MODULE_1_common_utils__["isChrome"]) {
        sample = normalizeStatsMatchChrome(i, stat);
      }
      if (!sample) {
        continue;
      }

      if (sample.timestamp) {
        sample.getStatsTs = sample.timestamp;
        delete sample.timestamp;
      }

      sample.timestamp = sampleTsMs;
      sample.pcId = identities.pcId;
      sample.isRelay = identities.isRelay;

      sample = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["assign"])(sample, identity);
      sample.sourceId = 'ssrc-' + ssrc;

      samples.push(sample);
    }

    return samples;
  }

  function normalizeSelectedPairStats(stats, identities) {
    var samples = [];
    var sampleTsMs = Date.now();
    var newSelectedPairs = {};

    for (var i in stats) {
      var stat = stats[i];
      var sample = null;

      if (stat.type === 'candidatepair' && stat.selected === true && stat.state === 'succeeded') {
        sample = getSelectedPairSampleFromStats(stats, stat, 'firefox');
      }
      if (stat.type === 'googCandidatePair' && stat.googActiveConnection === 'true') {
        sample = getSelectedPairSampleFromStats(stats, stat, 'chrome');
      }

      if (!sample) {
        continue;
      }

      sample.timestamp = sampleTsMs;
      sample.pcId = identities.pcId;
      sample.isRelay = identities.isRelay;

      var newSelectedPair = stat.localCandidateId + stat.remoteCandidateId;
      if (!(newSelectedPair in newSelectedPairs)) {
        newSelectedPairs[newSelectedPair] = [];
      }
      newSelectedPairs[newSelectedPair].push(sample);
    }

    for (var oldPair in selectedPairs) {
      if (!(oldPair in newSelectedPairs)) {
        delete selectedPairs[oldPair];
      }
    }
    for (var newPair in newSelectedPairs) {
      if (!(newPair in selectedPairs)) {
        selectedPairs[newPair] = true;
        [].push.apply(samples, newSelectedPairs[newPair]);
      }
    }

    return samples;
  }

  return function normalizePeerConnectionStats(stats, identities) {
    var samples = [];

    samples = normalizeSsrcStats(stats, identities);
    [].push.apply(samples, normalizeSelectedPairStats(stats, identities));

    return samples;
  };
}

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(203);
var $Object = __webpack_require__(0).Object;
module.exports = function defineProperties(T, D){
  return $Object.defineProperties(T, D);
};

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(6);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(11), 'Object', {defineProperties: __webpack_require__(95)});

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/*! adapterjs - v0.14.3-6d236da - 2017-05-24 */
var AdapterJS=AdapterJS||{};AdapterJS.options=AdapterJS.options||{},AdapterJS.VERSION="0.14.3-6d236da",AdapterJS.onwebrtcready=AdapterJS.onwebrtcready||function(isUsingPlugin){},AdapterJS._onwebrtcreadies=[],AdapterJS.webRTCReady=function(baseCallback){if("function"!=typeof baseCallback)throw new Error("Callback provided is not a function");var callback=function(){"function"==typeof window.require&&"function"==typeof AdapterJS._defineMediaSourcePolyfill&&AdapterJS._defineMediaSourcePolyfill(),baseCallback(null!==AdapterJS.WebRTCPlugin.plugin)};!0===AdapterJS.onwebrtcreadyDone?callback():AdapterJS._onwebrtcreadies.push(callback)},AdapterJS.WebRTCPlugin=AdapterJS.WebRTCPlugin||{},AdapterJS.WebRTCPlugin.pluginInfo=AdapterJS.WebRTCPlugin.pluginInfo||{prefix:"Tem",plugName:"TemWebRTCPlugin",pluginId:"plugin0",type:"application/x-temwebrtcplugin",onload:"__TemWebRTCReady0",portalLink:"https://skylink.io/plugin/",downloadLink:null,companyName:"Temasys",downloadLinks:{mac:"https://bit.ly/webrtcpluginpkg",win:"https://bit.ly/webrtcpluginmsi"}},"undefined"!=typeof AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks&&null!==AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks&&(navigator.platform.match(/^Mac/i)?AdapterJS.WebRTCPlugin.pluginInfo.downloadLink=AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.mac:navigator.platform.match(/^Win/i)&&(AdapterJS.WebRTCPlugin.pluginInfo.downloadLink=AdapterJS.WebRTCPlugin.pluginInfo.downloadLinks.win)),AdapterJS.WebRTCPlugin.TAGS={NONE:"none",AUDIO:"audio",VIDEO:"video"},AdapterJS.WebRTCPlugin.pageId=Math.random().toString(36).slice(2),AdapterJS.WebRTCPlugin.plugin=null,AdapterJS.WebRTCPlugin.setLogLevel=null,AdapterJS.WebRTCPlugin.defineWebRTCInterface=null,AdapterJS.WebRTCPlugin.isPluginInstalled=null,AdapterJS.WebRTCPlugin.pluginInjectionInterval=null,AdapterJS.WebRTCPlugin.injectPlugin=null,AdapterJS.WebRTCPlugin.PLUGIN_STATES={NONE:0,INITIALIZING:1,INJECTING:2,INJECTED:3,READY:4},AdapterJS.WebRTCPlugin.pluginState=AdapterJS.WebRTCPlugin.PLUGIN_STATES.NONE,AdapterJS.onwebrtcreadyDone=!1,AdapterJS.WebRTCPlugin.PLUGIN_LOG_LEVELS={NONE:"NONE",ERROR:"ERROR",WARNING:"WARNING",INFO:"INFO",VERBOSE:"VERBOSE",SENSITIVE:"SENSITIVE"},AdapterJS.WebRTCPlugin.WaitForPluginReady=null,AdapterJS.WebRTCPlugin.callWhenPluginReady=null,__TemWebRTCReady0=function(){if("complete"===document.readyState)AdapterJS.WebRTCPlugin.pluginState=AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY,AdapterJS.maybeThroughWebRTCReady();else var timer=setInterval(function(){"complete"===document.readyState&&(clearInterval(timer),AdapterJS.WebRTCPlugin.pluginState=AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY,AdapterJS.maybeThroughWebRTCReady())},100)},AdapterJS.maybeThroughWebRTCReady=function(){AdapterJS.onwebrtcreadyDone||(AdapterJS.onwebrtcreadyDone=!0,AdapterJS._onwebrtcreadies.length?AdapterJS._onwebrtcreadies.forEach(function(callback){"function"==typeof callback&&callback(null!==AdapterJS.WebRTCPlugin.plugin)}):"function"==typeof AdapterJS.onwebrtcready&&AdapterJS.onwebrtcready(null!==AdapterJS.WebRTCPlugin.plugin))},AdapterJS.TEXT={PLUGIN:{REQUIRE_INSTALLATION:"This website requires you to install a WebRTC-enabling plugin to work on this browser.",NOT_SUPPORTED:"Your browser does not support WebRTC.",BUTTON:"Install Now"},REFRESH:{REQUIRE_REFRESH:"Please refresh page",BUTTON:"Refresh Page"}},AdapterJS._iceConnectionStates={starting:"starting",checking:"checking",connected:"connected",completed:"connected",done:"completed",disconnected:"disconnected",failed:"failed",closed:"closed"},AdapterJS._iceConnectionFiredStates=[],AdapterJS.isDefined=null,AdapterJS.parseWebrtcDetectedBrowser=function(){var hasMatch=null;if(window.opr&&opr.addons||window.opera||navigator.userAgent.indexOf(" OPR/")>=0)hasMatch=navigator.userAgent.match(/OPR\/(\d+)/i)||[],webrtcDetectedBrowser="opera",webrtcDetectedVersion=parseInt(hasMatch[1]||"0",10),webrtcMinimumVersion=26,webrtcDetectedType="webkit",webrtcDetectedDCSupport="SCTP";else if(navigator.userAgent.match(/Bowser\/[0-9.]*/g)){hasMatch=navigator.userAgent.match(/Bowser\/[0-9.]*/g)||[];var chromiumVersion=parseInt((navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./i)||[])[2]||"0",10);webrtcDetectedBrowser="bowser",webrtcDetectedVersion=parseFloat((hasMatch[0]||"0/0").split("/")[1],10),webrtcMinimumVersion=0,webrtcDetectedType="webkit",webrtcDetectedDCSupport=chromiumVersion>30?"SCTP":"RTP"}else if(navigator.userAgent.indexOf("OPiOS")>0)hasMatch=navigator.userAgent.match(/OPiOS\/([0-9]+)\./),webrtcDetectedBrowser="opera",webrtcDetectedVersion=parseInt(hasMatch[1]||"0",10),webrtcMinimumVersion=0,webrtcDetectedType=null,webrtcDetectedDCSupport=null;else if(navigator.userAgent.indexOf("CriOS")>0)hasMatch=navigator.userAgent.match(/CriOS\/([0-9]+)\./)||[],webrtcDetectedBrowser="chrome",webrtcDetectedVersion=parseInt(hasMatch[1]||"0",10),webrtcMinimumVersion=0,webrtcDetectedType=null,webrtcDetectedDCSupport=null;else if(navigator.userAgent.indexOf("FxiOS")>0)hasMatch=navigator.userAgent.match(/FxiOS\/([0-9]+)\./)||[],webrtcDetectedBrowser="firefox",webrtcDetectedVersion=parseInt(hasMatch[1]||"0",10),webrtcMinimumVersion=0,webrtcDetectedType=null,webrtcDetectedDCSupport=null;else if(document.documentMode)hasMatch=/\brv[ :]+(\d+)/g.exec(navigator.userAgent)||[],webrtcDetectedBrowser="IE",webrtcDetectedVersion=parseInt(hasMatch[1],10),webrtcMinimumVersion=9,webrtcDetectedType="plugin",webrtcDetectedDCSupport="SCTP",webrtcDetectedVersion||(hasMatch=/\bMSIE[ :]+(\d+)/g.exec(navigator.userAgent)||[],webrtcDetectedVersion=parseInt(hasMatch[1]||"0",10));else if(window.StyleMedia||navigator.userAgent.match(/Edge\/(\d+).(\d+)$/))hasMatch=navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)||[],webrtcDetectedBrowser="edge",webrtcDetectedVersion=parseFloat((hasMatch[0]||"0/0").split("/")[1],10),webrtcMinimumVersion=13.10547,webrtcDetectedType="ms",webrtcDetectedDCSupport=null;else if("undefined"!=typeof InstallTrigger||navigator.userAgent.indexOf("irefox")>0)hasMatch=navigator.userAgent.match(/Firefox\/([0-9]+)\./)||[],webrtcDetectedBrowser="firefox",webrtcDetectedVersion=parseInt(hasMatch[1]||"0",10),webrtcMinimumVersion=33,webrtcDetectedType="moz",webrtcDetectedDCSupport="SCTP";else if(window.chrome&&window.chrome.webstore||navigator.userAgent.indexOf("Chrom")>0)hasMatch=navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./i)||[],webrtcDetectedBrowser="chrome",webrtcDetectedVersion=parseInt(hasMatch[2]||"0",10),webrtcMinimumVersion=38,webrtcDetectedType="webkit",webrtcDetectedDCSupport=webrtcDetectedVersion>30?"SCTP":"RTP";else if(/^((?!chrome|android).)*safari/i.test(navigator.userAgent)){hasMatch=navigator.userAgent.match(/version\/(\d+)/i)||[];var isMobile=navigator.userAgent.match(/(iPhone|iPad)/gi)||[];webrtcDetectedBrowser="safari",webrtcDetectedVersion=parseInt(hasMatch[1]||"0",10),webrtcMinimumVersion=7,webrtcDetectedType=0===isMobile.length?"plugin":null,webrtcDetectedDCSupport=0===isMobile.length?"SCTP":null}window.webrtcDetectedBrowser=webrtcDetectedBrowser,window.webrtcDetectedVersion=webrtcDetectedVersion,window.webrtcMinimumVersion=webrtcMinimumVersion,window.webrtcDetectedType=webrtcDetectedType,window.webrtcDetectedDCSupport=webrtcDetectedDCSupport},AdapterJS.addEvent=function(elem,evnt,func){elem.addEventListener?elem.addEventListener(evnt,func,!1):elem.attachEvent?elem.attachEvent("on"+evnt,func):elem[evnt]=func},AdapterJS.renderNotificationBar=function(message,buttonText,buttonCallback){if("complete"===document.readyState){var w=window,i=document.createElement("iframe");i.name="adapterjs-alert",i.style.position="fixed",i.style.top="-41px",i.style.left=0,i.style.right=0,i.style.width="100%",i.style.height="40px",i.style.backgroundColor="#ffffe1",i.style.border="none",i.style.borderBottom="1px solid #888888",i.style.zIndex="9999999","string"==typeof i.style.webkitTransition?i.style.webkitTransition="all .5s ease-out":"string"==typeof i.style.transition&&(i.style.transition="all .5s ease-out"),document.body.appendChild(i);var c=i.contentWindow?i.contentWindow:i.contentDocument.document?i.contentDocument.document:i.contentDocument;c.document.open(),c.document.write('<span style="display: inline-block; font-family: Helvetica, Arial,sans-serif; font-size: .9rem; padding: 4px; vertical-align: middle; cursor: default;">'+message+"</span>"),buttonText&&"function"==typeof buttonCallback?(c.document.write('<button id="okay">'+buttonText+'</button><button id="cancel">Cancel</button>'),c.document.close(),AdapterJS.addEvent(c.document.getElementById("okay"),"click",function(e){e.preventDefault();try{e.cancelBubble=!0}catch(error){}buttonCallback(e)}),AdapterJS.addEvent(c.document.getElementById("cancel"),"click",function(e){w.document.body.removeChild(i)})):c.document.close(),setTimeout(function(){"string"==typeof i.style.webkitTransform?i.style.webkitTransform="translateY(40px)":"string"==typeof i.style.transform?i.style.transform="translateY(40px)":i.style.top="0px"},300)}},webrtcDetectedType=null,checkMediaDataChannelSettings=function(peerBrowserAgent,peerBrowserVersion,callback,constraints){if("function"==typeof callback){var beOfferer=!0,isLocalFirefox="firefox"===webrtcDetectedBrowser,isLocalFirefoxInterop="moz"===webrtcDetectedType&&webrtcDetectedVersion>30,isPeerFirefox="firefox"===peerBrowserAgent;if(isLocalFirefox&&isPeerFirefox||isLocalFirefoxInterop)try{delete constraints.mandatory.MozDontOfferDataChannel}catch(error){}else isLocalFirefox&&!isPeerFirefox&&(constraints.mandatory.MozDontOfferDataChannel=!0);if(!isLocalFirefox)for(var prop in constraints.mandatory)constraints.mandatory.hasOwnProperty(prop)&&prop.indexOf("Moz")!==-1&&delete constraints.mandatory[prop];!isLocalFirefox||isPeerFirefox||isLocalFirefoxInterop||(beOfferer=!1),callback(beOfferer,constraints)}},checkIceConnectionState=function(peerId,iceConnectionState,callback){"function"==typeof callback&&(peerId=peerId?peerId:"peer",AdapterJS._iceConnectionFiredStates[peerId]&&iceConnectionState!==AdapterJS._iceConnectionStates.disconnected&&iceConnectionState!==AdapterJS._iceConnectionStates.failed&&iceConnectionState!==AdapterJS._iceConnectionStates.closed||(AdapterJS._iceConnectionFiredStates[peerId]=[]),iceConnectionState=AdapterJS._iceConnectionStates[iceConnectionState],AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState)<0&&(AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState),iceConnectionState===AdapterJS._iceConnectionStates.connected&&setTimeout(function(){AdapterJS._iceConnectionFiredStates[peerId].push(AdapterJS._iceConnectionStates.done),callback(AdapterJS._iceConnectionStates.done)},1e3),callback(iceConnectionState)))},createIceServer=null,createIceServers=null,MediaStream="function"==typeof MediaStream?MediaStream:null,RTCPeerConnection="function"==typeof RTCPeerConnection?RTCPeerConnection:null,RTCSessionDescription="function"==typeof RTCSessionDescription?RTCSessionDescription:null,RTCIceCandidate="function"==typeof RTCIceCandidate?RTCIceCandidate:null,getUserMedia=null,attachMediaStream=null,reattachMediaStream=null,webrtcDetectedBrowser=null,webrtcDetectedVersion=null,webrtcMinimumVersion=null,!(navigator.mozGetUserMedia||navigator.webkitGetUserMedia||navigator.mediaDevices&&navigator.userAgent.match(/Edge\/(\d+).(\d+)$/))||0===(navigator.userAgent.match(/android/gi)||[]).length&&0===(navigator.userAgent.match(/chrome/gi)||[]).length&&navigator.userAgent.indexOf("Safari/")>0?("object"==typeof console&&"function"==typeof console.log||(console={}||console,console.log=function(arg){},console.info=function(arg){},console.error=function(arg){},console.dir=function(arg){},console.exception=function(arg){},console.trace=function(arg){},console.warn=function(arg){},console.count=function(arg){},console.debug=function(arg){},console.count=function(arg){},console.time=function(arg){},console.timeEnd=function(arg){},console.group=function(arg){},console.groupCollapsed=function(arg){},console.groupEnd=function(arg){}),AdapterJS.parseWebrtcDetectedBrowser(),isIE="IE"===webrtcDetectedBrowser,AdapterJS.WebRTCPlugin.WaitForPluginReady=function(){for(;AdapterJS.WebRTCPlugin.pluginState!==AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY;);},AdapterJS.WebRTCPlugin.callWhenPluginReady=function(callback){if(AdapterJS.WebRTCPlugin.pluginState===AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY)callback();else var checkPluginReadyState=setInterval(function(){AdapterJS.WebRTCPlugin.pluginState===AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY&&(clearInterval(checkPluginReadyState),callback())},100)},AdapterJS.WebRTCPlugin.setLogLevel=function(logLevel){AdapterJS.WebRTCPlugin.callWhenPluginReady(function(){AdapterJS.WebRTCPlugin.plugin.setLogLevel(logLevel)})},AdapterJS.WebRTCPlugin.injectPlugin=function(){if("complete"===document.readyState&&AdapterJS.WebRTCPlugin.pluginState===AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING){if(AdapterJS.WebRTCPlugin.pluginState=AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTING,"IE"===webrtcDetectedBrowser&&webrtcDetectedVersion<=10){var frag=document.createDocumentFragment();for(AdapterJS.WebRTCPlugin.plugin=document.createElement("div"),AdapterJS.WebRTCPlugin.plugin.innerHTML='<object id="'+AdapterJS.WebRTCPlugin.pluginInfo.pluginId+'" type="'+AdapterJS.WebRTCPlugin.pluginInfo.type+'" width="1" height="1"><param name="pluginId" value="'+AdapterJS.WebRTCPlugin.pluginInfo.pluginId+'" /> <param name="windowless" value="false" /> <param name="pageId" value="'+AdapterJS.WebRTCPlugin.pageId+'" /> <param name="onload" value="'+AdapterJS.WebRTCPlugin.pluginInfo.onload+'" /><param name="tag" value="'+AdapterJS.WebRTCPlugin.TAGS.NONE+'" />'+(AdapterJS.options.getAllCams?'<param name="forceGetAllCams" value="True" />':"")+"</object>";AdapterJS.WebRTCPlugin.plugin.firstChild;)frag.appendChild(AdapterJS.WebRTCPlugin.plugin.firstChild);document.body.appendChild(frag),AdapterJS.WebRTCPlugin.plugin=document.getElementById(AdapterJS.WebRTCPlugin.pluginInfo.pluginId)}else AdapterJS.WebRTCPlugin.plugin=document.createElement("object"),AdapterJS.WebRTCPlugin.plugin.id=AdapterJS.WebRTCPlugin.pluginInfo.pluginId,isIE?(AdapterJS.WebRTCPlugin.plugin.width="1px",AdapterJS.WebRTCPlugin.plugin.height="1px"):(AdapterJS.WebRTCPlugin.plugin.width="0px",AdapterJS.WebRTCPlugin.plugin.height="0px"),AdapterJS.WebRTCPlugin.plugin.type=AdapterJS.WebRTCPlugin.pluginInfo.type,AdapterJS.WebRTCPlugin.plugin.innerHTML='<param name="onload" value="'+AdapterJS.WebRTCPlugin.pluginInfo.onload+'"><param name="pluginId" value="'+AdapterJS.WebRTCPlugin.pluginInfo.pluginId+'"><param name="windowless" value="false" /> '+(AdapterJS.options.getAllCams?'<param name="forceGetAllCams" value="True" />':"")+'<param name="pageId" value="'+AdapterJS.WebRTCPlugin.pageId+'"><param name="tag" value="'+AdapterJS.WebRTCPlugin.TAGS.NONE+'" />',document.body.appendChild(AdapterJS.WebRTCPlugin.plugin);AdapterJS.WebRTCPlugin.pluginState=AdapterJS.WebRTCPlugin.PLUGIN_STATES.INJECTED}},AdapterJS.WebRTCPlugin.isPluginInstalled=function(comName,plugName,plugType,installedCb,notInstalledCb){if(isIE){try{new ActiveXObject(comName+"."+plugName)}catch(e){return void notInstalledCb()}installedCb()}else{for(var pluginArray=navigator.mimeTypes,i=0;i<pluginArray.length;i++)if(pluginArray[i].type.indexOf(plugType)>=0)return void installedCb();notInstalledCb()}},AdapterJS.WebRTCPlugin.defineWebRTCInterface=function(){if(AdapterJS.WebRTCPlugin.pluginState!==AdapterJS.WebRTCPlugin.PLUGIN_STATES.READY){AdapterJS.WebRTCPlugin.pluginState=AdapterJS.WebRTCPlugin.PLUGIN_STATES.INITIALIZING,AdapterJS.isDefined=function(variable){return null!==variable&&void 0!==variable},createIceServer=function(url,username,password){var iceServer=null,urlParts=url.split(":");return 0===urlParts[0].indexOf("stun")?iceServer={url:url,hasCredentials:!1}:0===urlParts[0].indexOf("turn")&&(iceServer={url:url,hasCredentials:!0,credential:password,username:username}),iceServer},createIceServers=function(urls,username,password){for(var iceServers=[],i=0;i<urls.length;++i)iceServers.push(createIceServer(urls[i],username,password));return iceServers},RTCSessionDescription=function(info){return AdapterJS.WebRTCPlugin.WaitForPluginReady(),AdapterJS.WebRTCPlugin.plugin.ConstructSessionDescription(info.type,info.sdp)},MediaStream=function(mediaStreamOrTracks){return AdapterJS.WebRTCPlugin.WaitForPluginReady(),AdapterJS.WebRTCPlugin.plugin.MediaStream(mediaStreamOrTracks)},RTCPeerConnection=function(servers,constraints){if(void 0!==servers&&null!==servers&&!Array.isArray(servers.iceServers))throw new Error("Failed to construct 'RTCPeerConnection': Malformed RTCConfiguration");if("undefined"!=typeof constraints&&null!==constraints){var invalidConstraits=!1;if(invalidConstraits|="object"!=typeof constraints,invalidConstraits|=constraints.hasOwnProperty("mandatory")&&void 0!==constraints.mandatory&&null!==constraints.mandatory&&constraints.mandatory.constructor!==Object,invalidConstraits|=constraints.hasOwnProperty("optional")&&void 0!==constraints.optional&&null!==constraints.optional&&!Array.isArray(constraints.optional))throw new Error("Failed to construct 'RTCPeerConnection': Malformed constraints object")}AdapterJS.WebRTCPlugin.WaitForPluginReady();var iceServers=null;if(servers&&Array.isArray(servers.iceServers)){iceServers=servers.iceServers;for(var i=0;i<iceServers.length;i++)iceServers[i].urls&&!iceServers[i].url&&(iceServers[i].url=iceServers[i].urls),iceServers[i].hasCredentials=AdapterJS.isDefined(iceServers[i].username)&&AdapterJS.isDefined(iceServers[i].credential)}if(AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION&&AdapterJS.WebRTCPlugin.plugin.PEER_CONNECTION_VERSION>1)return iceServers&&(servers.iceServers=iceServers),AdapterJS.WebRTCPlugin.plugin.PeerConnection(servers);var mandatory=constraints&&constraints.mandatory?constraints.mandatory:null,optional=constraints&&constraints.optional?constraints.optional:null;return AdapterJS.WebRTCPlugin.plugin.PeerConnection(AdapterJS.WebRTCPlugin.pageId,iceServers,mandatory,optional)},MediaStreamTrack=function(){},MediaStreamTrack.getSources=function(callback){AdapterJS.WebRTCPlugin.callWhenPluginReady(function(){AdapterJS.WebRTCPlugin.plugin.GetSources(callback)})};var constraintsToPlugin=function(c){if("object"!=typeof c||c.mandatory||c.optional)return c;var cc={};return Object.keys(c).forEach(function(key){if("require"!==key&&"advanced"!==key){if("string"==typeof c[key])return void(cc[key]=c[key]);var r="object"==typeof c[key]?c[key]:{ideal:c[key]};void 0!==r.exact&&"number"==typeof r.exact&&(r.min=r.max=r.exact);var oldname=function(prefix,name){return prefix?prefix+name.charAt(0).toUpperCase()+name.slice(1):"deviceId"===name?"sourceId":name};if("sourceId"===oldname("",key)&&void 0!==r.exact&&(r.ideal=r.exact,r.exact=void 0),void 0!==r.ideal){cc.optional=cc.optional||[];var oc={};"number"==typeof r.ideal?(oc[oldname("min",key)]=r.ideal,cc.optional.push(oc),oc={},oc[oldname("max",key)]=r.ideal,cc.optional.push(oc)):(oc[oldname("",key)]=r.ideal,cc.optional.push(oc))}void 0!==r.exact&&"number"!=typeof r.exact?(cc.mandatory=cc.mandatory||{},cc.mandatory[oldname("",key)]=r.exact):["min","max"].forEach(function(mix){void 0!==r[mix]&&(cc.mandatory=cc.mandatory||{},cc.mandatory[oldname(mix,key)]=r[mix])})}}),c.advanced&&(cc.optional=(cc.optional||[]).concat(c.advanced)),cc};getUserMedia=function(constraints,successCallback,failureCallback){var cc={};cc.audio=!!constraints.audio&&constraintsToPlugin(constraints.audio),cc.video=!!constraints.video&&constraintsToPlugin(constraints.video),AdapterJS.WebRTCPlugin.callWhenPluginReady(function(){AdapterJS.WebRTCPlugin.plugin.getUserMedia(cc,successCallback,failureCallback)})},window.navigator.getUserMedia=getUserMedia,navigator.mediaDevices||"undefined"==typeof Promise||(requestUserMedia=function(constraints){return new Promise(function(resolve,reject){try{getUserMedia(constraints,resolve,reject)}catch(error){reject(error)}})},navigator.mediaDevices={getUserMedia:requestUserMedia,enumerateDevices:function(){return new Promise(function(resolve){var kinds={audio:"audioinput",video:"videoinput"};return MediaStreamTrack.getSources(function(devices){resolve(devices.map(function(device){return{label:device.label,kind:kinds[device.kind],id:device.id,deviceId:device.id,groupId:""}}))})})}}),attachMediaStream=function(element,stream){if(element&&element.parentNode){var streamId;null===stream?streamId="":("undefined"!=typeof stream.enableSoundTracks&&stream.enableSoundTracks(!0),streamId=stream.id);var elementId=0===element.id.length?Math.random().toString(36).slice(2):element.id,nodeName=element.nodeName.toLowerCase();if("object"!==nodeName){var tag;switch(nodeName){case"audio":tag=AdapterJS.WebRTCPlugin.TAGS.AUDIO;break;case"video":tag=AdapterJS.WebRTCPlugin.TAGS.VIDEO;break;default:tag=AdapterJS.WebRTCPlugin.TAGS.NONE}var frag=document.createDocumentFragment(),temp=document.createElement("div"),classHTML="";for(element.className?classHTML='class="'+element.className+'" ':element.attributes&&element.attributes.class&&(classHTML='class="'+element.attributes.class.value+'" '),temp.innerHTML='<object id="'+elementId+'" '+classHTML+'type="'+AdapterJS.WebRTCPlugin.pluginInfo.type+'"><param name="pluginId" value="'+elementId+'" /> <param name="pageId" value="'+AdapterJS.WebRTCPlugin.pageId+'" /> <param name="windowless" value="true" /> <param name="streamId" value="'+streamId+'" /> <param name="tag" value="'+tag+'" /> </object>';temp.firstChild;)frag.appendChild(temp.firstChild);var height="",width="";element.clientWidth||element.clientHeight?(width=element.clientWidth,height=element.clientHeight):(element.width||element.height)&&(width=element.width,height=element.height),element.parentNode.insertBefore(frag,element),frag=document.getElementById(elementId),frag.width=width,frag.height=height,element.parentNode.removeChild(element)}else{for(var children=element.children,i=0;i!==children.length;++i)if("streamId"===children[i].name){children[i].value=streamId;break}element.setStreamId(streamId)}var newElement=document.getElementById(elementId);return AdapterJS.forwardEventHandlers(newElement,element,Object.getPrototypeOf(element)),newElement}},reattachMediaStream=function(to,from){for(var stream=null,children=from.children,i=0;i!==children.length;++i)if("streamId"===children[i].name){AdapterJS.WebRTCPlugin.WaitForPluginReady(),stream=AdapterJS.WebRTCPlugin.plugin.getStreamWithId(AdapterJS.WebRTCPlugin.pageId,children[i].value);break}if(null!==stream)return attachMediaStream(to,stream)},window.attachMediaStream=attachMediaStream,window.reattachMediaStream=reattachMediaStream,window.getUserMedia=getUserMedia,AdapterJS.attachMediaStream=attachMediaStream,AdapterJS.reattachMediaStream=reattachMediaStream,AdapterJS.getUserMedia=getUserMedia,AdapterJS.forwardEventHandlers=function(destElem,srcElem,prototype){var properties=Object.getOwnPropertyNames(prototype);for(var prop in properties)if(prop){var propName=properties[prop];"function"==typeof propName.slice&&"on"===propName.slice(0,2)&&"function"==typeof srcElem[propName]&&AdapterJS.addEvent(destElem,propName.slice(2),srcElem[propName])}var subPrototype=Object.getPrototypeOf(prototype);subPrototype&&AdapterJS.forwardEventHandlers(destElem,srcElem,subPrototype)},RTCIceCandidate=function(candidate){return candidate.sdpMid||(candidate.sdpMid=""),AdapterJS.WebRTCPlugin.WaitForPluginReady(),AdapterJS.WebRTCPlugin.plugin.ConstructIceCandidate(candidate.sdpMid,candidate.sdpMLineIndex,candidate.candidate)},AdapterJS.addEvent(document,"readystatechange",AdapterJS.WebRTCPlugin.injectPlugin),AdapterJS.WebRTCPlugin.injectPlugin()}},AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb=AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb||function(){AdapterJS.addEvent(document,"readystatechange",AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv),AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv()},AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCbPriv=function(){if(!AdapterJS.options.hidePluginInstallPrompt){var downloadLink=AdapterJS.WebRTCPlugin.pluginInfo.downloadLink;if(downloadLink){var popupString;popupString=AdapterJS.WebRTCPlugin.pluginInfo.portalLink?'This website requires you to install the  <a href="'+AdapterJS.WebRTCPlugin.pluginInfo.portalLink+'" target="_blank">'+AdapterJS.WebRTCPlugin.pluginInfo.companyName+" WebRTC Plugin</a> to work on this browser.":AdapterJS.TEXT.PLUGIN.REQUIRE_INSTALLATION,AdapterJS.renderNotificationBar(popupString,AdapterJS.TEXT.PLUGIN.BUTTON,function(){window.open(downloadLink,"_top");var pluginInstallInterval=setInterval(function(){isIE||navigator.plugins.refresh(!1),AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix,AdapterJS.WebRTCPlugin.pluginInfo.plugName,AdapterJS.WebRTCPlugin.pluginInfo.type,function(){clearInterval(pluginInstallInterval),AdapterJS.WebRTCPlugin.defineWebRTCInterface()},function(){})},500)})}else AdapterJS.renderNotificationBar(AdapterJS.TEXT.PLUGIN.NOT_SUPPORTED)}},AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix,AdapterJS.WebRTCPlugin.pluginInfo.plugName,AdapterJS.WebRTCPlugin.pluginInfo.type,AdapterJS.WebRTCPlugin.defineWebRTCInterface,AdapterJS.WebRTCPlugin.pluginNeededButNotInstalledCb)):(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)&&window.RTCPeerConnection&&(window.msRTCPeerConnection=window.RTCPeerConnection),function(f){if(true)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{var g;g="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,g.adapter=f()}}(function(){return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a="function"==typeof require&&require;if(!u&&a)return require(o,!0);if(i)return require(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}for(var i="function"==typeof require&&require,o=0;o<r.length;o++)s(r[o]);return s}({1:[function(requirecopy,module,exports){"use strict";var SDPUtils={};SDPUtils.generateIdentifier=function(){return Math.random().toString(36).substr(2,10)},SDPUtils.localCName=SDPUtils.generateIdentifier(),SDPUtils.splitLines=function(blob){return blob.trim().split("\n").map(function(line){return line.trim()})},SDPUtils.splitSections=function(blob){var parts=blob.split("\nm=");return parts.map(function(part,index){return(index>0?"m="+part:part).trim()+"\r\n"})},SDPUtils.matchPrefix=function(blob,prefix){return SDPUtils.splitLines(blob).filter(function(line){return 0===line.indexOf(prefix)})},SDPUtils.parseCandidate=function(line){var parts;parts=0===line.indexOf("a=candidate:")?line.substring(12).split(" "):line.substring(10).split(" ");for(var candidate={foundation:parts[0],component:parts[1],protocol:parts[2].toLowerCase(),priority:parseInt(parts[3],10),ip:parts[4],port:parseInt(parts[5],10),type:parts[7]},i=8;i<parts.length;i+=2)switch(parts[i]){case"raddr":candidate.relatedAddress=parts[i+1];break;case"rport":candidate.relatedPort=parseInt(parts[i+1],10);break;case"tcptype":candidate.tcpType=parts[i+1]}return candidate},SDPUtils.writeCandidate=function(candidate){var sdp=[];sdp.push(candidate.foundation),sdp.push(candidate.component),sdp.push(candidate.protocol.toUpperCase()),sdp.push(candidate.priority),sdp.push(candidate.ip),sdp.push(candidate.port);var type=candidate.type;return sdp.push("typ"),sdp.push(type),"host"!==type&&candidate.relatedAddress&&candidate.relatedPort&&(sdp.push("raddr"),sdp.push(candidate.relatedAddress),sdp.push("rport"),sdp.push(candidate.relatedPort)),candidate.tcpType&&"tcp"===candidate.protocol.toLowerCase()&&(sdp.push("tcptype"),sdp.push(candidate.tcpType)),"candidate:"+sdp.join(" ")},SDPUtils.parseRtpMap=function(line){var parts=line.substr(9).split(" "),parsed={payloadType:parseInt(parts.shift(),10)};return parts=parts[0].split("/"),parsed.name=parts[0],parsed.clockRate=parseInt(parts[1],10),parsed.numChannels=3===parts.length?parseInt(parts[2],10):1,parsed},SDPUtils.writeRtpMap=function(codec){var pt=codec.payloadType;return void 0!==codec.preferredPayloadType&&(pt=codec.preferredPayloadType),"a=rtpmap:"+pt+" "+codec.name+"/"+codec.clockRate+(1!==codec.numChannels?"/"+codec.numChannels:"")+"\r\n"},SDPUtils.parseExtmap=function(line){var parts=line.substr(9).split(" ");return{id:parseInt(parts[0],10),uri:parts[1]}},SDPUtils.writeExtmap=function(headerExtension){return"a=extmap:"+(headerExtension.id||headerExtension.preferredId)+" "+headerExtension.uri+"\r\n"},SDPUtils.parseFmtp=function(line){for(var kv,parsed={},parts=line.substr(line.indexOf(" ")+1).split(";"),j=0;j<parts.length;j++)kv=parts[j].trim().split("="),parsed[kv[0].trim()]=kv[1];return parsed},SDPUtils.writeFmtp=function(codec){var line="",pt=codec.payloadType;if(void 0!==codec.preferredPayloadType&&(pt=codec.preferredPayloadType),codec.parameters&&Object.keys(codec.parameters).length){var params=[];Object.keys(codec.parameters).forEach(function(param){params.push(param+"="+codec.parameters[param])}),line+="a=fmtp:"+pt+" "+params.join(";")+"\r\n"}return line},SDPUtils.parseRtcpFb=function(line){var parts=line.substr(line.indexOf(" ")+1).split(" ");return{type:parts.shift(),parameter:parts.join(" ")}},SDPUtils.writeRtcpFb=function(codec){var lines="",pt=codec.payloadType;return void 0!==codec.preferredPayloadType&&(pt=codec.preferredPayloadType),codec.rtcpFeedback&&codec.rtcpFeedback.length&&codec.rtcpFeedback.forEach(function(fb){lines+="a=rtcp-fb:"+pt+" "+fb.type+(fb.parameter&&fb.parameter.length?" "+fb.parameter:"")+"\r\n"}),lines},SDPUtils.parseSsrcMedia=function(line){var sp=line.indexOf(" "),parts={ssrc:parseInt(line.substr(7,sp-7),10)},colon=line.indexOf(":",sp);return colon>-1?(parts.attribute=line.substr(sp+1,colon-sp-1),parts.value=line.substr(colon+1)):parts.attribute=line.substr(sp+1),parts},SDPUtils.getMid=function(mediaSection){var mid=SDPUtils.matchPrefix(mediaSection,"a=mid:")[0];if(mid)return mid.substr(6)},SDPUtils.getDtlsParameters=function(mediaSection,sessionpart){var lines=SDPUtils.splitLines(mediaSection);lines=lines.concat(SDPUtils.splitLines(sessionpart));var fpLine=lines.filter(function(line){return 0===line.indexOf("a=fingerprint:")})[0].substr(14),dtlsParameters={role:"auto",fingerprints:[{algorithm:fpLine.split(" ")[0].toLowerCase(),value:fpLine.split(" ")[1]}]};return dtlsParameters},SDPUtils.writeDtlsParameters=function(params,setupType){var sdp="a=setup:"+setupType+"\r\n";return params.fingerprints.forEach(function(fp){sdp+="a=fingerprint:"+fp.algorithm+" "+fp.value+"\r\n"}),sdp},SDPUtils.getIceParameters=function(mediaSection,sessionpart){var lines=SDPUtils.splitLines(mediaSection);lines=lines.concat(SDPUtils.splitLines(sessionpart));var iceParameters={usernameFragment:lines.filter(function(line){return 0===line.indexOf("a=ice-ufrag:")})[0].substr(12),password:lines.filter(function(line){return 0===line.indexOf("a=ice-pwd:")})[0].substr(10)};return iceParameters},SDPUtils.writeIceParameters=function(params){return"a=ice-ufrag:"+params.usernameFragment+"\r\na=ice-pwd:"+params.password+"\r\n"},SDPUtils.parseRtpParameters=function(mediaSection){for(var description={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},lines=SDPUtils.splitLines(mediaSection),mline=lines[0].split(" "),i=3;i<mline.length;i++){var pt=mline[i],rtpmapline=SDPUtils.matchPrefix(mediaSection,"a=rtpmap:"+pt+" ")[0];if(rtpmapline){var codec=SDPUtils.parseRtpMap(rtpmapline),fmtps=SDPUtils.matchPrefix(mediaSection,"a=fmtp:"+pt+" ");switch(codec.parameters=fmtps.length?SDPUtils.parseFmtp(fmtps[0]):{},codec.rtcpFeedback=SDPUtils.matchPrefix(mediaSection,"a=rtcp-fb:"+pt+" ").map(SDPUtils.parseRtcpFb),description.codecs.push(codec),codec.name.toUpperCase()){case"RED":case"ULPFEC":description.fecMechanisms.push(codec.name.toUpperCase())}}}return SDPUtils.matchPrefix(mediaSection,"a=extmap:").forEach(function(line){
description.headerExtensions.push(SDPUtils.parseExtmap(line))}),description},SDPUtils.writeRtpDescription=function(kind,caps){var sdp="";sdp+="m="+kind+" ",sdp+=caps.codecs.length>0?"9":"0",sdp+=" UDP/TLS/RTP/SAVPF ",sdp+=caps.codecs.map(function(codec){return void 0!==codec.preferredPayloadType?codec.preferredPayloadType:codec.payloadType}).join(" ")+"\r\n",sdp+="c=IN IP4 0.0.0.0\r\n",sdp+="a=rtcp:9 IN IP4 0.0.0.0\r\n",caps.codecs.forEach(function(codec){sdp+=SDPUtils.writeRtpMap(codec),sdp+=SDPUtils.writeFmtp(codec),sdp+=SDPUtils.writeRtcpFb(codec)});var maxptime=0;return caps.codecs.forEach(function(codec){codec.maxptime>maxptime&&(maxptime=codec.maxptime)}),maxptime>0&&(sdp+="a=maxptime:"+maxptime+"\r\n"),sdp+="a=rtcp-mux\r\n",caps.headerExtensions.forEach(function(extension){sdp+=SDPUtils.writeExtmap(extension)}),sdp},SDPUtils.parseRtpEncodingParameters=function(mediaSection){var secondarySsrc,encodingParameters=[],description=SDPUtils.parseRtpParameters(mediaSection),hasRed=description.fecMechanisms.indexOf("RED")!==-1,hasUlpfec=description.fecMechanisms.indexOf("ULPFEC")!==-1,ssrcs=SDPUtils.matchPrefix(mediaSection,"a=ssrc:").map(function(line){return SDPUtils.parseSsrcMedia(line)}).filter(function(parts){return"cname"===parts.attribute}),primarySsrc=ssrcs.length>0&&ssrcs[0].ssrc,flows=SDPUtils.matchPrefix(mediaSection,"a=ssrc-group:FID").map(function(line){var parts=line.split(" ");return parts.shift(),parts.map(function(part){return parseInt(part,10)})});flows.length>0&&flows[0].length>1&&flows[0][0]===primarySsrc&&(secondarySsrc=flows[0][1]),description.codecs.forEach(function(codec){if("RTX"===codec.name.toUpperCase()&&codec.parameters.apt){var encParam={ssrc:primarySsrc,codecPayloadType:parseInt(codec.parameters.apt,10),rtx:{ssrc:secondarySsrc}};encodingParameters.push(encParam),hasRed&&(encParam=JSON.parse(JSON.stringify(encParam)),encParam.fec={ssrc:secondarySsrc,mechanism:hasUlpfec?"red+ulpfec":"red"},encodingParameters.push(encParam))}}),0===encodingParameters.length&&primarySsrc&&encodingParameters.push({ssrc:primarySsrc});var bandwidth=SDPUtils.matchPrefix(mediaSection,"b=");return bandwidth.length&&(0===bandwidth[0].indexOf("b=TIAS:")?bandwidth=parseInt(bandwidth[0].substr(7),10):0===bandwidth[0].indexOf("b=AS:")&&(bandwidth=parseInt(bandwidth[0].substr(5),10)),encodingParameters.forEach(function(params){params.maxBitrate=bandwidth})),encodingParameters},SDPUtils.parseRtcpParameters=function(mediaSection){var rtcpParameters={},remoteSsrc=SDPUtils.matchPrefix(mediaSection,"a=ssrc:").map(function(line){return SDPUtils.parseSsrcMedia(line)}).filter(function(obj){return"cname"===obj.attribute})[0];remoteSsrc&&(rtcpParameters.cname=remoteSsrc.value,rtcpParameters.ssrc=remoteSsrc.ssrc);var rsize=SDPUtils.matchPrefix(mediaSection,"a=rtcp-rsize");rtcpParameters.reducedSize=rsize.length>0,rtcpParameters.compound=0===rsize.length;var mux=SDPUtils.matchPrefix(mediaSection,"a=rtcp-mux");return rtcpParameters.mux=mux.length>0,rtcpParameters},SDPUtils.parseMsid=function(mediaSection){var parts,spec=SDPUtils.matchPrefix(mediaSection,"a=msid:");if(1===spec.length)return parts=spec[0].substr(7).split(" "),{stream:parts[0],track:parts[1]};var planB=SDPUtils.matchPrefix(mediaSection,"a=ssrc:").map(function(line){return SDPUtils.parseSsrcMedia(line)}).filter(function(parts){return"msid"===parts.attribute});return planB.length>0?(parts=planB[0].value.split(" "),{stream:parts[0],track:parts[1]}):void 0},SDPUtils.writeSessionBoilerplate=function(){return"v=0\r\no=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"},SDPUtils.writeMediaSection=function(transceiver,caps,type,stream){var sdp=SDPUtils.writeRtpDescription(transceiver.kind,caps);if(sdp+=SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters()),sdp+=SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(),"offer"===type?"actpass":"active"),sdp+="a=mid:"+transceiver.mid+"\r\n",sdp+=transceiver.rtpSender&&transceiver.rtpReceiver?"a=sendrecv\r\n":transceiver.rtpSender?"a=sendonly\r\n":transceiver.rtpReceiver?"a=recvonly\r\n":"a=inactive\r\n",transceiver.rtpSender){var msid="msid:"+stream.id+" "+transceiver.rtpSender.track.id+"\r\n";sdp+="a="+msid,sdp+="a=ssrc:"+transceiver.sendEncodingParameters[0].ssrc+" "+msid,transceiver.sendEncodingParameters[0].rtx&&(sdp+="a=ssrc:"+transceiver.sendEncodingParameters[0].rtx.ssrc+" "+msid,sdp+="a=ssrc-group:FID "+transceiver.sendEncodingParameters[0].ssrc+" "+transceiver.sendEncodingParameters[0].rtx.ssrc+"\r\n")}return sdp+="a=ssrc:"+transceiver.sendEncodingParameters[0].ssrc+" cname:"+SDPUtils.localCName+"\r\n",transceiver.rtpSender&&transceiver.sendEncodingParameters[0].rtx&&(sdp+="a=ssrc:"+transceiver.sendEncodingParameters[0].rtx.ssrc+" cname:"+SDPUtils.localCName+"\r\n"),sdp},SDPUtils.getDirection=function(mediaSection,sessionpart){for(var lines=SDPUtils.splitLines(mediaSection),i=0;i<lines.length;i++)switch(lines[i]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return lines[i].substr(2)}return sessionpart?SDPUtils.getDirection(sessionpart):"sendrecv"},SDPUtils.getKind=function(mediaSection){var lines=SDPUtils.splitLines(mediaSection),mline=lines[0].split(" ");return mline[0].substr(2)},SDPUtils.isRejected=function(mediaSection){return"0"===mediaSection.split(" ",2)[1]},module.exports=SDPUtils},{}],2:[function(requirecopy,module,exports){"use strict";!function(){var logging=requirecopy("./utils").log,browserDetails=requirecopy("./utils").browserDetails;module.exports.browserDetails=browserDetails,module.exports.extractVersion=requirecopy("./utils").extractVersion,module.exports.disableLog=requirecopy("./utils").disableLog;var chromeShim=requirecopy("./chrome/chrome_shim")||null,edgeShim=requirecopy("./edge/edge_shim")||null,firefoxShim=requirecopy("./firefox/firefox_shim")||null,safariShim=requirecopy("./safari/safari_shim")||null;switch(browserDetails.browser){case"opera":case"chrome":if(!chromeShim||!chromeShim.shimPeerConnection)return void logging("Chrome shim is not included in this adapter release.");logging("adapter.js shimming chrome."),module.exports.browserShim=chromeShim,chromeShim.shimGetUserMedia(),chromeShim.shimMediaStream(),chromeShim.shimSourceObject(),chromeShim.shimPeerConnection(),chromeShim.shimOnTrack();break;case"firefox":if(!firefoxShim||!firefoxShim.shimPeerConnection)return void logging("Firefox shim is not included in this adapter release.");logging("adapter.js shimming firefox."),module.exports.browserShim=firefoxShim,firefoxShim.shimGetUserMedia(),firefoxShim.shimSourceObject(),firefoxShim.shimPeerConnection(),firefoxShim.shimOnTrack();break;case"edge":if(!edgeShim||!edgeShim.shimPeerConnection)return void logging("MS edge shim is not included in this adapter release.");logging("adapter.js shimming edge."),module.exports.browserShim=edgeShim,edgeShim.shimGetUserMedia(),edgeShim.shimPeerConnection();break;case"safari":if(!safariShim)return void logging("Safari shim is not included in this adapter release.");logging("adapter.js shimming safari."),module.exports.browserShim=safariShim,safariShim.shimGetUserMedia();break;default:logging("Unsupported browser!")}}()},{"./chrome/chrome_shim":3,"./edge/edge_shim":5,"./firefox/firefox_shim":7,"./safari/safari_shim":9,"./utils":10}],3:[function(requirecopy,module,exports){"use strict";var logging=requirecopy("../utils.js").log,browserDetails=requirecopy("../utils.js").browserDetails,chromeShim={shimMediaStream:function(){window.MediaStream=window.MediaStream||window.webkitMediaStream},shimOnTrack:function(){"object"!=typeof window||!window.RTCPeerConnection||"ontrack"in window.RTCPeerConnection.prototype||Object.defineProperty(window.RTCPeerConnection.prototype,"ontrack",{get:function(){return this._ontrack},set:function(f){var self=this;this._ontrack&&(this.removeEventListener("track",this._ontrack),this.removeEventListener("addstream",this._ontrackpoly)),this.addEventListener("track",this._ontrack=f),this.addEventListener("addstream",this._ontrackpoly=function(e){e.stream.addEventListener("addtrack",function(te){var event=new Event("track");event.track=te.track,event.receiver={track:te.track},event.streams=[e.stream],self.dispatchEvent(event)}),e.stream.getTracks().forEach(function(track){var event=new Event("track");event.track=track,event.receiver={track:track},event.streams=[e.stream],this.dispatchEvent(event)}.bind(this))}.bind(this))}})},shimSourceObject:function(){"object"==typeof window&&(!window.HTMLMediaElement||"srcObject"in window.HTMLMediaElement.prototype||Object.defineProperty(window.HTMLMediaElement.prototype,"srcObject",{get:function(){return this._srcObject},set:function(stream){var self=this;return this._srcObject=stream,this.src&&URL.revokeObjectURL(this.src),stream?(this.src=URL.createObjectURL(stream),stream.addEventListener("addtrack",function(){self.src&&URL.revokeObjectURL(self.src),self.src=URL.createObjectURL(stream)}),void stream.addEventListener("removetrack",function(){self.src&&URL.revokeObjectURL(self.src),self.src=URL.createObjectURL(stream)})):void(this.src="")}}))},shimPeerConnection:function(){window.RTCPeerConnection=function(pcConfig,pcConstraints){logging("PeerConnection"),pcConfig&&pcConfig.iceTransportPolicy&&(pcConfig.iceTransports=pcConfig.iceTransportPolicy);var pc=new webkitRTCPeerConnection(pcConfig,pcConstraints),origGetStats=pc.getStats.bind(pc);return pc.getStats=function(selector,successCallback,errorCallback){var self=this,args=arguments;if(arguments.length>0&&"function"==typeof selector)return origGetStats(selector,successCallback);var fixChromeStats_=function(response){var standardReport={},reports=response.result();return reports.forEach(function(report){var standardStats={id:report.id,timestamp:report.timestamp,type:report.type};report.names().forEach(function(name){standardStats[name]=report.stat(name)}),standardReport[standardStats.id]=standardStats}),standardReport},makeMapStats=function(stats,legacyStats){var map=new Map(Object.keys(stats).map(function(key){return[key,stats[key]]}));return legacyStats=legacyStats||stats,Object.keys(legacyStats).forEach(function(key){map[key]=legacyStats[key]}),map};if(arguments.length>=2){var successCallbackWrapper_=function(response){args[1](makeMapStats(fixChromeStats_(response)))};return origGetStats.apply(this,[successCallbackWrapper_,arguments[0]])}return new Promise(function(resolve,reject){1===args.length&&"object"==typeof selector?origGetStats.apply(self,[function(response){resolve(makeMapStats(fixChromeStats_(response)))},reject]):origGetStats.apply(self,[function(response){resolve(makeMapStats(fixChromeStats_(response),response.result()))},reject])}).then(successCallback,errorCallback)},pc},window.RTCPeerConnection.prototype=webkitRTCPeerConnection.prototype,webkitRTCPeerConnection.generateCertificate&&Object.defineProperty(window.RTCPeerConnection,"generateCertificate",{get:function(){return webkitRTCPeerConnection.generateCertificate}}),["createOffer","createAnswer"].forEach(function(method){var nativeMethod=webkitRTCPeerConnection.prototype[method];webkitRTCPeerConnection.prototype[method]=function(){var self=this;if(arguments.length<1||1===arguments.length&&"object"==typeof arguments[0]){var opts=1===arguments.length?arguments[0]:void 0;return new Promise(function(resolve,reject){nativeMethod.apply(self,[resolve,reject,opts])})}return nativeMethod.apply(this,arguments)}}),browserDetails.version<51&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(method){var nativeMethod=webkitRTCPeerConnection.prototype[method];webkitRTCPeerConnection.prototype[method]=function(){var args=arguments,self=this,promise=new Promise(function(resolve,reject){nativeMethod.apply(self,[args[0],resolve,reject])});return args.length<2?promise:promise.then(function(){args[1].apply(null,[])},function(err){args.length>=3&&args[2].apply(null,[err])})}}),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(method){var nativeMethod=webkitRTCPeerConnection.prototype[method];webkitRTCPeerConnection.prototype[method]=function(){return arguments[0]=new("addIceCandidate"===method?RTCIceCandidate:RTCSessionDescription)(arguments[0]),nativeMethod.apply(this,arguments)}});var nativeAddIceCandidate=RTCPeerConnection.prototype.addIceCandidate;RTCPeerConnection.prototype.addIceCandidate=function(){return null===arguments[0]?Promise.resolve():nativeAddIceCandidate.apply(this,arguments)}}};module.exports={shimMediaStream:chromeShim.shimMediaStream,shimOnTrack:chromeShim.shimOnTrack,shimSourceObject:chromeShim.shimSourceObject,shimPeerConnection:chromeShim.shimPeerConnection,shimGetUserMedia:requirecopy("./getusermedia")}},{"../utils.js":10,"./getusermedia":4}],4:[function(requirecopy,module,exports){"use strict";var logging=requirecopy("../utils.js").log;module.exports=function(){var constraintsToChrome_=function(c){if("object"!=typeof c||c.mandatory||c.optional)return c;var cc={};return Object.keys(c).forEach(function(key){if("require"!==key&&"advanced"!==key&&"mediaSource"!==key){var r="object"==typeof c[key]?c[key]:{ideal:c[key]};void 0!==r.exact&&"number"==typeof r.exact&&(r.min=r.max=r.exact);var oldname_=function(prefix,name){return prefix?prefix+name.charAt(0).toUpperCase()+name.slice(1):"deviceId"===name?"sourceId":name};if(void 0!==r.ideal){cc.optional=cc.optional||[];var oc={};"number"==typeof r.ideal?(oc[oldname_("min",key)]=r.ideal,cc.optional.push(oc),oc={},oc[oldname_("max",key)]=r.ideal,cc.optional.push(oc)):(oc[oldname_("",key)]=r.ideal,cc.optional.push(oc))}void 0!==r.exact&&"number"!=typeof r.exact?(cc.mandatory=cc.mandatory||{},cc.mandatory[oldname_("",key)]=r.exact):["min","max"].forEach(function(mix){void 0!==r[mix]&&(cc.mandatory=cc.mandatory||{},cc.mandatory[oldname_(mix,key)]=r[mix])})}}),c.advanced&&(cc.optional=(cc.optional||[]).concat(c.advanced)),cc},shimConstraints_=function(constraints,func){if(constraints=JSON.parse(JSON.stringify(constraints)),constraints&&constraints.audio&&(constraints.audio=constraintsToChrome_(constraints.audio)),constraints&&"object"==typeof constraints.video){var face=constraints.video.facingMode;if(face=face&&("object"==typeof face?face:{ideal:face}),face&&("user"===face.exact||"environment"===face.exact||"user"===face.ideal||"environment"===face.ideal)&&(!navigator.mediaDevices.getSupportedConstraints||!navigator.mediaDevices.getSupportedConstraints().facingMode)&&(delete constraints.video.facingMode,"environment"===face.exact||"environment"===face.ideal))return navigator.mediaDevices.enumerateDevices().then(function(devices){devices=devices.filter(function(d){return"videoinput"===d.kind});var back=devices.find(function(d){return d.label.toLowerCase().indexOf("back")!==-1})||devices.length&&devices[devices.length-1];return back&&(constraints.video.deviceId=face.exact?{exact:back.deviceId}:{ideal:back.deviceId}),constraints.video=constraintsToChrome_(constraints.video),logging("chrome: "+JSON.stringify(constraints)),func(constraints)});constraints.video=constraintsToChrome_(constraints.video)}return logging("chrome: "+JSON.stringify(constraints)),func(constraints)},shimError_=function(e){return{name:{PermissionDeniedError:"NotAllowedError",ConstraintNotSatisfiedError:"OverconstrainedError"}[e.name]||e.name,message:e.message,constraint:e.constraintName,toString:function(){return this.name+(this.message&&": ")+this.message}}},getUserMedia_=function(constraints,onSuccess,onError){shimConstraints_(constraints,function(c){navigator.webkitGetUserMedia(c,onSuccess,function(e){onError(shimError_(e))})})};navigator.getUserMedia=getUserMedia_;var getUserMediaPromise_=function(constraints){return new Promise(function(resolve,reject){navigator.getUserMedia(constraints,resolve,reject)})};if(navigator.mediaDevices||(navigator.mediaDevices={getUserMedia:getUserMediaPromise_,enumerateDevices:function(){return new Promise(function(resolve){var kinds={audio:"audioinput",video:"videoinput"};return MediaStreamTrack.getSources(function(devices){resolve(devices.map(function(device){return{label:device.label,kind:kinds[device.kind],deviceId:device.id,groupId:""}}))})})}}),navigator.mediaDevices.getUserMedia){var origGetUserMedia=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(cs){return shimConstraints_(cs,function(c){return origGetUserMedia(c).catch(function(e){return Promise.reject(shimError_(e))})})}}else navigator.mediaDevices.getUserMedia=function(constraints){return getUserMediaPromise_(constraints)};"undefined"==typeof navigator.mediaDevices.addEventListener&&(navigator.mediaDevices.addEventListener=function(){logging("Dummy mediaDevices.addEventListener called.")}),"undefined"==typeof navigator.mediaDevices.removeEventListener&&(navigator.mediaDevices.removeEventListener=function(){logging("Dummy mediaDevices.removeEventListener called.")})}},{"../utils.js":10}],5:[function(requirecopy,module,exports){"use strict";var SDPUtils=requirecopy("sdp"),browserDetails=requirecopy("../utils").browserDetails,edgeShim={shimPeerConnection:function(){window.RTCIceGatherer&&(window.RTCIceCandidate||(window.RTCIceCandidate=function(args){return args}),window.RTCSessionDescription||(window.RTCSessionDescription=function(args){return args})),window.RTCPeerConnection=function(config){var self=this,_eventTarget=document.createDocumentFragment();if(["addEventListener","removeEventListener","dispatchEvent"].forEach(function(method){self[method]=_eventTarget[method].bind(_eventTarget)}),this.onicecandidate=null,this.onaddstream=null,this.ontrack=null,this.onremovestream=null,this.onsignalingstatechange=null,this.oniceconnectionstatechange=null,this.onnegotiationneeded=null,this.ondatachannel=null,this.localStreams=[],this.remoteStreams=[],this.getLocalStreams=function(){return self.localStreams},this.getRemoteStreams=function(){return self.remoteStreams},this.localDescription=new RTCSessionDescription({type:"",sdp:""}),this.remoteDescription=new RTCSessionDescription({type:"",sdp:""}),this.signalingState="stable",this.iceConnectionState="new",this.iceGatheringState="new",this.iceOptions={gatherPolicy:"all",iceServers:[]},config&&config.iceTransportPolicy)switch(config.iceTransportPolicy){case"all":case"relay":this.iceOptions.gatherPolicy=config.iceTransportPolicy;break;case"none":throw new TypeError('iceTransportPolicy "none" not supported')}if(this.usingBundle=config&&"max-bundle"===config.bundlePolicy,config&&config.iceServers){var iceServers=JSON.parse(JSON.stringify(config.iceServers));this.iceOptions.iceServers=iceServers.filter(function(server){if(server&&server.urls){var urls=server.urls;return"string"==typeof urls&&(urls=[urls]),urls=urls.filter(function(url){return 0===url.indexOf("turn:")&&url.indexOf("transport=udp")!==-1&&url.indexOf("turn:[")===-1||0===url.indexOf("stun:")&&browserDetails.version>=14393})[0],!!urls}return!1})}this.transceivers=[],this._localIceCandidatesBuffer=[]},window.RTCPeerConnection.prototype._emitBufferedCandidates=function(){var self=this,sections=SDPUtils.splitSections(self.localDescription.sdp);this._localIceCandidatesBuffer.forEach(function(event){var end=!event.candidate||0===Object.keys(event.candidate).length;if(end)for(var j=1;j<sections.length;j++)sections[j].indexOf("\r\na=end-of-candidates\r\n")===-1&&(sections[j]+="a=end-of-candidates\r\n");else event.candidate.candidate.indexOf("typ endOfCandidates")===-1&&(sections[event.candidate.sdpMLineIndex+1]+="a="+event.candidate.candidate+"\r\n");if(self.localDescription.sdp=sections.join(""),self.dispatchEvent(event),null!==self.onicecandidate&&self.onicecandidate(event),!event.candidate&&"complete"!==self.iceGatheringState){var complete=self.transceivers.every(function(transceiver){return transceiver.iceGatherer&&"completed"===transceiver.iceGatherer.state});complete&&(self.iceGatheringState="complete")}}),this._localIceCandidatesBuffer=[]},window.RTCPeerConnection.prototype.addStream=function(stream){this.localStreams.push(stream.clone()),this._maybeFireNegotiationNeeded()},window.RTCPeerConnection.prototype.removeStream=function(stream){var idx=this.localStreams.indexOf(stream);idx>-1&&(this.localStreams.splice(idx,1),this._maybeFireNegotiationNeeded())},window.RTCPeerConnection.prototype.getSenders=function(){return this.transceivers.filter(function(transceiver){return!!transceiver.rtpSender}).map(function(transceiver){return transceiver.rtpSender})},window.RTCPeerConnection.prototype.getReceivers=function(){return this.transceivers.filter(function(transceiver){return!!transceiver.rtpReceiver}).map(function(transceiver){return transceiver.rtpReceiver})},window.RTCPeerConnection.prototype._getCommonCapabilities=function(localCapabilities,remoteCapabilities){var commonCapabilities={codecs:[],headerExtensions:[],fecMechanisms:[]};return localCapabilities.codecs.forEach(function(lCodec){for(var i=0;i<remoteCapabilities.codecs.length;i++){var rCodec=remoteCapabilities.codecs[i];if(lCodec.name.toLowerCase()===rCodec.name.toLowerCase()&&lCodec.clockRate===rCodec.clockRate&&lCodec.numChannels===rCodec.numChannels){commonCapabilities.codecs.push(rCodec),rCodec.rtcpFeedback=rCodec.rtcpFeedback.filter(function(fb){for(var j=0;j<lCodec.rtcpFeedback.length;j++)if(lCodec.rtcpFeedback[j].type===fb.type&&lCodec.rtcpFeedback[j].parameter===fb.parameter)return!0;return!1});break}}}),localCapabilities.headerExtensions.forEach(function(lHeaderExtension){for(var i=0;i<remoteCapabilities.headerExtensions.length;i++){var rHeaderExtension=remoteCapabilities.headerExtensions[i];if(lHeaderExtension.uri===rHeaderExtension.uri){commonCapabilities.headerExtensions.push(rHeaderExtension);break}}}),commonCapabilities},window.RTCPeerConnection.prototype._createIceAndDtlsTransports=function(mid,sdpMLineIndex){var self=this,iceGatherer=new RTCIceGatherer(self.iceOptions),iceTransport=new RTCIceTransport(iceGatherer);iceGatherer.onlocalcandidate=function(evt){var event=new Event("icecandidate");event.candidate={sdpMid:mid,sdpMLineIndex:sdpMLineIndex};var cand=evt.candidate,end=!cand||0===Object.keys(cand).length;end?(void 0===iceGatherer.state&&(iceGatherer.state="completed"),event.candidate.candidate="candidate:1 1 udp 1 0.0.0.0 9 typ endOfCandidates"):(cand.component="RTCP"===iceTransport.component?2:1,event.candidate.candidate=SDPUtils.writeCandidate(cand));var sections=SDPUtils.splitSections(self.localDescription.sdp);event.candidate.candidate.indexOf("typ endOfCandidates")===-1?sections[event.candidate.sdpMLineIndex+1]+="a="+event.candidate.candidate+"\r\n":sections[event.candidate.sdpMLineIndex+1]+="a=end-of-candidates\r\n",self.localDescription.sdp=sections.join("");var complete=self.transceivers.every(function(transceiver){return transceiver.iceGatherer&&"completed"===transceiver.iceGatherer.state});switch(self.iceGatheringState){case"new":self._localIceCandidatesBuffer.push(event),end&&complete&&self._localIceCandidatesBuffer.push(new Event("icecandidate"));break;case"gathering":self._emitBufferedCandidates(),self.dispatchEvent(event),null!==self.onicecandidate&&self.onicecandidate(event),complete&&(self.dispatchEvent(new Event("icecandidate")),null!==self.onicecandidate&&self.onicecandidate(new Event("icecandidate")),self.iceGatheringState="complete");break;case"complete":}},iceTransport.onicestatechange=function(){self._updateConnectionState()};var dtlsTransport=new RTCDtlsTransport(iceTransport);return dtlsTransport.ondtlsstatechange=function(){self._updateConnectionState()},dtlsTransport.onerror=function(){dtlsTransport.state="failed",self._updateConnectionState()},{iceGatherer:iceGatherer,iceTransport:iceTransport,dtlsTransport:dtlsTransport}},window.RTCPeerConnection.prototype._transceive=function(transceiver,send,recv){var params=this._getCommonCapabilities(transceiver.localCapabilities,transceiver.remoteCapabilities);send&&transceiver.rtpSender&&(params.encodings=transceiver.sendEncodingParameters,params.rtcp={cname:SDPUtils.localCName},transceiver.recvEncodingParameters.length&&(params.rtcp.ssrc=transceiver.recvEncodingParameters[0].ssrc),transceiver.rtpSender.send(params)),recv&&transceiver.rtpReceiver&&(params.encodings=transceiver.recvEncodingParameters,params.rtcp={cname:transceiver.cname},transceiver.sendEncodingParameters.length&&(params.rtcp.ssrc=transceiver.sendEncodingParameters[0].ssrc),transceiver.rtpReceiver.receive(params))},window.RTCPeerConnection.prototype.setLocalDescription=function(description){var sections,sessionpart,self=this;if("offer"===description.type)this._pendingOffer&&(sections=SDPUtils.splitSections(description.sdp),sessionpart=sections.shift(),sections.forEach(function(mediaSection,sdpMLineIndex){var caps=SDPUtils.parseRtpParameters(mediaSection);self._pendingOffer[sdpMLineIndex].localCapabilities=caps}),this.transceivers=this._pendingOffer,delete this._pendingOffer);else if("answer"===description.type){sections=SDPUtils.splitSections(self.remoteDescription.sdp),sessionpart=sections.shift();var isIceLite=SDPUtils.matchPrefix(sessionpart,"a=ice-lite").length>0;sections.forEach(function(mediaSection,sdpMLineIndex){var transceiver=self.transceivers[sdpMLineIndex],iceGatherer=transceiver.iceGatherer,iceTransport=transceiver.iceTransport,dtlsTransport=transceiver.dtlsTransport,localCapabilities=transceiver.localCapabilities,remoteCapabilities=transceiver.remoteCapabilities,rejected="0"===mediaSection.split("\n",1)[0].split(" ",2)[1];if(!rejected&&!transceiver.isDatachannel){var remoteIceParameters=SDPUtils.getIceParameters(mediaSection,sessionpart);if(isIceLite){var cands=SDPUtils.matchPrefix(mediaSection,"a=candidate:").map(function(cand){return SDPUtils.parseCandidate(cand)}).filter(function(cand){return"1"===cand.component});cands.length&&iceTransport.setRemoteCandidates(cands)}var remoteDtlsParameters=SDPUtils.getDtlsParameters(mediaSection,sessionpart);isIceLite&&(remoteDtlsParameters.role="server"),self.usingBundle&&0!==sdpMLineIndex||(iceTransport.start(iceGatherer,remoteIceParameters,isIceLite?"controlling":"controlled"),dtlsTransport.start(remoteDtlsParameters));var params=self._getCommonCapabilities(localCapabilities,remoteCapabilities);self._transceive(transceiver,params.codecs.length>0,!1)}})}switch(this.localDescription={type:description.type,sdp:description.sdp},description.type){case"offer":this._updateSignalingState("have-local-offer");break;case"answer":this._updateSignalingState("stable");break;default:throw new TypeError('unsupported type "'+description.type+'"')}var hasCallback=arguments.length>1&&"function"==typeof arguments[1];if(hasCallback){var cb=arguments[1];window.setTimeout(function(){cb(),"new"===self.iceGatheringState&&(self.iceGatheringState="gathering"),self._emitBufferedCandidates()},0)}var p=Promise.resolve();return p.then(function(){hasCallback||("new"===self.iceGatheringState&&(self.iceGatheringState="gathering"),window.setTimeout(self._emitBufferedCandidates.bind(self),500))}),p},window.RTCPeerConnection.prototype.setRemoteDescription=function(description){var self=this,stream=new MediaStream,receiverList=[],sections=SDPUtils.splitSections(description.sdp),sessionpart=sections.shift(),isIceLite=SDPUtils.matchPrefix(sessionpart,"a=ice-lite").length>0;switch(this.usingBundle=SDPUtils.matchPrefix(sessionpart,"a=group:BUNDLE ").length>0,sections.forEach(function(mediaSection,sdpMLineIndex){var lines=SDPUtils.splitLines(mediaSection),mline=lines[0].substr(2).split(" "),kind=mline[0],rejected="0"===mline[1],direction=SDPUtils.getDirection(mediaSection,sessionpart),mid=SDPUtils.matchPrefix(mediaSection,"a=mid:");if(mid=mid.length?mid[0].substr(6):SDPUtils.generateIdentifier(),"application"===kind&&"DTLS/SCTP"===mline[2])return void(self.transceivers[sdpMLineIndex]={mid:mid,isDatachannel:!0});var transceiver,iceGatherer,iceTransport,dtlsTransport,rtpSender,rtpReceiver,sendEncodingParameters,recvEncodingParameters,localCapabilities,track,remoteIceParameters,remoteDtlsParameters,remoteCapabilities=SDPUtils.parseRtpParameters(mediaSection);rejected||(remoteIceParameters=SDPUtils.getIceParameters(mediaSection,sessionpart),remoteDtlsParameters=SDPUtils.getDtlsParameters(mediaSection,sessionpart),remoteDtlsParameters.role="client"),recvEncodingParameters=SDPUtils.parseRtpEncodingParameters(mediaSection);var cname,remoteSsrc=SDPUtils.matchPrefix(mediaSection,"a=ssrc:").map(function(line){return SDPUtils.parseSsrcMedia(line)}).filter(function(obj){return"cname"===obj.attribute})[0];remoteSsrc&&(cname=remoteSsrc.value);var isComplete=SDPUtils.matchPrefix(mediaSection,"a=end-of-candidates",sessionpart).length>0,cands=SDPUtils.matchPrefix(mediaSection,"a=candidate:").map(function(cand){return SDPUtils.parseCandidate(cand)}).filter(function(cand){return"1"===cand.component});if("offer"!==description.type||rejected)"answer"!==description.type||rejected||(transceiver=self.transceivers[sdpMLineIndex],iceGatherer=transceiver.iceGatherer,iceTransport=transceiver.iceTransport,dtlsTransport=transceiver.dtlsTransport,rtpSender=transceiver.rtpSender,rtpReceiver=transceiver.rtpReceiver,sendEncodingParameters=transceiver.sendEncodingParameters,localCapabilities=transceiver.localCapabilities,self.transceivers[sdpMLineIndex].recvEncodingParameters=recvEncodingParameters,self.transceivers[sdpMLineIndex].remoteCapabilities=remoteCapabilities,self.transceivers[sdpMLineIndex].cname=cname,(isIceLite||isComplete)&&cands.length&&iceTransport.setRemoteCandidates(cands),self.usingBundle&&0!==sdpMLineIndex||(iceTransport.start(iceGatherer,remoteIceParameters,"controlling"),dtlsTransport.start(remoteDtlsParameters)),self._transceive(transceiver,"sendrecv"===direction||"recvonly"===direction,"sendrecv"===direction||"sendonly"===direction),!rtpReceiver||"sendrecv"!==direction&&"sendonly"!==direction?delete transceiver.rtpReceiver:(track=rtpReceiver.track,receiverList.push([track,rtpReceiver]),stream.addTrack(track)));else{var transports=self.usingBundle&&sdpMLineIndex>0?{iceGatherer:self.transceivers[0].iceGatherer,iceTransport:self.transceivers[0].iceTransport,dtlsTransport:self.transceivers[0].dtlsTransport}:self._createIceAndDtlsTransports(mid,sdpMLineIndex);if(isComplete&&transports.iceTransport.setRemoteCandidates(cands),localCapabilities=RTCRtpReceiver.getCapabilities(kind),sendEncodingParameters=[{ssrc:1001*(2*sdpMLineIndex+2)}],rtpReceiver=new RTCRtpReceiver(transports.dtlsTransport,kind),track=rtpReceiver.track,receiverList.push([track,rtpReceiver]),stream.addTrack(track),self.localStreams.length>0&&self.localStreams[0].getTracks().length>=sdpMLineIndex){var localTrack;"audio"===kind?localTrack=self.localStreams[0].getAudioTracks()[0]:"video"===kind&&(localTrack=self.localStreams[0].getVideoTracks()[0]),localTrack&&(rtpSender=new RTCRtpSender(localTrack,transports.dtlsTransport))}self.transceivers[sdpMLineIndex]={iceGatherer:transports.iceGatherer,iceTransport:transports.iceTransport,dtlsTransport:transports.dtlsTransport,localCapabilities:localCapabilities,remoteCapabilities:remoteCapabilities,rtpSender:rtpSender,rtpReceiver:rtpReceiver,kind:kind,mid:mid,cname:cname,sendEncodingParameters:sendEncodingParameters,recvEncodingParameters:recvEncodingParameters},self._transceive(self.transceivers[sdpMLineIndex],!1,"sendrecv"===direction||"sendonly"===direction)}}),this.remoteDescription={type:description.type,sdp:description.sdp},description.type){case"offer":this._updateSignalingState("have-remote-offer");break;case"answer":this._updateSignalingState("stable");break;default:throw new TypeError('unsupported type "'+description.type+'"')}return stream.getTracks().length&&(self.remoteStreams.push(stream),window.setTimeout(function(){var event=new Event("addstream");event.stream=stream,self.dispatchEvent(event),null!==self.onaddstream&&window.setTimeout(function(){self.onaddstream(event)},0),receiverList.forEach(function(item){var track=item[0],receiver=item[1],trackEvent=new Event("track");trackEvent.track=track,trackEvent.receiver=receiver,
trackEvent.streams=[stream],self.dispatchEvent(event),null!==self.ontrack&&window.setTimeout(function(){self.ontrack(trackEvent)},0)})},0)),arguments.length>1&&"function"==typeof arguments[1]&&window.setTimeout(arguments[1],0),Promise.resolve()},window.RTCPeerConnection.prototype.close=function(){this.transceivers.forEach(function(transceiver){transceiver.iceTransport&&transceiver.iceTransport.stop(),transceiver.dtlsTransport&&transceiver.dtlsTransport.stop(),transceiver.rtpSender&&transceiver.rtpSender.stop(),transceiver.rtpReceiver&&transceiver.rtpReceiver.stop()}),this._updateSignalingState("closed")},window.RTCPeerConnection.prototype._updateSignalingState=function(newState){this.signalingState=newState;var event=new Event("signalingstatechange");this.dispatchEvent(event),null!==this.onsignalingstatechange&&this.onsignalingstatechange(event)},window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded=function(){var event=new Event("negotiationneeded");this.dispatchEvent(event),null!==this.onnegotiationneeded&&this.onnegotiationneeded(event)},window.RTCPeerConnection.prototype._updateConnectionState=function(){var newState,self=this,states={new:0,closed:0,connecting:0,checking:0,connected:0,completed:0,failed:0};if(this.transceivers.forEach(function(transceiver){states[transceiver.iceTransport.state]++,states[transceiver.dtlsTransport.state]++}),states.connected+=states.completed,newState="new",states.failed>0?newState="failed":states.connecting>0||states.checking>0?newState="connecting":states.disconnected>0?newState="disconnected":states.new>0?newState="new":(states.connected>0||states.completed>0)&&(newState="connected"),newState!==self.iceConnectionState){self.iceConnectionState=newState;var event=new Event("iceconnectionstatechange");this.dispatchEvent(event),null!==this.oniceconnectionstatechange&&this.oniceconnectionstatechange(event)}},window.RTCPeerConnection.prototype.createOffer=function(){var self=this;if(this._pendingOffer)throw new Error("createOffer called while there is a pending offer.");var offerOptions;1===arguments.length&&"function"!=typeof arguments[0]?offerOptions=arguments[0]:3===arguments.length&&(offerOptions=arguments[2]);var tracks=[],numAudioTracks=0,numVideoTracks=0;if(this.localStreams.length&&(numAudioTracks=this.localStreams[0].getAudioTracks().length,numVideoTracks=this.localStreams[0].getVideoTracks().length),offerOptions){if(offerOptions.mandatory||offerOptions.optional)throw new TypeError("Legacy mandatory/optional constraints not supported.");void 0!==offerOptions.offerToReceiveAudio&&(numAudioTracks=offerOptions.offerToReceiveAudio),void 0!==offerOptions.offerToReceiveVideo&&(numVideoTracks=offerOptions.offerToReceiveVideo)}for(this.localStreams.length&&this.localStreams[0].getTracks().forEach(function(track){tracks.push({kind:track.kind,track:track,wantReceive:"audio"===track.kind?numAudioTracks>0:numVideoTracks>0}),"audio"===track.kind?numAudioTracks--:"video"===track.kind&&numVideoTracks--});numAudioTracks>0||numVideoTracks>0;)numAudioTracks>0&&(tracks.push({kind:"audio",wantReceive:!0}),numAudioTracks--),numVideoTracks>0&&(tracks.push({kind:"video",wantReceive:!0}),numVideoTracks--);var sdp=SDPUtils.writeSessionBoilerplate(),transceivers=[];tracks.forEach(function(mline,sdpMLineIndex){var rtpSender,rtpReceiver,track=mline.track,kind=mline.kind,mid=SDPUtils.generateIdentifier(),transports=self.usingBundle&&sdpMLineIndex>0?{iceGatherer:transceivers[0].iceGatherer,iceTransport:transceivers[0].iceTransport,dtlsTransport:transceivers[0].dtlsTransport}:self._createIceAndDtlsTransports(mid,sdpMLineIndex),localCapabilities=RTCRtpSender.getCapabilities(kind),sendEncodingParameters=[{ssrc:1001*(2*sdpMLineIndex+1)}];track&&(rtpSender=new RTCRtpSender(track,transports.dtlsTransport)),mline.wantReceive&&(rtpReceiver=new RTCRtpReceiver(transports.dtlsTransport,kind)),transceivers[sdpMLineIndex]={iceGatherer:transports.iceGatherer,iceTransport:transports.iceTransport,dtlsTransport:transports.dtlsTransport,localCapabilities:localCapabilities,remoteCapabilities:null,rtpSender:rtpSender,rtpReceiver:rtpReceiver,kind:kind,mid:mid,sendEncodingParameters:sendEncodingParameters,recvEncodingParameters:null}}),this.usingBundle&&(sdp+="a=group:BUNDLE "+transceivers.map(function(t){return t.mid}).join(" ")+"\r\n"),tracks.forEach(function(mline,sdpMLineIndex){var transceiver=transceivers[sdpMLineIndex];sdp+=SDPUtils.writeMediaSection(transceiver,transceiver.localCapabilities,"offer",self.localStreams[0])}),this._pendingOffer=transceivers;var desc=new RTCSessionDescription({type:"offer",sdp:sdp});return arguments.length&&"function"==typeof arguments[0]&&window.setTimeout(arguments[0],0,desc),Promise.resolve(desc)},window.RTCPeerConnection.prototype.createAnswer=function(){var self=this,sdp=SDPUtils.writeSessionBoilerplate();this.usingBundle&&(sdp+="a=group:BUNDLE "+this.transceivers.map(function(t){return t.mid}).join(" ")+"\r\n"),this.transceivers.forEach(function(transceiver){if(transceiver.isDatachannel)return void(sdp+="m=application 0 DTLS/SCTP 5000\r\nc=IN IP4 0.0.0.0\r\na=mid:"+transceiver.mid+"\r\n");var commonCapabilities=self._getCommonCapabilities(transceiver.localCapabilities,transceiver.remoteCapabilities);sdp+=SDPUtils.writeMediaSection(transceiver,commonCapabilities,"answer",self.localStreams[0])});var desc=new RTCSessionDescription({type:"answer",sdp:sdp});return arguments.length&&"function"==typeof arguments[0]&&window.setTimeout(arguments[0],0,desc),Promise.resolve(desc)},window.RTCPeerConnection.prototype.addIceCandidate=function(candidate){if(null===candidate)this.transceivers.forEach(function(transceiver){transceiver.iceTransport.addRemoteCandidate({})});else{var mLineIndex=candidate.sdpMLineIndex;if(candidate.sdpMid)for(var i=0;i<this.transceivers.length;i++)if(this.transceivers[i].mid===candidate.sdpMid){mLineIndex=i;break}var transceiver=this.transceivers[mLineIndex];if(transceiver){var cand=Object.keys(candidate.candidate).length>0?SDPUtils.parseCandidate(candidate.candidate):{};if("tcp"===cand.protocol&&(0===cand.port||9===cand.port))return;if("1"!==cand.component)return;"endOfCandidates"===cand.type&&(cand={}),transceiver.iceTransport.addRemoteCandidate(cand);var sections=SDPUtils.splitSections(this.remoteDescription.sdp);sections[mLineIndex+1]+=(cand.type?candidate.candidate.trim():"a=end-of-candidates")+"\r\n",this.remoteDescription.sdp=sections.join("")}}return arguments.length>1&&"function"==typeof arguments[1]&&window.setTimeout(arguments[1],0),Promise.resolve()},window.RTCPeerConnection.prototype.getStats=function(){var promises=[];this.transceivers.forEach(function(transceiver){["rtpSender","rtpReceiver","iceGatherer","iceTransport","dtlsTransport"].forEach(function(method){transceiver[method]&&promises.push(transceiver[method].getStats())})});var cb=arguments.length>1&&"function"==typeof arguments[1]&&arguments[1];return new Promise(function(resolve){var results=new Map;Promise.all(promises).then(function(res){res.forEach(function(result){Object.keys(result).forEach(function(id){results.set(id,result[id]),results[id]=result[id]})}),cb&&window.setTimeout(cb,0,results),resolve(results)})})}}};module.exports={shimPeerConnection:edgeShim.shimPeerConnection,shimGetUserMedia:requirecopy("./getusermedia")}},{"../utils":10,"./getusermedia":6,sdp:1}],6:[function(requirecopy,module,exports){"use strict";module.exports=function(){var shimError_=function(e){return{name:{PermissionDeniedError:"NotAllowedError"}[e.name]||e.name,message:e.message,constraint:e.constraint,toString:function(){return this.name}}},origGetUserMedia=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(c){return origGetUserMedia(c).catch(function(e){return Promise.reject(shimError_(e))})}}},{}],7:[function(requirecopy,module,exports){"use strict";var browserDetails=requirecopy("../utils").browserDetails,firefoxShim={shimOnTrack:function(){"object"!=typeof window||!window.RTCPeerConnection||"ontrack"in window.RTCPeerConnection.prototype||Object.defineProperty(window.RTCPeerConnection.prototype,"ontrack",{get:function(){return this._ontrack},set:function(f){this._ontrack&&(this.removeEventListener("track",this._ontrack),this.removeEventListener("addstream",this._ontrackpoly)),this.addEventListener("track",this._ontrack=f),this.addEventListener("addstream",this._ontrackpoly=function(e){e.stream.getTracks().forEach(function(track){var event=new Event("track");event.track=track,event.receiver={track:track},event.streams=[e.stream],this.dispatchEvent(event)}.bind(this))}.bind(this))}})},shimSourceObject:function(){"object"==typeof window&&(!window.HTMLMediaElement||"srcObject"in window.HTMLMediaElement.prototype||Object.defineProperty(window.HTMLMediaElement.prototype,"srcObject",{get:function(){return this.mozSrcObject},set:function(stream){this.mozSrcObject=stream}}))},shimPeerConnection:function(){if("object"==typeof window&&(window.RTCPeerConnection||window.mozRTCPeerConnection)){window.RTCPeerConnection||(window.RTCPeerConnection=function(pcConfig,pcConstraints){if(browserDetails.version<38&&pcConfig&&pcConfig.iceServers){for(var newIceServers=[],i=0;i<pcConfig.iceServers.length;i++){var server=pcConfig.iceServers[i];if(server.hasOwnProperty("urls"))for(var j=0;j<server.urls.length;j++){var newServer={url:server.urls[j]};0===server.urls[j].indexOf("turn")&&(newServer.username=server.username,newServer.credential=server.credential),newIceServers.push(newServer)}else newIceServers.push(pcConfig.iceServers[i])}pcConfig.iceServers=newIceServers}return new mozRTCPeerConnection(pcConfig,pcConstraints)},window.RTCPeerConnection.prototype=mozRTCPeerConnection.prototype,mozRTCPeerConnection.generateCertificate&&Object.defineProperty(window.RTCPeerConnection,"generateCertificate",{get:function(){return mozRTCPeerConnection.generateCertificate}}),window.RTCSessionDescription=mozRTCSessionDescription,window.RTCIceCandidate=mozRTCIceCandidate),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(method){var nativeMethod=RTCPeerConnection.prototype[method];RTCPeerConnection.prototype[method]=function(){return arguments[0]=new("addIceCandidate"===method?RTCIceCandidate:RTCSessionDescription)(arguments[0]),nativeMethod.apply(this,arguments)}});var nativeAddIceCandidate=RTCPeerConnection.prototype.addIceCandidate;RTCPeerConnection.prototype.addIceCandidate=function(){return null===arguments[0]?Promise.resolve():nativeAddIceCandidate.apply(this,arguments)};var makeMapStats=function(stats){var map=new Map;return Object.keys(stats).forEach(function(key){map.set(key,stats[key]),map[key]=stats[key]}),map},nativeGetStats=RTCPeerConnection.prototype.getStats;RTCPeerConnection.prototype.getStats=function(selector,onSucc,onErr){return nativeGetStats.apply(this,[selector||null]).then(function(stats){return makeMapStats(stats)}).then(onSucc,onErr)}}}};module.exports={shimOnTrack:firefoxShim.shimOnTrack,shimSourceObject:firefoxShim.shimSourceObject,shimPeerConnection:firefoxShim.shimPeerConnection,shimGetUserMedia:requirecopy("./getusermedia")}},{"../utils":10,"./getusermedia":8}],8:[function(requirecopy,module,exports){"use strict";var logging=requirecopy("../utils").log,browserDetails=requirecopy("../utils").browserDetails;module.exports=function(){var shimError_=function(e){return{name:{SecurityError:"NotAllowedError",PermissionDeniedError:"NotAllowedError"}[e.name]||e.name,message:{"The operation is insecure.":"The request is not allowed by the user agent or the platform in the current context."}[e.message]||e.message,constraint:e.constraint,toString:function(){return this.name+(this.message&&": ")+this.message}}},getUserMedia_=function(constraints,onSuccess,onError){var constraintsToFF37_=function(c){if("object"!=typeof c||c.require)return c;var require=[];return Object.keys(c).forEach(function(key){if("require"!==key&&"advanced"!==key&&"mediaSource"!==key){var r=c[key]="object"==typeof c[key]?c[key]:{ideal:c[key]};if(void 0===r.min&&void 0===r.max&&void 0===r.exact||require.push(key),void 0!==r.exact&&("number"==typeof r.exact?r.min=r.max=r.exact:c[key]=r.exact,delete r.exact),void 0!==r.ideal){c.advanced=c.advanced||[];var oc={};"number"==typeof r.ideal?oc[key]={min:r.ideal,max:r.ideal}:oc[key]=r.ideal,c.advanced.push(oc),delete r.ideal,Object.keys(r).length||delete c[key]}}}),require.length&&(c.require=require),c};return constraints=JSON.parse(JSON.stringify(constraints)),browserDetails.version<38&&(logging("spec: "+JSON.stringify(constraints)),constraints.audio&&(constraints.audio=constraintsToFF37_(constraints.audio)),constraints.video&&(constraints.video=constraintsToFF37_(constraints.video)),logging("ff37: "+JSON.stringify(constraints))),navigator.mozGetUserMedia(constraints,onSuccess,function(e){onError(shimError_(e))})},getUserMediaPromise_=function(constraints){return new Promise(function(resolve,reject){getUserMedia_(constraints,resolve,reject)})};if(navigator.mediaDevices||(navigator.mediaDevices={getUserMedia:getUserMediaPromise_,addEventListener:function(){},removeEventListener:function(){}}),navigator.mediaDevices.enumerateDevices=navigator.mediaDevices.enumerateDevices||function(){return new Promise(function(resolve){var infos=[{kind:"audioinput",deviceId:"default",label:"",groupId:""},{kind:"videoinput",deviceId:"default",label:"",groupId:""}];resolve(infos)})},browserDetails.version<41){var orgEnumerateDevices=navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);navigator.mediaDevices.enumerateDevices=function(){return orgEnumerateDevices().then(void 0,function(e){if("NotFoundError"===e.name)return[];throw e})}}if(browserDetails.version<49){var origGetUserMedia=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(c){return origGetUserMedia(c).catch(function(e){return Promise.reject(shimError_(e))})}}navigator.getUserMedia=function(constraints,onSuccess,onError){return browserDetails.version<44?getUserMedia_(constraints,onSuccess,onError):void navigator.mediaDevices.getUserMedia(constraints).then(onSuccess,onError)}}},{"../utils":10}],9:[function(requirecopy,module,exports){"use strict";var safariShim={shimGetUserMedia:function(){navigator.getUserMedia=navigator.webkitGetUserMedia}};module.exports={shimGetUserMedia:safariShim.shimGetUserMedia}},{}],10:[function(requirecopy,module,exports){"use strict";var logDisabled_=!0,utils={disableLog:function(bool){return"boolean"!=typeof bool?new Error("Argument type: "+typeof bool+". Please use a boolean."):(logDisabled_=bool,bool?"adapter.js logging disabled":"adapter.js logging enabled")},log:function(){if("object"==typeof window){if(logDisabled_)return;"undefined"!=typeof console&&"function"==typeof console.log}},extractVersion:function(uastring,expr,pos){var match=uastring.match(expr);return match&&match.length>=pos&&parseInt(match[pos],10)},detectBrowser:function(){var result={};if(result.browser=null,result.version=null,"undefined"==typeof window||!window.navigator)return result.browser="Not a browser.",result;if(navigator.mozGetUserMedia)result.browser="firefox",result.version=this.extractVersion(navigator.userAgent,/Firefox\/([0-9]+)\./,1);else if(navigator.webkitGetUserMedia)if(window.webkitRTCPeerConnection)result.browser="chrome",result.version=this.extractVersion(navigator.userAgent,/Chrom(e|ium)\/([0-9]+)\./,2);else{if(!navigator.userAgent.match(/Version\/(\d+).(\d+)/))return result.browser="Unsupported webkit-based browser with GUM support but no WebRTC support.",result;result.browser="safari",result.version=this.extractVersion(navigator.userAgent,/AppleWebKit\/([0-9]+)\./,1)}else{if(!navigator.mediaDevices||!navigator.userAgent.match(/Edge\/(\d+).(\d+)$/))return result.browser="Not a supported browser.",result;result.browser="edge",result.version=this.extractVersion(navigator.userAgent,/Edge\/(\d+).(\d+)$/,2)}return result}};module.exports={log:utils.log,disableLog:utils.disableLog,browserDetails:utils.detectBrowser(),extractVersion:utils.extractVersion}},{}]},{},[2])(2)}),AdapterJS.parseWebrtcDetectedBrowser(),navigator.mozGetUserMedia?(MediaStreamTrack.getSources=function(successCb){setTimeout(function(){var infos=[{kind:"audio",id:"default",label:"",facing:""},{kind:"video",id:"default",label:"",facing:""}];successCb(infos)},0)},attachMediaStream=function(element,stream){return element.srcObject=stream,element},reattachMediaStream=function(to,from){return to.srcObject=from.srcObject,to},createIceServer=function(url,username,password){var iceServer=null,urlParts=url.split(":");if(0===urlParts[0].indexOf("stun"))iceServer={urls:[url]};else if(0===urlParts[0].indexOf("turn"))if(webrtcDetectedVersion<27){var turnUrlParts=url.split("?");1!==turnUrlParts.length&&0!==turnUrlParts[1].indexOf("transport=udp")||(iceServer={urls:[turnUrlParts[0]],credential:password,username:username})}else iceServer={urls:[url],credential:password,username:username};return iceServer},createIceServers=function(urls,username,password){var iceServers=[];for(i=0;i<urls.length;i++){var iceServer=createIceServer(urls[i],username,password);null!==iceServer&&iceServers.push(iceServer)}return iceServers}):navigator.webkitGetUserMedia?(attachMediaStream=function(element,stream){return webrtcDetectedVersion>=43?element.srcObject=stream:"undefined"!=typeof element.src&&(element.src=URL.createObjectURL(stream)),element},reattachMediaStream=function(to,from){return webrtcDetectedVersion>=43?to.srcObject=from.srcObject:to.src=from.src,to},createIceServer=function(url,username,password){var iceServer=null,urlParts=url.split(":");return 0===urlParts[0].indexOf("stun")?iceServer={url:url}:0===urlParts[0].indexOf("turn")&&(iceServer={url:url,credential:password,username:username}),iceServer},createIceServers=function(urls,username,password){var iceServers=[];if(webrtcDetectedVersion>=34)iceServers={urls:urls,credential:password,username:username};else for(i=0;i<urls.length;i++){var iceServer=createIceServer(urls[i],username,password);null!==iceServer&&iceServers.push(iceServer)}return iceServers}):navigator.mediaDevices&&navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)&&(attachMediaStream=function(element,stream){return element.srcObject=stream,element},reattachMediaStream=function(to,from){return to.srcObject=from.srcObject,to}),attachMediaStream_base=attachMediaStream,"opera"===webrtcDetectedBrowser&&(attachMediaStream_base=function(element,stream){webrtcDetectedVersion>38?element.srcObject=stream:"undefined"!=typeof element.src&&(element.src=URL.createObjectURL(stream))}),attachMediaStream=function(element,stream){return"chrome"!==webrtcDetectedBrowser&&"opera"!==webrtcDetectedBrowser||stream?attachMediaStream_base(element,stream):element.src="",element},reattachMediaStream_base=reattachMediaStream,reattachMediaStream=function(to,from){return reattachMediaStream_base(to,from),to},window.attachMediaStream=attachMediaStream,window.reattachMediaStream=reattachMediaStream,window.getUserMedia=function(constraints,onSuccess,onFailure){navigator.getUserMedia(constraints,onSuccess,onFailure)},AdapterJS.attachMediaStream=attachMediaStream,AdapterJS.reattachMediaStream=reattachMediaStream,AdapterJS.getUserMedia=getUserMedia,"undefined"==typeof Promise&&(requestUserMedia=null),AdapterJS.maybeThroughWebRTCReady()),"undefined"!=typeof exports&&(module.exports=AdapterJS);

/*** EXPORTS FROM exports-loader ***/
module.exports = AdapterJS;

/***/ }),
/* 205 */
/***/ (function(module, exports) {

/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = function arrayEquals(array) {
    // if the other array is a falsy value, return
    if (!array)
        return false;

    // compare lengths - can save a lot of time
    if (this.length != array.length)
        return false;

    for (var i = 0, l = this.length; i < l; i++) {
        // Check if we have nested arrays
        if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!arrayEquals.apply(this[i], [array[i]]))
                return false;
        } else if (this[i] != array[i]) {
            // Warning - two different object instances will never be equal:
            // {x:20} != {x:20}
            return false;
        }
    }
    return true;
};



/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

exports.Interop = __webpack_require__(207);


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* global RTCSessionDescription */
/* jshint -W097 */


var transform = __webpack_require__(208);
var arrayEquals = __webpack_require__(205);

function Interop() {

    /**
     * This map holds the most recent Unified Plan offer/answer SDP that was
     * converted to Plan B, with the SDP type ('offer' or 'answer') as keys and
     * the SDP string as values.
     *
     * @type {{}}
     */
    this.cache = {};
}

module.exports = Interop;

/**
 * Returns the index of the first m-line with the given media type and with a
 * direction which allows sending, in the last Unified Plan description with
 * type "answer" converted to Plan B. Returns {null} if there is no saved
 * answer, or if none of its m-lines with the given type allow sending.
 * @param type the media type ("audio" or "video").
 * @returns {*}
 */
Interop.prototype.getFirstSendingIndexFromAnswer = function(type) {
    if (!this.cache.answer) {
        return null;
    }

    var session = transform.parse(this.cache.answer);
    if (session && session.media && Array.isArray(session.media)){
        for (var i = 0; i < session.media.length; i++) {
            if (session.media[i].type == type &&
                (!session.media[i].direction /* default to sendrecv */ ||
                    session.media[i].direction === 'sendrecv' ||
                    session.media[i].direction === 'sendonly')){
                return i;
            }
        }
    }

    return null;
};

/**
 * This method transforms a Unified Plan SDP to an equivalent Plan B SDP. A
 * PeerConnection wrapper transforms the SDP to Plan B before passing it to the
 * application.
 *
 * @param desc
 * @returns {*}
 */
Interop.prototype.toPlanB = function(desc) {
    var self = this;
    //#region Preliminary input validation.

    if (typeof desc !== 'object' || desc === null ||
        typeof desc.sdp !== 'string') {
        console.warn('An empty description was passed as an argument.');
        return desc;
    }

    // Objectify the SDP for easier manipulation.
    var session = transform.parse(desc.sdp);

    // If the SDP contains no media, there's nothing to transform.
    if (typeof session.media === 'undefined' ||
        !Array.isArray(session.media) || session.media.length === 0) {
        console.warn('The description has no media.');
        return desc;
    }

    // Try some heuristics to "make sure" this is a Unified Plan SDP. Plan B
    // SDP has a video, an audio and a data "channel" at most.
    if (session.media.length <= 3 && session.media.every(function(m) {
            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;
        })) {
        console.warn('This description does not look like Unified Plan.');
        return desc;
    }

    //#endregion

    // HACK https://bugzilla.mozilla.org/show_bug.cgi?id=1113443
    var sdp = desc.sdp;
    var rewrite = false;
    for (var i = 0; i < session.media.length; i++) {
        var uLine = session.media[i];
        uLine.rtp.forEach(function(rtp) {
            if (rtp.codec === 'NULL')
            {
                rewrite = true;
                var offer = transform.parse(self.cache['offer']);
                rtp.codec = offer.media[i].rtp[0].codec;
            }
        });
    };
    if (rewrite) {
        sdp = transform.write(session);
    }

    // Unified Plan SDP is our "precious". Cache it for later use in the Plan B
    // -> Unified Plan transformation.
    this.cache[desc.type] = sdp;

    //#region Convert from Unified Plan to Plan B.

    // We rebuild the session.media array.
    var media = session.media;
    session.media = [];

    // Associative array that maps channel types to channel objects for fast
    // access to channel objects by their type, e.g. type2bl['audio']->channel
    // obj.
    var type2bl = {};

    // Used to build the group:BUNDLE value after the channels construction
    // loop.
    var types = [];

    // Implode the Unified Plan m-lines/tracks into Plan B channels.
    media.forEach(function(uLine) {

        // rtcp-mux is required in the Plan B SDP.
        if ((typeof uLine.rtcpMux !== 'string' ||
            uLine.rtcpMux !== 'rtcp-mux') &&
            uLine.direction !== 'inactive') {
            throw new Error('Cannot convert to Plan B because m-lines ' +
                'without the rtcp-mux attribute were found.');
        }

        if (uLine.type === 'application') {
            session.media.push(uLine);
            types.push(uLine.mid);
            return;
        }

        // If we don't have a channel for this uLine.type, then use this
        // uLine as the channel basis.
        if (typeof type2bl[uLine.type] === 'undefined') {
            type2bl[uLine.type] = uLine;
        }

        // Add sources to the channel and handle a=msid.
        if (typeof uLine.sources === 'object') {
            Object.keys(uLine.sources).forEach(function(ssrc) {
                if (typeof type2bl[uLine.type].sources !== 'object')
                    type2bl[uLine.type].sources = {};

                // Assign the sources to the channel.
                type2bl[uLine.type].sources[ssrc] =
                    uLine.sources[ssrc];

                if (typeof uLine.msid !== 'undefined') {
                    // In Plan B the msid is an SSRC attribute. Also, we don't
                    // care about the obsolete label and mslabel attributes.
                    //
                    // Note that it is not guaranteed that the uLine will
                    // have an msid. recvonly channels in particular don't have
                    // one.
                    type2bl[uLine.type].sources[ssrc].msid =
                        uLine.msid;
                }
                // NOTE ssrcs in ssrc groups will share msids, as
                // draft-uberti-rtcweb-plan-00 mandates.
            });
        }

        // Add ssrc groups to the channel.
        if (typeof uLine.ssrcGroups !== 'undefined' &&
                Array.isArray(uLine.ssrcGroups)) {

            // Create the ssrcGroups array, if it's not defined.
            if (typeof type2bl[uLine.type].ssrcGroups === 'undefined' ||
                    !Array.isArray(type2bl[uLine.type].ssrcGroups)) {
                type2bl[uLine.type].ssrcGroups = [];
            }

            type2bl[uLine.type].ssrcGroups =
                type2bl[uLine.type].ssrcGroups.concat(
                    uLine.ssrcGroups);
        }

        if (type2bl[uLine.type] === uLine) {
            // Copy ICE related stuff from the principal media line.
            uLine.candidates = media[0].candidates;
            uLine.iceUfrag = media[0].iceUfrag;
            uLine.icePwd = media[0].icePwd;
            uLine.fingerprint = media[0].fingerprint;

            // Plan B mids are in ['audio', 'video', 'data']
            uLine.mid = uLine.type;

            // Plan B doesn't support/need the bundle-only attribute.
            delete uLine.bundleOnly;

            // In Plan B the msid is an SSRC attribute.
            delete uLine.msid;

            // Used to build the group:BUNDLE value after this loop.
            types.push(uLine.type);

            // Add the channel to the new media array.
            session.media.push(uLine);
        }
    });

    // We regenerate the BUNDLE group with the new mids.
    session.groups.some(function(group) {
        if (group.type === 'BUNDLE') {
            group.mids = types.join(' ');
            return true;
        }
    });

    // msid semantic
    session.msidSemantic = {
        semantic: 'WMS',
        token: '*'
    };

    var resStr = transform.write(session);

    return new RTCSessionDescription({
        type: desc.type,
        sdp: resStr
    });

    //#endregion
};

/**
 * This method transforms a Plan B SDP to an equivalent Unified Plan SDP. A
 * PeerConnection wrapper transforms the SDP to Unified Plan before passing it
 * to FF.
 *
 * @param desc
 * @returns {*}
 */
Interop.prototype.toUnifiedPlan = function(desc) {
    var self = this;
    //#region Preliminary input validation.

    if (typeof desc !== 'object' || desc === null ||
        typeof desc.sdp !== 'string') {
        console.warn('An empty description was passed as an argument.');
        return desc;
    }

    var session = transform.parse(desc.sdp);

    // If the SDP contains no media, there's nothing to transform.
    if (typeof session.media === 'undefined' ||
        !Array.isArray(session.media) || session.media.length === 0) {
        console.warn('The description has no media.');
        return desc;
    }

    // Try some heuristics to "make sure" this is a Plan B SDP. Plan B SDP has
    // a video, an audio and a data "channel" at most.
    if (session.media.length > 3 || !session.media.every(function(m) {
            return ['video', 'audio', 'data'].indexOf(m.mid) !== -1;
        })) {
        console.warn('This description does not look like Plan B.');
        return desc;
    }

    // Make sure this Plan B SDP can be converted to a Unified Plan SDP.
    var mids = [];
    session.media.forEach(function(m) {
        mids.push(m.mid);
    });

    var hasBundle = false;
    if (typeof session.groups !== 'undefined' &&
        Array.isArray(session.groups)) {
        hasBundle = session.groups.every(function(g) {
            return g.type !== 'BUNDLE' ||
                arrayEquals.apply(g.mids.sort(), [mids.sort()]);
        });
    }

    if (!hasBundle) {
        throw new Error("Cannot convert to Unified Plan because m-lines that" +
            " are not bundled were found.");
    }

    //#endregion


    //#region Convert from Plan B to Unified Plan.

    // Unfortunately, a Plan B offer/answer doesn't have enough information to
    // rebuild an equivalent Unified Plan offer/answer.
    //
    // For example, if this is a local answer (in Unified Plan style) that we
    // convert to Plan B prior to handing it over to the application (the
    // PeerConnection wrapper called us, for instance, after a successful
    // createAnswer), we want to remember the m-line at which we've seen the
    // (local) SSRC. That's because when the application wants to do call the
    // SLD method, forcing us to do the inverse transformation (from Plan B to
    // Unified Plan), we need to know to which m-line to assign the (local)
    // SSRC. We also need to know all the other m-lines that the original
    // answer had and include them in the transformed answer as well.
    //
    // Another example is if this is a remote offer that we convert to Plan B
    // prior to giving it to the application, we want to remember the mid at
    // which we've seen the (remote) SSRC.
    //
    // In the iteration that follows, we use the cached Unified Plan (if it
    // exists) to assign mids to ssrcs.

    var cached;
    if (typeof this.cache[desc.type] !== 'undefined') {
        cached = transform.parse(this.cache[desc.type]);
    }

    var recvonlySsrcs = {
        audio: {},
        video: {}
    };

    // A helper map that sends mids to m-line objects. We use it later to
    // rebuild the Unified Plan style session.media array.
    var mid2ul = {};
    session.media.forEach(function(bLine) {
        if ((typeof bLine.rtcpMux !== 'string' ||
            bLine.rtcpMux !== 'rtcp-mux') &&
            bLine.direction !== 'inactive') {
            throw new Error("Cannot convert to Unified Plan because m-lines " +
                "without the rtcp-mux attribute were found.");
        }

        if (bLine.type === 'application') {
            mid2ul[bLine.mid] = bLine;
            return;
        }

        // With rtcp-mux and bundle all the channels should have the same ICE
        // stuff.
        var sources = bLine.sources;
        var ssrcGroups = bLine.ssrcGroups;
        var candidates = bLine.candidates;
        var iceUfrag = bLine.iceUfrag;
        var icePwd = bLine.icePwd;
        var fingerprint = bLine.fingerprint;
        var port = bLine.port;

        // We'll use the "bLine" object as a prototype for each new "mLine"
        // that we create, but first we need to clean it up a bit.
        delete bLine.sources;
        delete bLine.ssrcGroups;
        delete bLine.candidates;
        delete bLine.iceUfrag;
        delete bLine.icePwd;
        delete bLine.fingerprint;
        delete bLine.port;
        delete bLine.mid;

        // inverted ssrc group map
        var ssrc2group = {};
        if (typeof ssrcGroups !== 'undefined' && Array.isArray(ssrcGroups)) {
            ssrcGroups.forEach(function (ssrcGroup) {

                // TODO(gp) find out how to receive simulcast with FF. For the
                // time being, hide it.
                if (ssrcGroup.semantics === 'SIM') {
                    return;
                }

                // XXX This might brake if an SSRC is in more than one group
                // for some reason.
                if (typeof ssrcGroup.ssrcs !== 'undefined' &&
                    Array.isArray(ssrcGroup.ssrcs)) {
                    ssrcGroup.ssrcs.forEach(function (ssrc) {
                        if (typeof ssrc2group[ssrc] === 'undefined') {
                            ssrc2group[ssrc] = [];
                        }

                        ssrc2group[ssrc].push(ssrcGroup);
                    });
                }
            });
        }

        // ssrc to m-line index.
        var ssrc2ml = {};

        if (typeof sources === 'object') {

            // Explode the Plan B channel sources with one m-line per source.
            Object.keys(sources).forEach(function(ssrc) {

                // The (unified) m-line for this SSRC. We either create it from
                // scratch or, if it's a grouped SSRC, we re-use a related
                // mline. In other words, if the source is grouped with another
                // source, put the two together in the same m-line.
                var uLine;

                // We assume here that we are the answerer in the O/A, so any
                // offers which we translate come from the remote side, while
                // answers are local. So the check below is to make that we
                // handle receive-only SSRCs in a special way only if they come
                // from the remote side.
                if (desc.type==='offer') {
                    // We want to detect SSRCs which are used by a remote peer
                    // in an m-line with direction=recvonly (i.e. they are
                    // being used for RTCP only).
                    // This information would have gotten lost if the remote
                    // peer used Unified Plan and their local description was
                    // translated to Plan B. So we use the lack of an MSID
                    // attribute to deduce a "receive only" SSRC.
                    if (!sources[ssrc].msid) {
                        recvonlySsrcs[bLine.type][ssrc] = sources[ssrc];
                        // Receive-only SSRCs must not create new m-lines. We
                        // will assign them to an existing m-line later.
                        return;
                    }
                }

                if (typeof ssrc2group[ssrc] !== 'undefined' &&
                    Array.isArray(ssrc2group[ssrc])) {
                    ssrc2group[ssrc].some(function (ssrcGroup) {
                        // ssrcGroup.ssrcs *is* an Array, no need to check
                        // again here.
                        return ssrcGroup.ssrcs.some(function (related) {
                            if (typeof ssrc2ml[related] === 'object') {
                                uLine = ssrc2ml[related];
                                return true;
                            }
                        });
                    });
                }

                if (typeof uLine === 'object') {
                    // the m-line already exists. Just add the source.
                    uLine.sources[ssrc] = sources[ssrc];
                    delete sources[ssrc].msid;
                } else {
                    // Use the "bLine" as a prototype for the "uLine".
                    uLine = Object.create(bLine);
                    ssrc2ml[ssrc] = uLine;

                    if (typeof sources[ssrc].msid !== 'undefined') {
                        // Assign the msid of the source to the m-line. Note
                        // that it is not guaranteed that the source will have
                        // msid. In particular "recvonly" sources don't have an
                        // msid. Note that "recvonly" is a term only defined
                        // for m-lines.
                        uLine.msid = sources[ssrc].msid;
                        uLine.direction = 'sendrecv';
                        delete sources[ssrc].msid;
                    }

                    // We assign one SSRC per media line.
                    uLine.sources = {};
                    uLine.sources[ssrc] = sources[ssrc];
                    uLine.ssrcGroups = ssrc2group[ssrc];

                    // Use the cached Unified Plan SDP (if it exists) to assign
                    // SSRCs to mids.
                    if (typeof cached !== 'undefined' &&
                        typeof cached.media !== 'undefined' &&
                        Array.isArray(cached.media)) {

                        cached.media.forEach(function (m) {
                            if (typeof m.sources === 'object') {
                                Object.keys(m.sources).forEach(function (s) {
                                    if (s === ssrc) {
                                        uLine.mid = m.mid;
                                    }
                                });
                            }
                        });
                    }

                    if (typeof uLine.mid === 'undefined') {

                        // If this is an SSRC that we see for the first time
                        // assign it a new mid. This is typically the case when
                        // this method is called to transform a remote
                        // description for the first time or when there is a
                        // new SSRC in the remote description because a new
                        // peer has joined the conference. Local SSRCs should
                        // have already been added to the map in the toPlanB
                        // method.
                        //
                        // Because FF generates answers in Unified Plan style,
                        // we MUST already have a cached answer with all the
                        // local SSRCs mapped to some m-line/mid.

                        if (desc.type === 'answer') {
                            throw new Error("An unmapped SSRC was found.");
                        }

                        uLine.mid = [bLine.type, '-', ssrc].join('');
                    }

                    // Include the candidates in the 1st media line.
                    uLine.candidates = candidates;
                    uLine.iceUfrag = iceUfrag;
                    uLine.icePwd = icePwd;
                    uLine.fingerprint = fingerprint;
                    uLine.port = port;

                    mid2ul[uLine.mid] = uLine;
                }
            });
        }
    });

    // Rebuild the media array in the right order and add the missing mLines
    // (missing from the Plan B SDP).
    session.media = [];
    mids = []; // reuse

    if (desc.type === 'answer') {

        // The media lines in the answer must match the media lines in the
        // offer. The order is important too. Here we assume that Firefox is
        // the answerer, so we merely have to use the reconstructed (unified)
        // answer to update the cached (unified) answer accordingly.
        //
        // In the general case, one would have to use the cached (unified)
        // offer to find the m-lines that are missing from the reconstructed
        // answer, potentially grabbing them from the cached (unified) answer.
        // One has to be careful with this approach because inactive m-lines do
        // not always have an mid, making it tricky (impossible?) to find where
        // exactly and which m-lines are missing from the reconstructed answer.

        for (var i = 0; i < cached.media.length; i++) {
            var uLine = cached.media[i];

            if (typeof mid2ul[uLine.mid] === 'undefined') {

                // The mid isn't in the reconstructed (unified) answer.
                // This is either a (unified) m-line containing a remote
                // track only, or a (unified) m-line containing a remote
                // track and a local track that has been removed.
                // In either case, it MUST exist in the cached
                // (unified) answer.
                //
                // In case this is a removed local track, clean-up
                // the (unified) m-line and make sure it's 'recvonly' or
                // 'inactive'.

                delete uLine.msid;
                delete uLine.sources;
                delete uLine.ssrcGroups;
                if (!uLine.direction
                    || uLine.direction === 'sendrecv')
                    uLine.direction = 'recvonly';
                else if (uLine.direction === 'sendonly')
                    uLine.direction = 'inactive';
            } else {
                // This is an (unified) m-line/channel that contains a local
                // track (sendrecv or sendonly channel) or it's a unified
                // recvonly m-line/channel. In either case, since we're
                // going from PlanB -> Unified Plan this m-line MUST
                // exist in the cached answer.
            }

            session.media.push(uLine);

            if (typeof uLine.mid === 'string') {
                // inactive lines don't/may not have an mid.
                mids.push(uLine.mid);
            }
        }
    } else {

        // SDP offer/answer (and the JSEP spec) forbids removing an m-section
        // under any circumstances. If we are no longer interested in sending a
        // track, we just remove the msid and ssrc attributes and set it to
        // either a=recvonly (as the reofferer, we must use recvonly if the
        // other side was previously sending on the m-section, but we can also
        // leave the possibility open if it wasn't previously in use), or
        // a=inactive.

        if (typeof cached !== 'undefined' &&
            typeof cached.media !== 'undefined' &&
            Array.isArray(cached.media)) {
            cached.media.forEach(function(uLine) {
                mids.push(uLine.mid);
                if (typeof mid2ul[uLine.mid] !== 'undefined') {
                    session.media.push(mid2ul[uLine.mid]);
                } else {
                    delete uLine.msid;
                    delete uLine.sources;
                    delete uLine.ssrcGroups;
                    if (!uLine.direction
                        || uLine.direction === 'sendrecv')
                        uLine.direction = 'recvonly';
                    if (!uLine.direction
                        || uLine.direction === 'sendonly')
                        uLine.direction = 'inactive';
                    session.media.push(uLine);
                }
            });
        }

        // Add all the remaining (new) m-lines of the transformed SDP.
        Object.keys(mid2ul).forEach(function(mid) {
            if (mids.indexOf(mid) === -1) {
                mids.push(mid);
                if (mid2ul[mid].direction === 'recvonly') {
                    // This is a remote recvonly channel. Add its SSRC to the
                    // appropriate sendrecv or sendonly channel.
                    // TODO(gp) what if we don't have sendrecv/sendonly
                    // channel?

                    session.media.some(function (uLine) {
                        if ((uLine.direction === 'sendrecv' ||
                            uLine.direction === 'sendonly') &&
                            uLine.type === mid2ul[mid].type) {

                            // mid2ul[mid] shouldn't have any ssrc-groups
                            Object.keys(mid2ul[mid].sources).forEach(
                                function (ssrc) {
                                uLine.sources[ssrc] =
                                    mid2ul[mid].sources[ssrc];
                            });

                            return true;
                        }
                    });
                } else {
                    session.media.push(mid2ul[mid]);
                }
            }
        });
    }

    // After we have constructed the Plan Unified m-lines we can figure out
    // where (in which m-line) to place the 'recvonly SSRCs'.
    // Note: we assume here that we are the answerer in the O/A, so any offers
    // which we translate come from the remote side, while answers are local
    // (and so our last local description is cached as an 'answer').
    ["audio", "video"].forEach(function (type) {
        if (!session || !session.media || !Array.isArray(session.media))
            return;

        var idx = null;
        if (Object.keys(recvonlySsrcs[type]).length > 0) {
            idx = self.getFirstSendingIndexFromAnswer(type);
            if (idx === null){
                // If this is the first offer we receive, we don't have a
                // cached answer. Assume that we will be sending media using
                // the first m-line for each media type.

                for (var i = 0; i < session.media.length; i++) {
                    if (session.media[i].type === type) {
                        idx = i;
                        break;
                    }
                }
            }
        }

        if (idx && session.media.length > idx) {
            var mLine = session.media[idx];
            Object.keys(recvonlySsrcs[type]).forEach(function(ssrc) {
                if (mLine.sources && mLine.sources[ssrc]) {
                    console.warn("Replacing an existing SSRC.");
                }
                if (!mLine.sources) {
                    mLine.sources = {};
                }

                mLine.sources[ssrc] = recvonlySsrcs[type][ssrc];
            });
        }
    });

    // We regenerate the BUNDLE group (since we regenerated the mids)
    session.groups.some(function(group) {
        if (group.type === 'BUNDLE') {
            group.mids = mids.join(' ');
            return true;
        }
    });

    // msid semantic
    session.msidSemantic = {
        semantic: 'WMS',
        token: '*'
    };

    var resStr = transform.write(session);

    // Cache the transformed SDP (Unified Plan) for later re-use in this
    // function.
    this.cache[desc.type] = resStr;

    return new RTCSessionDescription({
        type: desc.type,
        sdp: resStr
    });

    //#endregion
};


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright @ 2015 Atlassian Pty Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var transform = __webpack_require__(209);

exports.write = function(session, opts) {

  if (typeof session !== 'undefined' &&
      typeof session.media !== 'undefined' &&
      Array.isArray(session.media)) {

    session.media.forEach(function (mLine) {
      // expand sources to ssrcs
      if (typeof mLine.sources !== 'undefined' &&
        Object.keys(mLine.sources).length !== 0) {
          mLine.ssrcs = [];
          Object.keys(mLine.sources).forEach(function (ssrc) {
            var source = mLine.sources[ssrc];
            Object.keys(source).forEach(function (attribute) {
              mLine.ssrcs.push({
                id: ssrc,
                attribute: attribute,
                value: source[attribute]
              });
            });
          });
          delete mLine.sources;
        }

      // join ssrcs in ssrc groups
      if (typeof mLine.ssrcGroups !== 'undefined' &&
        Array.isArray(mLine.ssrcGroups)) {
          mLine.ssrcGroups.forEach(function (ssrcGroup) {
            if (typeof ssrcGroup.ssrcs !== 'undefined' &&
                Array.isArray(ssrcGroup.ssrcs)) {
              ssrcGroup.ssrcs = ssrcGroup.ssrcs.join(' ');
            }
          });
        }
    });
  }

  // join group mids
  if (typeof session !== 'undefined' &&
      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {

    session.groups.forEach(function (g) {
      if (typeof g.mids !== 'undefined' && Array.isArray(g.mids)) {
        g.mids = g.mids.join(' ');
      }
    });
  }

  return transform.write(session, opts);
};

exports.parse = function(sdp) {
  var session = transform.parse(sdp);

  if (typeof session !== 'undefined' && typeof session.media !== 'undefined' &&
      Array.isArray(session.media)) {

    session.media.forEach(function (mLine) {
      // group sources attributes by ssrc
      if (typeof mLine.ssrcs !== 'undefined' && Array.isArray(mLine.ssrcs)) {
        mLine.sources = {};
        mLine.ssrcs.forEach(function (ssrc) {
          if (!mLine.sources[ssrc.id])
          mLine.sources[ssrc.id] = {};
        mLine.sources[ssrc.id][ssrc.attribute] = ssrc.value;
        });

        delete mLine.ssrcs;
      }

      // split ssrcs in ssrc groups
      if (typeof mLine.ssrcGroups !== 'undefined' &&
        Array.isArray(mLine.ssrcGroups)) {
          mLine.ssrcGroups.forEach(function (ssrcGroup) {
            if (typeof ssrcGroup.ssrcs === 'string') {
              ssrcGroup.ssrcs = ssrcGroup.ssrcs.split(' ');
            }
          });
        }
    });
  }
  // split group mids
  if (typeof session !== 'undefined' &&
      typeof session.groups !== 'undefined' && Array.isArray(session.groups)) {

    session.groups.forEach(function (g) {
      if (typeof g.mids === 'string') {
        g.mids = g.mids.split(' ');
      }
    });
  }

  return session;
};



/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var parser = __webpack_require__(210);
var writer = __webpack_require__(211);

exports.write = writer;
exports.parse = parser.parse;
exports.parseFmtpConfig = parser.parseFmtpConfig;
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = __webpack_require__(175);
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var fmtpReducer = function (acc, expr) {
  var s = expr.split('=');
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  }
  return acc;
};

exports.parseFmtpConfig = function (str) {
  return str.split(/\;\s?/).reduce(fmtpReducer, {});
};

exports.parsePayloads = function (str) {
  return str.split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var grammar = __webpack_require__(175);

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
      case '%%':
        return '%';
      case '%s':
        return String(arg);
      case '%d':
        return Number(arg);
      case '%v':
        return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // "v=0" must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = " "; // "s= " must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = "";
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};


/***/ }),
/* 212 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["calculateClientPower"] = calculateClientPower;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_math_log2__ = __webpack_require__(287);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_math_log2___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_math_log2__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_webrtc_dataHub__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_webrtc_attachmentManager__ = __webpack_require__(192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_conference_raft__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_conference_switcher__ = __webpack_require__(261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_conference_meshTopology__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_conference_conferencePeers__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_conference_conferenceConnectionPool__ = __webpack_require__(259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_conference_conferenceConnection__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_conference_voiceActivityDetector__ = __webpack_require__(262);

























var TAG = 'conference';

var SIGNALING_STATE_SEARCHING = 'searching';
var SIGNALING_STATE_JOINING = 'joining';
var SIGNALING_STATE_MEMBER = 'member';
var SIGNALING_STATE_CLOSED = 'closed';

// We haven't found a cluster to join yet
var CONNECTION_STATE_SIGNALING = 'signaling';
// Connecting to the cluster
var CONNECTION_STATE_CONNECTING = 'connecting';
// Connected to at least one other member of the current cluster
var CONNECTION_STATE_CONNECTED = 'connected';
// Duh
var CONNECTION_STATE_CLOSED = 'closed';

var MEMBER_ADD_TTL_MS = 20 * 1000;

function calculateClientPower(navigator) {
  if (navigator.hardwareConcurrency) {
    return __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_math_log2___default()(navigator.hardwareConcurrency) | 0;
  } else if (navigator.userAgent.match(/iPad|iPhone/)) {
    return 2;
  } else {
    return 2;
  }
}

var switcherAttachPoint = '__c3-switcher';

/**
 * A peer-to-peer WebRTC call between multiple users.
 *
 * The main role of the conference is to manage a set of connections to other
 * peers in the conference. Just like with {@link Call}, functionality is
 * added via {@link RtcComponent}s that are attached to the conference
 * using {@link Conference#attach}. An exception to this is the {@link Switcher},
 * which provides specialized media streaming capabilities for conferences.
 *
 * A conference always happens within a {@link Room}, and there's is only
 * a single conference in a room at a given time. Any member of the room
 * that calls {@link Room#startConference} will join the conference, as long
 * as they have permission to do so, which is default.
 *
 * @example <caption>Example of starting a conference with switching, broadcasting and data sharing.</caption>
 * let conference = room.startConference({
 *   switcherMode: 'automatic', // Use voice-activated switching
 * })
 *
 * let mediaSource = new cct.DeviceSource({
 *   audio: true,
 *   video: true,
 * })
 *
 * // We use a splitter to get hold of separate audio and video streams
 * let streamSplitter = new cct.StreamSplitter()
 * mediaSource.connect(streamSplitter)
 *
 * // The conference switcher can send a single high-quality media stream
 * streamSplitter.videoOutput.connect(conference.switcher)
 * // It also receives a high-quality video stream from the current speaker.
 * conference.switcher.connect(largeVideoView)
 *
 * // See MediaBroadcaster for how to broadcast audio
 *
 * // Use a DataShare to share data with all participants.
 * let data = new cct.DataShare()
 * conference.attach('test-data', data)
 * data.on('update', ({key, value}) => console.log(`updated test-data:s ${key}=${value}`))
 * data.set('some-key', 'some-value')
 *
 * @abstract
 * @class Conference
 * @extends EventEmitter
 */

var Conference = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(Conference, _EmitterMixin);

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(Conference, null, [{
    key: 'create',
    value: function create(config) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].options('Conference.create', 'config', config).optString('userId').optArray('iceServers').optFunc('iceCandidateFilter').optString('switcherMode').func('onSignalingMessage');

      var _config$userId = config.userId,
          userId = _config$userId === undefined ? 'self' : _config$userId,
          _config$iceServers = config.iceServers,
          iceServers = _config$iceServers === undefined ? null : _config$iceServers,
          _config$iceCandidateF = config.iceCandidateFilter,
          iceCandidateFilter = _config$iceCandidateF === undefined ? null : _config$iceCandidateF,
          switcherMode = config.switcherMode,
          onSignalingMessage = config.onSignalingMessage;


      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["priv"])(Conference, {
        userId: userId,
        iceServers: iceServers,
        iceCandidateFilter: iceCandidateFilter,
        switcherMode: switcherMode,
        onSignalingMessage: onSignalingMessage
      });
    }
  }]);

  function Conference(priv, deps) {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, Conference);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Conference.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(Conference)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["assertPriv"])('Conference', priv);

    _this._onRaftStateChange = _this._onRaftStateChange.bind(_this);
    _this._onRaftMembersChange = _this._onRaftMembersChange.bind(_this);
    _this._onRaftLeadershipChange = _this._onRaftLeadershipChange.bind(_this);
    _this._onAttachmentUpdate = _this._onAttachmentUpdate.bind(_this);
    _this._onPeersUpdate = _this._onPeersUpdate.bind(_this);
    _this._onDisconnected = _this._onDisconnected.bind(_this);
    _this._invitePeer = _this._invitePeer.bind(_this);

    // this._id = randomString(16)
    _this._connectionState = CONNECTION_STATE_SIGNALING;
    _this._signalingState = null;
    _this._joiningCluster = null;
    _this._ownId = deps.userId;
    _this._onClosed = deps.onClosed;
    _this._iceServers = deps.iceServers;
    _this._onSignalingMessage = deps.onSignalingMessage;
    _this._iceCandidateFilter = deps.iceCandidateFilter;
    _this._statsFormatterFactory = deps.statsFormatterFactory;

    _this._peers = new __WEBPACK_IMPORTED_MODULE_16_conference_conferencePeers__["a" /* default */]({
      ownId: _this._ownId,
      onUpdate: _this._onPeersUpdate
    });

    _this._voiceActivityDetector = new __WEBPACK_IMPORTED_MODULE_19_conference_voiceActivityDetector__["a" /* default */]({
      active: __WEBPACK_IMPORTED_MODULE_14_conference_switcher__["a" /* default */].modeUsesVoiceDetection(deps.switcherMode)
    });

    _this._meshTopology = new __WEBPACK_IMPORTED_MODULE_15_conference_meshTopology__["c" /* default */]({
      power: calculateClientPower(navigator),
      ownId: _this._ownId,
      voiceActivityDetector: _this._voiceActivityDetector
    });

    _this._connectionPool = new __WEBPACK_IMPORTED_MODULE_17_conference_conferenceConnectionPool__["a" /* default */]({
      ownId: _this._ownId,
      connectionFactory: _this._createConnection.bind(_this),
      meshTopology: _this._meshTopology,
      onRaftMessage: function onRaftMessage(raftId, message) {
        return _this._raft.handleMessage(raftId, message);
      },
      onDisconnected: _this._onDisconnected,
      onInvite: _this._invitePeer,
      onBestConnection: function onBestConnection(connection) {
        if (connection) {
          _this._voiceActivityDetector.setPeerConnection(connection._peerConnection);
        } else {
          _this._voiceActivityDetector.setPeerConnection(null);
        }
      }
    });

    _this._raft = new __WEBPACK_IMPORTED_MODULE_13_conference_raft__["a" /* default */]({
      id: _this._ownId,
      meshTopology: _this._meshTopology,
      onMessage: _this._connectionPool.handleRaftMessage,
      onStateChange: _this._onRaftStateChange,
      onMembersChange: _this._onRaftMembersChange,
      onLeadershipChange: _this._onRaftLeadershipChange,
      onReplicationDeadlock: _this._onDisconnected
    });

    _this._switcher = new __WEBPACK_IMPORTED_MODULE_14_conference_switcher__["a" /* default */]({
      ownId: _this._ownId,
      raft: _this._raft,
      mode: deps.switcherMode,
      voiceActivityDetector: _this._voiceActivityDetector
    });

    _this._attachmentManager = new __WEBPACK_IMPORTED_MODULE_12_webrtc_attachmentManager__["b" /* default */]({
      ownId: _this._ownId,
      type: 'conference',
      dataHub: new __WEBPACK_IMPORTED_MODULE_11_webrtc_dataHub__["b" /* default */](),
      onUpdate: _this._onAttachmentUpdate
    });

    _this._attachmentManager.attach(switcherAttachPoint, _this._switcher._component);
    return _this;
  }

  /**
   * Emitted when there is an error within the conference, e.g. the signaling fails.
   *
   * @event Conference#error
   * @param {Error} error - The error.
   */

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(Conference, [{
    key: 'toString',
    value: function toString() {
      return 'conference{ownId=' + this._ownId + ',state=' + this._signalingState + '}';
    }

    /**
     * Attach a component that will be shared in the conference.
     *
     * @function Conference#attach
     * @param {string} name - Name of the attachment point.
     * @param {RtcComponent} component - A component to attach.
     */

  }, {
    key: 'attach',
    value: function attach(name, component) {
      if (name === switcherAttachPoint) {
        __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].error('Conference.attach', 'name', 'not use reserved name ' + name);
      }
      if (!this._attachmentManager) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'Tried to attach component at \'' + name + '\' on a closed conference.');
      } else {
        this._attachmentManager.attach(name, component);
      }
    }

    /**
     * Detach a component that was previously attached. If the component argument
     * is given and it does not match the currently attached component, a `TypeError`
     * will be thrown.
     *
     * @function Conference#detach
     * @param {string} name - Name of the attachment point.
     * @param {RtcComponent} [component] - An optional specific component to detach.
     */

  }, {
    key: 'detach',
    value: function detach(name, component) {
      if (name === switcherAttachPoint) {
        __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].error('Conference.detach', 'name', 'not use reserved name ' + name);
      }
      if (!this._attachmentManager) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'Tried to detach component at \'' + name + '\' from a closed conference.');
      } else {
        this._attachmentManager.detach(name, component);
      }
    }

    /**
     * The client's own user id in the conference, this is what other members
     * will see as `peerId`. This will be the same as the logged in user ID.
     *
     * @member {UserId} Conference#ownId
     */

  }, {
    key: 'start',


    /**
     * Start an incoming conference. This only needs to be called if listening
     * to the conference events on a client or room.
     *
     * @param {Object} options - Options object.
     * @param {ConferenceSwitcherMode} [options.switcherMode] - The default switcher mode for this conference.
     */
    value: function start() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._signalingState !== null) {
        return __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].warning(TAG, 'tried to start conference in wrong state: ' + this._signalingState);
      }
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'starting conference');
      this._connectionPool.start();
      this._switcher._setDefaultMode(options.switcherMode);
      this._startSearch();
    }

    /**
     * Leave the conference, remove all attachments, and cleanup all resources.
     *
     * Note that like {@link Call#close}, this does not signal the other
     * participants in the conference. To do a room-wide conference start/stop,
     * one should use application specific signaling, e.g. using room state.
    */

  }, {
    key: 'close',
    value: function close() {
      if (this._signalingState !== SIGNALING_STATE_CLOSED) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, 'closing ' + this);
        if (this._onClosed) {
          this._onClosed();
        }
        this._setSignalingState(SIGNALING_STATE_CLOSED);
        this._raft.stop();
        this._raft = null;
        this._connectionPool.stop();
        this._connectionPool = null;
        this._peers._cleanup();
        this._peers = null;
        this._attachmentManager.cleanup();
        this._attachmentManager = null;
        this._emit('closed', {
          reason: 'closed',
          source: 'self',
          conference: this
        });
        this._clearListeners();
      }
    }
  }, {
    key: '_onAttachmentUpdate',
    value: function _onAttachmentUpdate() {
      var _this2 = this;

      this._connectionPool.connections.forEach(function (connection, peerId) {
        var streams = _this2._attachmentManager.getLocalStreamsForPeer(peerId);
        connection._updateLocalStreams(streams);
      });
    }

    // Join message
    // {type: 'search', browser: <string>, [multiOffer: <offer>]}
    //
    // Connect message
    // {type: 'invite', [multiAnswer: <answer>]}
    //
    // multiOffer and multiAnswer reuses the same certificate for multiple peer connections, avoiding
    // an RTT and speeding up setup time
    //
    // Connection signaling
    // {type: 'connection'}

  }, {
    key: 'handleSignalingMessage',
    value: function handleSignalingMessage(peerId, message) {
      if (this._signalingState === null || this._signalingState === SIGNALING_STATE_CLOSED) {
        return __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].verbose(TAG, this, 'ignoring signaling message for stopped conference');
      }

      var type = message.type;

      if (!type) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].warning(TAG, this, 'got signaling message without type from ' + peerId);
        return;
      }

      if (type === 'search') {
        return this._handleSearchMessage(peerId, message);
      } else if (type === 'invite') {
        return this._handleInviteMessage(peerId, message);
      } else if (type === 'connection') {
        return this._connectionPool.handleConnectionMessage(peerId, message);
      }
    }
  }, {
    key: '_handleSearchMessage',
    value: function _handleSearchMessage(peerId, message) {
      if (this._signalingState === SIGNALING_STATE_SEARCHING) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'got search message from ' + peerId + ' while searching, creating new cluster');

        // An invite message is sent to the peer,
        this._invitePeer(peerId);
        this._setSignalingState(SIGNALING_STATE_MEMBER);
      } else if (this._signalingState === SIGNALING_STATE_JOINING) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'got search message from ' + peerId + ' while joining, ignoring');
        // If we are currently joining a cluster, we only add the searching peer to the member waitlist
        // If we then become leader while the member is still on the waitlist
        // FIXME: a connection needs to be set up to the peer if we become leader
        this._raft.addPeer(peerId, { waitlistTtlMs: MEMBER_ADD_TTL_MS });
        this._connectionPool.addGhostConnection(peerId, { ttlMs: MEMBER_ADD_TTL_MS });
      } else if (this._signalingState === SIGNALING_STATE_MEMBER) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'got search message from ' + peerId + ' as ' + (this._raft.isLeader ? 'leader' : 'member'));
        if (this._raft.isLeader) {
          // An invite message is sent to the peer,
          this._invitePeer(peerId);
        } else {
          // Keep track of the peer in case we become leader within the TTL
          this._raft.addPeer(peerId, { waitlistTtlMs: MEMBER_ADD_TTL_MS });
          this._connectionPool.addGhostConnection(peerId, { ttlMs: MEMBER_ADD_TTL_MS });
        }
      }
    }
  }, {
    key: '_getClusterInfo',
    value: function _getClusterInfo() {
      if (this._joiningCluster) {
        return this._joiningCluster;
      }
      return {
        id: this._raft.get('clusterId'),
        size: this._raft.members.size,
        term: this._raft.term
      };
    }
  }, {
    key: '_compareClusters',
    value: function _compareClusters(clusterA, clusterB) {
      if (clusterA.size !== clusterB.size) {
        return clusterB.size - clusterA.size;
      } else if (clusterA.id !== clusterB.id) {
        return clusterA.id.localeCompare(clusterB.id);
      } else {
        return clusterB.term - clusterA.term;
      }
    }
  }, {
    key: '_joinCluster',
    value: function _joinCluster(_ref) {
      var leaderId = _ref.leaderId,
          cluster = _ref.cluster;

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'joining cluster led by ' + leaderId + ': ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(cluster));
      this._setSignalingState(SIGNALING_STATE_JOINING);
      this._joiningCluster = cluster;
      this._raft.startPassive();
      this._connectionPool.connectToClusterLeader(leaderId);
      this._peers._setPeers([leaderId], this._connectionPool.connections);
    }
  }, {
    key: '_handleInviteMessage',
    value: function _handleInviteMessage(peerId, message) {
      if (message.recipient === this._ownId) {
        var cluster = message.cluster;

        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'received invite in state ' + this._signalingState + ' for ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(cluster));
        if (this._signalingState === SIGNALING_STATE_SEARCHING) {
          this._joinCluster({ leaderId: peerId, cluster: cluster });
        } else if (this._signalingState === SIGNALING_STATE_JOINING || this._signalingState === SIGNALING_STATE_MEMBER) {
          // we are already joining a cluster, so we need to figure out if we should abort that process
          // and accept the new invite instead. For now we just error out
          var ownCluster = this._getClusterInfo();
          var compareResult = this._compareClusters(ownCluster, cluster);
          if (compareResult > 0) {
            __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'left existing cluster to join cluster of ' + peerId + ', ' + ('old: ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(ownCluster) + ', new: ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(cluster) + ', result: ' + compareResult));
            this._joinCluster({ leaderId: peerId, cluster: cluster });
          }
        }
      } else {
        if (this._signalingState === SIGNALING_STATE_JOINING || this._signalingState === SIGNALING_STATE_MEMBER) {
          var _cluster = message.cluster;

          var _ownCluster = this._getClusterInfo();
          var _compareResult = this._compareClusters(_ownCluster, _cluster);
          if (_compareResult > 0) {
            __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'saw invite from other cluster with higher priority' + (', abanding ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(_ownCluster) + ' for ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(_cluster)));
            this._joinCluster({ leaderId: peerId, cluster: _cluster });
          }
        }
      }
    }
  }, {
    key: '_onRaftStateChange',
    value: function _onRaftStateChange() {
      this._switcher._handleStateChange();
    }
  }, {
    key: '_onRaftMembersChange',
    value: function _onRaftMembersChange(peerIds) {
      var _this3 = this;

      this._switcher._setMembers(peerIds);
      this._connectionPool.setExpectedConnections(peerIds);

      var connections = this._connectionPool.connections;

      this._peers._setPeers(peerIds, connections);

      var isMember = peerIds.has(this._ownId);
      connections.forEach(function (connection, peerId) {
        var isPaused = !isMember || !_this3._raft.members.has(peerId);
        connection.setPausedState(isPaused);
        _this3._attachmentManager.setPeerPausedState(peerId, isPaused);
      });

      if (this._signalingState === SIGNALING_STATE_MEMBER) {
        // If we lost membership it means we're considered disconnected by the cluster
        // and need to rejoin.
        if (!isMember) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'got new cluster members in connected state without self present');
          this._onDisconnected();
        }
      } else if (this._signalingState === SIGNALING_STATE_JOINING) {
        if (isMember) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'got new cluster members with itself as member, promoting to member');
          this._setSignalingState(SIGNALING_STATE_MEMBER);
        }
      }
    }
  }, {
    key: '_onRaftLeadershipChange',
    value: function _onRaftLeadershipChange(isLeader) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, (isLeader ? 'got' : 'lost') + ' cluster leadership');
      this._switcher._handleLeadershipChange(isLeader);
      if (isLeader) {
        this._connectionPool.materializeGhostConnections();
      }
    }
  }, {
    key: '_onPeersUpdate',
    value: function _onPeersUpdate() {
      if (this._connectionState === CONNECTION_STATE_CONNECTING) {
        if (this._peers._hasConnection()) {
          this._setConnectionState(CONNECTION_STATE_CONNECTED);
        }
      } else if (this._connectionState === CONNECTION_STATE_CONNECTED) {
        if (!this._peers._hasConnection()) {
          this._setConnectionState(CONNECTION_STATE_CONNECTING);
        }
      }
    }
  }, {
    key: '_setSignalingState',
    value: function _setSignalingState(newSignalingState) {
      if (this._signalingState === SIGNALING_STATE_CLOSED) {
        return;
      }
      this._signalingState = newSignalingState;

      if (newSignalingState !== SIGNALING_STATE_JOINING) {
        this._joiningCluster = null;
      }

      var newConnectionState = null;

      if (newSignalingState === SIGNALING_STATE_SEARCHING) {
        if (this._connectionState !== CONNECTION_STATE_SIGNALING) {
          newConnectionState = CONNECTION_STATE_SIGNALING;
        }
      } else if (newSignalingState === SIGNALING_STATE_JOINING) {
        if (this._connectionState !== CONNECTION_STATE_SIGNALING) {
          newConnectionState = CONNECTION_STATE_SIGNALING;
        }
      } else if (newSignalingState === SIGNALING_STATE_MEMBER) {
        if (this._connectionState === CONNECTION_STATE_SIGNALING) {
          if (this._peers._hasConnection()) {
            newConnectionState = CONNECTION_STATE_CONNECTED;
          } else {
            newConnectionState = CONNECTION_STATE_CONNECTING;
          }
        }
      } else if (newSignalingState === SIGNALING_STATE_CLOSED) {
        newConnectionState = CONNECTION_STATE_CLOSED;
      }

      if (newConnectionState) {
        this._setConnectionState(newConnectionState);
      }
    }
  }, {
    key: '_setConnectionState',
    value: function _setConnectionState(newConnectionState) {
      var oldConnectionState = this._connectionState;
      this._connectionState = newConnectionState;
      this._emit('connectionState', newConnectionState, oldConnectionState);
    }
  }, {
    key: '_onDisconnected',
    value: function _onDisconnected() {
      // We keep the connection pool going on disconnects, which means that we don't kill
      // existing connections that we are trying to set up. That means that triggering a
      // disconnect is quite cheack, there's only ome matrix signaling overhead.
      // Because of that we can keep disconnect timeouts low.

      this._raft.stop();
      this._peers._clear();

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'resetting conference due to disconnect');
      this._startSearch();
    }
  }, {
    key: '_startSearch',
    value: function _startSearch() {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'is starting search');
      // We start in active state with no other peers, which will immediately make us leader
      this._raft.start();
      var clusterId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["randomString"])(16);
      // While being leader, we set and commit the clusterId, which should then never be touched for
      // the history of this cluster's log.
      this._raft.set('clusterId', clusterId);

      this._switcher._initializeLeader();

      this._setSignalingState(SIGNALING_STATE_SEARCHING);
      this._onSignalingMessage({
        type: 'search',
        browser: __WEBPACK_IMPORTED_MODULE_10_common_utils__["browser"],
        cluster: this._getClusterInfo()
      });
    }
  }, {
    key: '_invitePeer',
    value: function _invitePeer(peerId) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'inviting ' + peerId + ' to cluster');
      this._raft.addPeer(peerId, { waitlistTtlMs: MEMBER_ADD_TTL_MS });
      this._onSignalingMessage({
        type: 'invite',
        browser: __WEBPACK_IMPORTED_MODULE_10_common_utils__["browser"],
        recipient: peerId,
        cluster: this._getClusterInfo()
      });
      this._connectionPool.ensureTemporaryConnection(peerId);
    }
  }, {
    key: '_createConnection',
    value: function _createConnection(_ref2) {
      var _this4 = this;

      var peerId = _ref2.peerId,
          peerLinkInfo = _ref2.peerLinkInfo;

      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].string('Conference._createConnection', 'peerId', peerId);

      var conferencePeer = this._peers.get(peerId) || null;

      var connection = new __WEBPACK_IMPORTED_MODULE_18_conference_conferenceConnection__["a" /* default */]({
        ownId: this._ownId,
        peerId: peerId,
        peerLinkInfo: peerLinkInfo,
        conferencePeer: conferencePeer,
        offer: null,
        iceServers: this._iceServers,
        iceCandidateFilter: this._iceCandidateFilter,
        statsFormatter: this._statsFormatterFactory && this._statsFormatterFactory(peerId),
        attachmentManager: this._attachmentManager,
        onSignalingMessage: function onSignalingMessage(message) {
          _this4._onSignalingMessage({
            type: 'connection',
            recipient: peerId,
            content: message
          });
        }
      });

      var isPaused = !this._raft.members.has(peerId);
      connection.setPausedState(isPaused);
      this._attachmentManager.setPeerPausedState(peerId, isPaused);

      if (conferencePeer) {
        connection._setConferencePeer(conferencePeer);
      }

      return connection;
    }
  }, {
    key: 'ownId',
    get: function get() {
      return this._ownId;
    }

    /**
     * A map representing the conference peers.
     *
     * @member {ConferencePeers} Conference#peers
     */

  }, {
    key: 'peers',
    get: function get() {
      return this._peers;
    }

    /**
     * The {@link ConferenceSwitcher} instance for this conference.
     *
     * Conferences always have a single switcher instance associated with them.
     * As long as the switcher mode is set to `'off'`, which is default, the switcher
     * will not consume any resources.
     *
     * @member {ConferenceSwitcher} Conference#switcher
     */

  }, {
    key: 'switcher',
    get: function get() {
      return this._switcher;
    }

    /**
     * Emitted when the connection state of the conference changes.
     *
     * @event Conference#connectionState
     * @param {PeerConnectionState} connectionState - The new connection state.
     * @param {PeerConnectionState} oldConnectionState - The old connection state.
     */

    /**
     * The connection state of the conference.
     *
     * @readonly
     * @member {PeerConnectionState} Conference#connectionState
     */

  }, {
    key: 'connectionState',
    get: function get() {
      return this._connectionState;
    }

    /**
     * True if the conference has been closed.
     *
     * A closed conference can not be started again, and will have had all attachments removed. It will
     * alse have been removed from {@link Room#conference}, so that a new conference can be started in the room.
     *
     * @member {boolean} Conference#closed
     */

  }, {
    key: 'closed',
    get: function get() {
      return this._signalingState === SIGNALING_STATE_CLOSED;
    }

    /**
     * True if the conference is stopped. This is the initial state for incoming conferences.
     *
     * Stopped conferences will keep all attachments and state, but will not have any connections to
     * other peers.
     *
     * @member {boolean} Conference#stopped
     */

  }, {
    key: 'stopped',
    get: function get() {
      return this._signalingState === null;
    }
  }]);

  return Conference;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_emitter__["a" /* default */])(null));

/* harmony default export */ __webpack_exports__["default"] = (Conference);

/***/ }),
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RoomQuery;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_utils__ = __webpack_require__(13);






/**
 * Emitted when the result of the query has changed.
 *
 * @event RoomQuery#update
 * @param {Array<*>} rows - The resulting rows, MUST NOT be modified.
 */

/**
 * Emitted when a row is added to the result of the query.
 *
 * @event RoomQuery#added
 * @param {*} row - The added row
 */

/**
 * Emitted when a row is removed from the result of the query.
 *
 * @event RoomQuery#removed
 * @param {*} row - The removed row
 */

/**
 * Represents a live query that selects a subset of all rooms and transforms
 * them using a map function.
 *
 * Whenever a room receives an event, the map function is run for every query.
 * If the map function returns a falsy value, it is ignored. If the value is
 * truthy, the value is added to the resulting rows.
 *
 * This is an example of a map function that lists all public rooms that the user is
 * a member of:
 *
 * ```js
 * function (room) {
 *     if (room.membership === 'member' && room.visibility === 'public') {
 *         return room;
 *     }
 * }
 * ```
 *
 * Whenever the value returned by the map function changes, an `'update'` event is
 * emitted, as well as `'added'` and/or `'removed'` events.
 * The value is considered changed if it switches between truthy and falsy, or
 * if the id property of the value changes.
 * If multiple return values are bundled in an object, it is important to
 * include an id property to avoid unnecessary change events.
 *
 * This is an example of a map function that lists all rooms to which the user has
 * been invited, as well as the inviting user:
 *
 * ```js
 * function (room) {
 *     if (room.membership === 'invited') {
 *         return {
 *             id: room.invitedBy.id,
 *             user: room.invitedBy,
 *             room: room,
 *         };
 *     }
 * }
 * ```
 *
 * @abstract
 * @class RoomQuery
 * @extends EventEmitter
 */

function RoomQuery(priv, mapFunction) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["assertPriv"])('RoomQuery', priv);
  var self = this;
  var rows = [];
  var items = [];
  var stateChangeFunctions = [];
  var stopped = false;
  var deferredEmit = 0;

  /**
   * The resulting rows of the RoomQuery, MUST NOT be modified.
   * @readonly
   * @member {Array<*>} RoomQuery#rows
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["getter"])(this, 'rows', function () {
    return items;
  });

  /**
   * Stops the query and frees all resources.
   *
   * @function
   * @name RoomQuery#stop
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["prop"])(this, 'stop', function () {
    stopped = true;
    rows = [];
    items = [];
    stateChangeFunctions = [];
    self._emit('update', items);
    self._clearListeners('update');
    self._clearListeners('added');
    self._clearListeners('removed');
  });

  /**
   * Forces the map function to be rerun for all rooms.
   *
   * @function
   * @name RoomQuery#forceUpdate
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["prop"])(this, 'forceUpdate', function () {
    if (stopped) {
      return;
    }
    stateChangeFunctions.forEach(function (fn) {
      fn();
    });
  });

  function handleNewRoom(room) {
    if (stopped) {
      return;
    }
    var item = mapFunction(room);
    var row = null;
    if (item) {
      row = {
        item: item
      };
      addRow(row);
    }
    var stateChangeFunction = onStateChangeFunction(room, row);
    stateChangeFunctions.push(stateChangeFunction);
    room._registerQuery(stateChangeFunction);
    return true;
  }

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["hiddenProp"])(this, '_handleNewRoom', handleNewRoom);

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["hiddenProp"])(this, '_clear', function () {
    if (stopped) {
      return;
    }
    rows = [];
    items = [];
    self._emit('update', items);
  });

  function deferEmit() {
    if (!deferredEmit) {
      deferredEmit = setTimeout(function () {
        if (stopped) {
          return;
        }
        self._emit('update', items);
        deferredEmit = 0;
      });
    }
  }

  function addRow(row) {
    rows.push(row);
    items.push(row.item);
    self._emit('added', row.item);
    deferEmit();
  }

  function removeRow(row) {
    var index = rows.indexOf(row);
    if (index === -1) {
      __WEBPACK_IMPORTED_MODULE_0_common_log__["default"].error('room-query', 'RoomQuery removeRow: room does not exist', row.item);
    } else {
      rows.splice(index, 1);
      items.splice(index, 1);
      self._emit('removed', row.item);
      deferEmit();
    }
  }

  function onStateChangeFunction(room, row) {
    return function onStateChange() {
      if (stopped) {
        return true;
      }

      var newItem = mapFunction(room);
      if (row) {
        if (newItem) {
          if (newItem === row.item) {
            return;
          } else if (newItem.id === row.item.id) {
            return;
          }
        }
        removeRow(row);
      } else if (!newItem) {
        return;
      }

      var newRow = null;
      if (newItem) {
        newRow = {
          item: newItem
        };
        addRow(newRow);
      }
      row = newRow;
    };
  }
}

__WEBPACK_IMPORTED_MODULE_1_common_emitter__["a" /* default */].call(RoomQuery.prototype);

/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = RoomState;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_utils__ = __webpack_require__(13);








/**
 * Emitted when the default value of the room state is changed.
 *
 * @event RoomState#value
 * @param {JsonTypes} value - The new value.
 * @param {JsonTypes} oldValue - The old value, if any.
 */

/**
 * Emitted when any value but the default value is changed.
 *
 * @event RoomState#update
 * @param {Object} change
 * @param {string} change.key - The key whose value was changed.
 * @param {JsonTypes} change.value - The new value that the key is now associated with.
 * @param {JsonTypes} change.oldValue - The value that the key was previously associated with, if any.
 */

/**
 * Emitted when the value associated with the given key is changed.
 *
 * @event RoomState#update:&lt;key&gt;
 * @param {JsonTypes} value - The new value that the key is now associated with.
 * @param {JsonTypes} oldValue - The value that the key was previously associated with, if any.
 */

// eslint-disable-next-line
/**
 * Represents a state in a room identified by a state type, and synchronized between all clients.
 *
 * Each room state is a key-value pair store that emits events when values are changed.
 *
 * The room state also has a default value which can be accessed by omitting the
 *  key parameter to any of the methods. The default value is handy for simple states
 *  such as setting a hex color for the room.
 *
 * @abstract
 * @class RoomState
 * @extends EventEmitter
 */
function RoomState(priv, type, room, setState) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["assertPriv"])('RoomState', priv);
  var self = this;
  var values = {};

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["hiddenProp"])(this, '_set', function (key, value) {
    key = '' + key;
    if (value && '__value__' in value) {
      value = value.__value__;
    }
    var oldValue = values[key];
    values[key] = value;
    if (key === '') {
      this._emit('value', value, oldValue);
    } else {
      this._emit('update:' + key, value, oldValue);
    }
    this._emit('update', {
      key: key,
      value: value,
      oldValue: oldValue
    });
  });

  /**
   * The type of the RoomState
   * @readonly
   * @member {string} RoomState#type
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["prop"])(this, 'type', type);

  /**
   * The room that the RoomState is derived from
   * @readonly
   * @member {Room} RoomState#room
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["prop"])(this, 'room', room);

  /**
   * Returns true if the key has been set
   *
   * @name RoomState#has
   * @function
   * @param {string} [key] - The key to test if it has been set.
   * @returns {boolean} - True if the key has been set, false otherwise
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["prop"])(this, 'has', function (key) {
    if (!__WEBPACK_IMPORTED_MODULE_2_common_argCheck__["a" /* default */].optString('RoomState.has', 'key', key)) {
      key = '';
    }
    return key in values;
  });

  /**
   * Gets the value for the corresponding key.
   *
   * If the key is omitted the default value of the RoomState will returned instead
   *
   * @name RoomState#get
   * @function
   * @param {string} [key] - The key whose associated value should be returned,
   *  or omitted if the default value is desired instead.
   * @returns {JsonTypes} - The value associated with the key
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["prop"])(this, 'get', function (key) {
    if (!__WEBPACK_IMPORTED_MODULE_2_common_argCheck__["a" /* default */].optString('RoomState.get', 'key', key)) {
      key = '';
    }
    return values[key];
  });

  /**
   * Sets the value that a key should be associated with. This will override any
   * existing association with the key.
   *
   * If the key is omitted the value of the RoomState will set instead.
   *
   * **NOTE:**
   * It is best to avoid relying on the returned promise to modify application state,
   * e.g. UI updates, as that will lead to race conditions and undefined behaviour.
   * It is better to use the returned promise for feedback that the state was changed
   * was successfully, and tie application state changes an 'update' event handler.
   * This is due to the fact that state changes are received via the event stream, but
   * the returned promise is resolved when the request is returned, and those two events
   * can happen in any order.
   *
   * ##### Errors:
   * - {@link TooLargeError} - The serialized value is too large, as in it occupies too many bytes.
   * - {@link NotAllowedError} - The user must be a member of the room and have enough power level.
   * - {@link GuestAccessError} - Guest access is not allowed.
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method</i>
   *
   * @name RoomState#set
   * @function
   * @param {string} [key] - The key that should be associated with the value.
   * @param {JsonTypes} value - The value that should be associated with the key.
   * @returns {Promise<RoomState, CctError>} - The room state
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["prop"])(this, 'set', function (key, value) {
    __WEBPACK_IMPORTED_MODULE_2_common_argCheck__["a" /* default */].count('RoomState.set', 1, arguments.length);
    if (arguments.length === 1) {
      value = key;
      key = '';
    } else {
      __WEBPACK_IMPORTED_MODULE_2_common_argCheck__["a" /* default */].string('RoomState.get', 'key', key);
    }
    if ((typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_typeof___default()(value)) !== 'object' || value === null || Array.isArray(value)) {
      value = {
        __value__: value
      };
    }
    return setState(key, value).then(function () {
      return self;
    });
  });

  /**
   * A list of all keys who are associated to a value
   *
   * @readonly
   * @member {string[]} RoomState#keys
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["getter"])(this, 'keys', function () {
    return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_keys___default()(values).filter(function (x) {
      return x;
    });
  });
}

RoomState.prototype.toString = function () {
  return 'RoomState{type=' + this.type + ', value=' + this.get() + ', keys=' + this.keys + '}';
};

__WEBPACK_IMPORTED_MODULE_3_common_emitter__["a" /* default */].call(RoomState.prototype);

/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getChromeMediaSourceId */
/* unused harmony export getChromeScreenConstraints */
/* unused harmony export getChromeMediaSourceIdEx */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_errors__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_media_common__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_media_concreteMediaSource__ = __webpack_require__(164);















var TAG = 'chrome-screen-source';

function getChromeMediaSourceId(extensionId, sourceTypes) {
  return new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
    var installedStatusTimeout = setTimeout(function () {
      window.removeEventListener('message', onMessage);
      var error = new __WEBPACK_IMPORTED_MODULE_8_common_errors__["b" /* NotFoundError */]('Screen sharing extension not installed');
      error.reason = new Error('Extension did not respond to install status check');
      reject(error);
    }, 1000);
    var onMessage = function onMessage(event) {
      var data = event.data;
      if (data.extensionId === extensionId) {
        switch (data.message) {
          case 'extensionIsInstalled':
            clearTimeout(installedStatusTimeout);
            window.postMessage({
              extensionId: extensionId, sourceTypes: sourceTypes,
              message: 'requestChromeMediaSourceId'
            }, '*');
            break;
          case 'chromeMediaSourceId':
            window.removeEventListener('message', onMessage);
            var sourceId = data.content;
            if (sourceId) {
              resolve(sourceId);
            } else {
              // user denied the request
              reject(new __WEBPACK_IMPORTED_MODULE_8_common_errors__["c" /* NotAllowedError */]('The user denied the request to share the screen'));
            }
        }
      }
    };

    window.addEventListener('message', onMessage);
    window.postMessage({
      extensionId: extensionId,
      message: 'getInstalledStatus'
    }, '*');
  });
}

function getChromeScreenConstraints() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$audio = _ref.audio,
      audio = _ref$audio === undefined ? false : _ref$audio,
      video = _ref.video,
      sourceId = _ref.sourceId;

  if (!video) {
    video = {};
  }
  if (!(video.width || video.height)) {
    video.width = { max: window.screen.width };
    video.height = { max: window.screen.height };
  }
  video.chromeMediaSourceId = { exact: sourceId };
  video.chromeMediaSource = { exact: 'desktop' };

  return { audio: audio, video: video };
}

function _sendChromeMessage(extensionId, message) {
  return new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
    window.chrome.runtime.sendMessage(extensionId, message, function (response) {
      if (response) {
        resolve(response);
      } else {
        var error = new Error('No response received');
        error.name = 'NotFoundError';
        reject(error);
      }
    });
  });
}

function getChromeMediaSourceIdEx(extensionId, sourceTypes) {
  return new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
    var installedStatusTimeout = setTimeout(function () {
      var error = new __WEBPACK_IMPORTED_MODULE_8_common_errors__["b" /* NotFoundError */]('Screen sharing extension not installed');
      error.reason = new Error('Extension did not respond to install status check');
      reject(error);
    }, 1000);

    _sendChromeMessage(extensionId, {
      extensionId: extensionId,
      message: 'getInstalledStatus'
    }).then(function (response) {
      clearTimeout(installedStatusTimeout);
      return response;
    }).then(_sendChromeMessage(extensionId, {
      extensionId: extensionId,
      sourceTypes: sourceTypes,
      message: 'requestChromeMediaSourceId'
    }).then(function (response) {
      var sourceId = response.content;
      if (sourceId) {
        resolve(sourceId);
      } else {
        // user denied the request
        reject(new __WEBPACK_IMPORTED_MODULE_8_common_errors__["c" /* NotAllowedError */]('The user denied the request to share the screen'));
      }
    }).catch(function (error) {
      return reject(error);
    })).catch(function (error) {
      return reject(error);
    });
  });
}

/**
 * Internal media node for acquiring a Chrome screen sharing stream.
 *
 * @private
 * @class ChromeScreenSource
 * @extends ConcreteMediaSource
 * @param {Object} options - Options object.
 * @param {string} options.chromeExtensionId - The id of the chrome extension to use.
 * @param {ScreenSharingType|null} [options.type=null] - The screen sharing type to use. Specifying
 *   null will let the user choose either screen or window.
 * @param {boolean} [options.audio=false] - Whether desktop audio should be captured as well.
 * @param {Object} [options.video] - Constraints for the video, defaults to max resolution and no
 *   framerate limit.
 */

var ChromeScreenSource = function (_ConcreteMediaSource) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(ChromeScreenSource, _ConcreteMediaSource);

  function ChromeScreenSource(options) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ChromeScreenSource);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ChromeScreenSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ChromeScreenSource)).call(this));

    __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].options('ChromeScreenSource constructor', 'options', options).string('chromeExtensionId').optString('type').optBoolean('audio').optObject('video');

    var sourceTypes = options.type ? [options.type] : ['screen', 'window'];

    getChromeMediaSourceIdEx(options.chromeExtensionId, sourceTypes).then(function (sourceId) {
      return getChromeScreenConstraints({
        sourceId: sourceId,
        type: options.type,
        audio: options.audio,
        video: options.video
      });
    }).then(function (constraints) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_media_common__["f" /* getUserMedia */])(constraints);
    }).then(function (stream) {
      return _this.setStream(stream);
    }, function (error) {
      if (error.name && error.name === 'NotFoundError') {
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].warning('deprecated', 'This Extension implementation will be DEPRICATED in later release');
        var p2 = getChromeMediaSourceId(options.chromeExtensionId, sourceTypes);
        _this._handleExtensionId(p2, options).catch(function () {
          _this.setError(error);
        });
      } else {
        _this.setError(error);
      }
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'unexpected error in ChromeScreenSource: ' + error);
    });
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(ChromeScreenSource, [{
    key: '_handleExtensionId',
    value: function _handleExtensionId(promise, options) {
      var _this2 = this;

      return promise.then(function (sourceId) {
        return getChromeScreenConstraints({
          sourceId: sourceId,
          type: options.type,
          audio: options.audio,
          video: options.video
        });
      }).then(function (constraints) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_media_common__["f" /* getUserMedia */])(constraints);
      }).then(function (stream) {
        return _this2.setStream(stream);
      }, function (error) {
        return _this2.setError(error);
      }).catch(function (error) {
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'unexpected error in ChromeScreenSource: ' + error);
      });
    }
  }]);

  return ChromeScreenSource;
}(__WEBPACK_IMPORTED_MODULE_10_media_concreteMediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (ChromeScreenSource);

/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_errors__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_common__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_concreteMediaSource__ = __webpack_require__(164);













var TAG = 'firefox-screen-source';
var ERROR_TIME_BREAKPOINT_MS = 100;

/**
 * Internal media node for acquiring a Firefox screen sharing stream.
 *
 * @private
 * @class FirefoxScreenSource
 * @extends ConcreteMediaSource
 * @param {Object} [options] - Optional options object.
 * @param {ScreenSharingType} [options.type='window'] - The screen sharing type to use.
 *   The difference between window and application is that application will show all application windows
 *   at once, while window only shows a single window. e.g. only a single Firefox window or all open Firefox
 *   windows.
 * @param {boolean} [options.audio=false] - Whether audio should be requested as well.
 * @param {Object} [options.video] - Constraints for the video, defaults to max resolution and no
 *   framerate limit.
 */

var FirefoxScreenSource = function (_ConcreteMediaSource) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(FirefoxScreenSource, _ConcreteMediaSource);

  function FirefoxScreenSource(options) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, FirefoxScreenSource);

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (FirefoxScreenSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(FirefoxScreenSource)).call(this));

    var audio = options.audio || false;
    var video = options.video || {};
    var type = options.type || 'window';

    __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optBoolean('FirefoxScreenSource constructor', 'options.audio', audio);
    __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optObject('FirefoxScreenSource constructor', 'options.video', video);
    __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optString('FirefoxScreenSource constructor', 'options.type', type);

    if (!video.mediaSource) {
      video.mediaSource = type;
    }
    var startTime = Date.now();
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_media_common__["f" /* getUserMedia */])({ audio: audio, video: video }).then(function (stream) {
      return _this.setStream(stream);
    }, function (error) {
      if (error.name === 'NotAllowedError') {
        var actualError;
        // If the diff is too short we can assume it's not the user...
        var timeToError = Date.now() - startTime;
        if (timeToError < ERROR_TIME_BREAKPOINT_MS) {
          if (location.protocol !== 'https:') {
            actualError = new __WEBPACK_IMPORTED_MODULE_6_common_errors__["c" /* NotAllowedError */]('Screen sharing is only allowed over HTTPS');
          } else {
            var msg = 'Screen sharing is not allowed on this domain, it needs to be added to ' + 'the media.getusermedia.screensharing.allowed_domains preference in about:config, ' + 'either manually or using an extension.';
            actualError = new __WEBPACK_IMPORTED_MODULE_6_common_errors__["b" /* NotFoundError */](msg);
          }
        } else {
          actualError = new __WEBPACK_IMPORTED_MODULE_6_common_errors__["c" /* NotAllowedError */]('The user denied the request to share the screen');
        }
        actualError.reason = error.reason;
        error = actualError;
      }
      _this.setError(error);
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].error(TAG, 'unexpected error in FirefoxScreenSource: ' + error);
    });
    return _this;
  }

  return FirefoxScreenSource;
}(__WEBPACK_IMPORTED_MODULE_8_media_concreteMediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (FirefoxScreenSource);

/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_streamSink__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_media_muteFilter__ = __webpack_require__(180);














var TAG = 'media-tee';

/**
 * A simple {@link MediaNode} that can be used to expose media together with the basic utilities
 * of emitting stream events, exposing a stream stream property, and a mute property.
 *
 * @class MediaTee
 * @extends ConnectMixin
 */

var MediaTee = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(MediaTee, _EmitterMixin);

  function MediaTee() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, MediaTee);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (MediaTee.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(MediaTee)).call(this));

    _this._streamSink = new __WEBPACK_IMPORTED_MODULE_7_media_streamSink__["a" /* default */]({ onStream: function onStream(stream) {
        return _this._emit('stream', stream);
      } });
    _this._muteFilter = new __WEBPACK_IMPORTED_MODULE_9_media_muteFilter__["a" /* default */]();
    _this._muteFilter.connect(_this._streamSink);
    return _this;
  }

  /**
   * Emitted whenever the stream is changed.
   *
   * @event MediaTee#stream
   * @param {?MediaStream} stream - The media stream, or null.
   */

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(MediaTee, [{
    key: 'sink',
    set: function set(target) {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(TAG, 'mediaTee.sink is removed, just connect directly to the sink instead');
    }

    /**
     * The tee's current media stream, or null.
     *
     * @readonly
     * @member {MediaStream} MediaTee#stream
     */

  }, {
    key: 'stream',
    get: function get() {
      return this._streamSink.stream;
    }

    /**
     * The input of the media tee.
     *
     * @readonly
     * @member {MediaNodeInput} MediaTee#input
     */

  }, {
    key: 'input',
    get: function get() {
      return this._muteFilter;
    }

    /**
     * The output of the media tee.
     *
     * @readonly
     * @member {MediaNodeOutput} MediaTee#output
     */

  }, {
    key: 'output',
    get: function get() {
      return this._muteFilter;
    }

    /**
     * Mute property as documented in {@link MuteFilter#mute}.
     *
     * @member {Object} MediaTee#mute
     */

  }, {
    key: 'mute',
    get: function get() {
      return this._muteFilter.mute;
    },
    set: function set(value) {
      this._muteFilter.mute = value;
    }
  }]);

  return MediaTee;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_8_media_mediaNode__["a" /* default */].connectMixin()));

/* harmony default export */ __webpack_exports__["a"] = (MediaTee);

/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_common__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_concreteMediaSource__ = __webpack_require__(164);












var TAG = 'user-media-source';

/**
 * Low level media node that wraps a `getUserMedia` call. Applications will typically want to use
 * {@link DeviceSource} or {@link ScreenSource} instead.
 *
 * @class UserMediaSource
 * @extends ConcreteMediaSource
 * @param {Object} [options] - Optional options object.
 * @param {Object} [options.constraints] - Constraints passed to `getUserMedia`.
 * @param {boolean|Object} [options.constraints.audio=true] - Set to `true` if audio is desired, or a
 *  {@link http://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints MediaTrackConstraints}
 *  object if more detailed constraints is required.
 * @param {boolean|Object} [options.constraints.video=true] - Set to `true` if video is desired, or a
 *  {@link http://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints MediaTrackConstraints}
 *  object if more detailed configuration is required.
 */

var UserMediaSource = function (_ConcreteMediaSource) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(UserMediaSource, _ConcreteMediaSource);

  function UserMediaSource() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, UserMediaSource);

    __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optOptions('UserMediaSource constructor', 'options', options).optObject('constraints');
    var _options$constraints = options.constraints,
        constraints = _options$constraints === undefined ? { audio: true, video: true } : _options$constraints;

    var _this = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (UserMediaSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(UserMediaSource)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_media_common__["f" /* getUserMedia */])(constraints).then(function (stream) {
      return _this.setStream(stream);
    }, function (error) {
      return _this.setError(error);
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].error(TAG, 'unexpected error in UserMediaSource: ' + error);
    });
    return _this;
  }

  /**
   * @private
   * @function UserMediaSource#setStream
   */

  /**
   * @private
   * @function UserMediaSource#setError
   */


  return UserMediaSource;
}(__WEBPACK_IMPORTED_MODULE_7_media_concreteMediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (UserMediaSource);

/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_media_mediaFilter__ = __webpack_require__(179);















var TAG = 'web-audio-filter';

/**
 * A base class for media filter nodes that wish to use the WebAudio APIs.
 *
 * @class WebAudioFilter
 * @extends MediaFilter
 * @param {Object} [options] - Optional options object
 * @param {AudioContext} [options.context] - Audio context to use within this media node,
 *   which must not be closed as while the filter is still being used.
 *   If omitted, an internal context will be used.
 */

var WebAudioFilter = function (_MediaFilter) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(WebAudioFilter, _MediaFilter);

  function WebAudioFilter() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, WebAudioFilter);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (WebAudioFilter.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(WebAudioFilter)).call(this));

    __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].optOptions('WebAudioFilter constructor', 'options', options).optInstance('context', __WEBPACK_IMPORTED_MODULE_8_webrtc_utils__["AudioContext"]);

    if (options.context) {
      _this._releaseContext = false;
      _this._audioContext = options.context;
    } else {
      _this._releaseContext = true;
      _this._audioContext = null;
    }

    _this._source = null;
    _this._destination = null;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(WebAudioFilter, [{
    key: 'onStream',
    value: function onStream(stream, oldStream) {
      if (this._source) {
        this._source.disconnect();
        this._source = null;
      }
      if (stream) {
        if (this._releaseContext) {
          this._audioContext = __WEBPACK_IMPORTED_MODULE_8_webrtc_utils__["audioContextUtil"].get();
        }
        this._source = this._audioContext.createMediaStreamSource(stream);
        this._destination = this._audioContext.createMediaStreamDestination();
        this.setStream(this._destination.stream);
      } else {
        if (this._audioContext && this._releaseContext) {
          __WEBPACK_IMPORTED_MODULE_8_webrtc_utils__["audioContextUtil"].release();
          this._audioContext = null;
        }
        this._destination = null;
        this.setStream(null);
      }

      try {
        this.onAudioSource(this._source, this._destination, this._audioContext);
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'Error thrown in WebAudioFilter.onAudioSource: ' + error);
      }
    }
  }, {
    key: 'onAudioSource',
    value: function onAudioSource(source, destination, context) {
      if (source) {
        if (this.onSetupFilter) {
          try {
            var result = this.onSetupFilter(context);
            if (result instanceof AudioNode) {
              source.connect(result);
              result.connect(destination);
            } else if (Array.isArray(result)) {
              var _result = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(result, 2),
                  input = _result[0],
                  output = _result[1];

              if (!(input instanceof AudioNode)) {
                throw new TypeError('returned input node must be an AudioNode');
              }
              if (!(output instanceof AudioNode)) {
                throw new TypeError('returned output node must be an AudioNode');
              }
              source.connect(input);
              output.connect(destination);
            } else {
              throw new TypeError('return value must be an AudioNode or array of [input, output] nodes');
            }
          } catch (error) {
            __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'Error thrown in WebAudioFilter.onSetupFilter: ' + error);
          }
        } else {
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].warning(TAG, 'WebAudioFilter should override onAudioSource(source, destination, context) ' + 'or implement onSetupFilter(context)');
        }
      } else {
        if (this.onTeardownFilter) {
          try {
            this.onTeardownFilter(context);
          } catch (error) {
            __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'Error thrown in WebAudioFilter.onTeardownFilter: ' + error);
          }
        }
      }
    }
  }, {
    key: 'context',
    get: function get() {
      return this._audioContext;
    }
  }, {
    key: 'audioSource',
    get: function get() {
      return this._source;
    }
  }, {
    key: 'audioDestination',
    get: function get() {
      return this._destination;
    }
  }]);

  return WebAudioFilter;
}(__WEBPACK_IMPORTED_MODULE_9_media_mediaFilter__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (WebAudioFilter);

/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_mediaSource__ = __webpack_require__(144);














/**
 * A base class for media source nodes that wish to use the WebAudio APIs.
 *
 * @class WebAudioSource
 * @extends MediaSource
 * @param {Object} [options] - Optional options object
 * @param {AudioContext} [options.context] - Audio context to use within this media node,
 *   which must not be closed as while the filter is still being used.
 *   If omitted, an internal context will be used.
 */

var WebAudioSource = function (_MediaSource) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(WebAudioSource, _MediaSource);

  function WebAudioSource() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, WebAudioSource);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (WebAudioSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(WebAudioSource)).call(this));

    __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].optOptions('WebAudioSource constructor', 'options', options).optInstance('context', __WEBPACK_IMPORTED_MODULE_7_webrtc_utils__["AudioContext"]);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_utils__["registerInstance"])('webAudioSource', _this);

    if (options.context) {
      _this._releaseContext = false;
      _this._audioContext = options.context;
    } else {
      _this._releaseContext = true;
      _this._audioContext = __WEBPACK_IMPORTED_MODULE_7_webrtc_utils__["audioContextUtil"].get();
    }

    _this._destination = _this._audioContext.createMediaStreamDestination();
    _this.setStream(_this._destination.stream);
    return _this;
  }

  /**
   * The audio context that is used within this media node.
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(WebAudioSource, [{
    key: 'stop',


    /**
     * Stops the source and cleans up all resources. This has to be called once the source
     * is no longer used in order to clean up resources.
     *
     * Calling this method multiple times has no effect.
     */
    value: function stop() {
      if (this._stopped) {
        return;
      }
      this._stopped = true;
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_utils__["unregisterInstance"])('webAudioSource', this);
      this.setStream(null);
      this._destination = null;
      if (this._releaseContext) {
        __WEBPACK_IMPORTED_MODULE_7_webrtc_utils__["audioContextUtil"].release();
        this._audioContext = null;
      }
    }

    /**
     * @private
     * @function WebAudioSource#setStream
     */

  }, {
    key: 'context',
    get: function get() {
      return this._audioContext;
    }

    /**
     * The web audio media stream destination node, whose stream is set as the output stream
     * of this source. Audio nodes should be connected to this node in order to generate an output.
     *
     * This property should only be accessed by subclasses of the web audio source.
     */

  }, {
    key: 'audioDestination',
    get: function get() {
      return this._destination;
    }
  }]);

  return WebAudioSource;
}(__WEBPACK_IMPORTED_MODULE_8_media_mediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (WebAudioSource);

/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_webrtc_errors__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_webrtc_peerConnectionProxy__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_webrtc_dataHub__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_webrtc_dataChannelMonitor__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_webrtc_attachmentManager__ = __webpack_require__(192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_webrtc_components__ = __webpack_require__(225);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_webrtc_signaler__ = __webpack_require__(233);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_datamux_datamux__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_media_mediaNodeInput__ = __webpack_require__(131);




























var TAG = 'call';

var PEER_SWITCH_TIMEOUT_MS = 5000;

/**
 * A WebRTC call to a single peer.
 *
 * The call only manages the connection to a single peer. Functionality is added by attaching
 * different {@link RtcComponent}s using {@link Call#attach}.
 *
 * @abstract
 * @class Call
 * @extends EventEmitter
 */

var Call = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(Call, _EmitterMixin);

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(Call, null, [{
    key: 'create',

    /**
     * Emitted when the call is closed. Closing the call is permanent, and removes it from the
     * active calls in a room.
     * @event Call#closed
     * @param {object} info - Information about who closed the call and how.
     * @param {string} info.reason -
     * An identifier for the reason that the call closed
     * * `closed` - The call was closed locally.
     * * `hangup` - Someone hangs up the call, can be caused by both parties.
     * @param {string} info.source - Who caused the call to close
     * * `self` - The call was closed locally.
     * * `peer` - The call was closed by the peer.
     * @param {Call} info.call - The call that was closed
     */

    /**
     * Emitted when the connection state of the call changes.
     *
     * @event Call#connectionState
     * @param {PeerConnectionState} connectionState - The new connection state.
     */

    /**
     * Emitted when the call error state is changed.
     *
     * @event Call#error
     * @param {(ConnectionFailedError|ConnectionLostError)?} error - The new error state.
     */

    /**
     * Emitted when there is a signaling error.
     *
     * @event Call#signalingError
     * @param {ConnectionSignalingError} signalingError - A signaling error.
     */

    value: function create(config) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].options('Call.create', 'config', config).func('onSignalingMessage').optString('userId').optString('peerId').optArray('iceServers').optFunc('iceCandidateFilter').optObject('receivedOffer');

      var onSignalingMessage = config.onSignalingMessage,
          _config$userId = config.userId,
          userId = _config$userId === undefined ? 'self' : _config$userId,
          _config$peerId = config.peerId,
          peerId = _config$peerId === undefined ? 'peer' : _config$peerId,
          _config$iceServers = config.iceServers,
          iceServers = _config$iceServers === undefined ? null : _config$iceServers,
          _config$iceCandidateF = config.iceCandidateFilter,
          iceCandidateFilter = _config$iceCandidateF === undefined ? null : _config$iceCandidateF,
          _config$receivedOffer = config.receivedOffer,
          receivedOffer = _config$receivedOffer === undefined ? null : _config$receivedOffer;


      if (userId === peerId) {
        __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].error('Call.create', 'config', 'not have identical userId and peerId');
      }

      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["priv"])(Call, { onSignalingMessage: onSignalingMessage, userId: userId, peerId: peerId, iceServers: iceServers, iceCandidateFilter: iceCandidateFilter, receivedOffer: receivedOffer });
    }
  }]);

  function Call(priv, deps) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, Call);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Call.__proto__ || __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default()(Call)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["assertPriv"])('Call', priv);
    _this._ownId = deps.userId || null;
    _this._peerId = deps.peerId || null;
    _this._isPassive = !deps.peerId;
    _this._onClosed = deps.onClosed;
    _this._statsFormatter = deps.statsFormatter;

    _this._disconnectTimeoutId = 0;

    _this._attachmentManager = new __WEBPACK_IMPORTED_MODULE_16_webrtc_attachmentManager__["b" /* default */]({
      ownId: deps.userId,
      type: 'call',
      dataHub: new __WEBPACK_IMPORTED_MODULE_14_webrtc_dataHub__["b" /* default */](),
      onUpdate: _this._onAttachmentUpdate.bind(_this)
    });

    _this._datamux = new __WEBPACK_IMPORTED_MODULE_19_datamux_datamux__["a" /* default */]({
      onChannel: function onChannel(channel) {
        return _this._attachmentManager.handlePeerChannel(_this._peerId, channel);
      },
      onConnect: function onConnect() {
        return _this._signaler.handleDataChannelConnect();
      },
      onDisconnect: function onDisconnect(reason) {
        return _this._signaler.handleDataChannelDisconnect(reason);
      }
    });

    // All builtin channels should be created here
    var renegotiationChannel = _this._datamux.createChannel({
      builtin: true,
      label: 'cct.call',
      protocol: 'cct.call.v0'
    });
    _this._attachmentChannels = {
      negotiationChannel: _this._datamux.createChannel({
        builtin: true,
        label: 'cct.call.attach-map',
        protocol: 'cct.call.attach-map.v0'
      }),
      dataHubChannel: _this._datamux.createChannel({
        builtin: true,
        label: 'cct.attach.data',
        protocol: 'cct.attach.data.v0'
      }),
      messagingChannel: _this._datamux.createChannel({
        builtin: true,
        label: 'cct.attach.messaging',
        protocol: 'cct.attach.messaging.v0'
      })
    };

    _this._peerConnectionConfiguration = {
      iceServers: deps.iceServers,
      iceCandidateFilter: deps.iceCandidateFilter,
      statsFormatter: deps.statsFormatter
    };

    _this._onAddRemoteStream = _this._onRemoteStreamChange.bind(_this, 'got');
    _this._onRemoveRemoteStream = _this._onRemoteStreamChange.bind(_this, 'lost');

    _this._signaler = new __WEBPACK_IMPORTED_MODULE_18_webrtc_signaler__["a" /* default */]({
      label: _this._ownId + '=>' + _this._peerId,
      receivedOffer: deps.offer,
      renegotiationChannel: renegotiationChannel,
      onMessage: deps.onSignalingMessage,
      onSignalingError: _this._onSignalingError.bind(_this),
      onErrorStateChange: _this._onErrorStateChange.bind(_this),
      onConnectionStateChange: _this._onConnectionStateChange.bind(_this),
      onCreatePeerConnection: _this._createPeerConnection.bind(_this)
    });
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(Call, [{
    key: 'toString',
    value: function toString() {
      return 'call{id=' + this.id + ',' + this._peerConnection + '}';
    }
  }, {
    key: '_onErrorStateChange',
    value: function _onErrorStateChange(error) {
      this._emit('errorState', error);
      this._emit('error', error);
      if (error && this._statsFormatter) {
        this._statsFormatter.handleStats([{
          timestamp: Date.now(),
          pcId: this._peerConnection && this._peerConnection.id,
          sourceId: 'errorState',
          name: error.name,
          message: error.message
        }]);
      }
    }
  }, {
    key: '_onConnectionStateChange',
    value: function _onConnectionStateChange(state, prevState) {
      if (state === 'connected') {
        this._emit('connected', this);
      }
      if (prevState === 'connected') {
        this._emit('disconnected', this);
      }
      this._emit('connectionState', state, prevState);
    }
  }, {
    key: '_onSignalingError',
    value: function _onSignalingError(error) {
      var signalingError = new __WEBPACK_IMPORTED_MODULE_11_webrtc_errors__["e" /* ConnectionSignalingError */](error);
      this._emit({
        eventType: 'signalingError',
        defaultHandler: function defaultHandler() {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'unhandled call signaling error', signalingError);
        }
      }, signalingError);
      if (this._statsFormatter) {
        this._statsFormatter.handleStats([{
          timestamp: Date.now(),
          pcId: this._peerConnection && this._peerConnection.id,
          sourceId: 'signalingError',
          name: error.name,
          message: error.message
        }]);
      }
    }

    /**
     * Attaches an {@link RtcComponent} to the call. If the peer attaches a compatible component
     * to the same attachment point, the two components will be paired together.
     *
     * A common use case is for two peers to each attach a {@link DataShare} to 'data'.
     * Once the call has connected, both peers will be able to use the attached DataShare to share data.
     *
     * The attachment point name can be any string, although excessively long names should be avoided.
     *
     * This method can be called at any point during a call, but will have no effect if the call is closed.
     *
     * @param  {string} name - The attachment point where the component should be attached.
     * @param  {RtcComponent} component - An RtcComponent instance to attach.
     */

  }, {
    key: 'attach',
    value: function attach(name, component) {
      if (!this._attachmentManager) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, 'Tried to attach component at \'' + name + '\' on a closed call.');
      } else {
        this._attachmentManager.attach(name, component);
      }
    }

    /**
     * Detaches the {@link RtcComponent} currently attached to the given attachment point.
     * If no component is currently attached, an error will be thrown. If the component argument is
     * given and it does not match the currently attached component, an error will be thrown.
     *
     * This method can be called at any point during a call, but will have no effect if the call is closed.
     *
     * @param {string} name - The attachment point from where the component should be detached.
     * @param {RtcComponent} [component] - An RtcComponent instance that is expected to be attached
     *   at the point.
     */

  }, {
    key: 'detach',
    value: function detach(name, component) {
      if (!this._attachmentManager) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, 'Tried to detach component at \'' + name + '\' from a closed call.');
      } else {
        this._attachmentManager.detach(name, component);
      }
    }

    /**
     * A object containing all the attachments of the call.
     *
     * @readonly
     * @member {Object<RtcComponent>} Call#attachments
     */

  }, {
    key: '_getMediaPipe',
    value: function _getMediaPipe(name) {
      if (!this._attachmentManager) {
        return new __WEBPACK_IMPORTED_MODULE_17_webrtc_components__["d" /* PeerMediaPipe */]();
      }
      var pipe = this._attachmentManager.getAttachments()[name];
      if (pipe && !(pipe instanceof __WEBPACK_IMPORTED_MODULE_17_webrtc_components__["d" /* PeerMediaPipe */])) {
        throw new Error('Attachment conflict for ' + name + ', another component is attached.');
      } else if (!pipe) {
        pipe = new __WEBPACK_IMPORTED_MODULE_17_webrtc_components__["d" /* PeerMediaPipe */]();
        this._attachmentManager.attach(name, pipe);
      }
      return pipe;
    }

    /**
     * Returns a {@link MediaTee} that represents a remote source with a specific name.
     *
     * This method is guaranteed to always return a {@link MediaTee}, unless the call is closed.
     * If there is no remote source with the given name, it will be created.
     *
     * Under the hood this method will ensure that a {@link PeerMediaPipe} component is attached to the given point.
     *
     * @example <caption>Rendering a remote stream to a &lt;video&gt; element</caption>
     *
     * call.getRemoteSource('main').connect(videoElement)
     *
     * @function Call#getRemoteSource
     * @param {string} name - The name of the remote source to return.
     * @returns {MediaTee} A media tee that forwards the remote stream.
     */

  }, {
    key: 'getRemoteSource',
    value: function getRemoteSource(name) {
      return this._getMediaPipe(name).output;
    }

    /**
     * Sets or removes a local media source that will be streamed to the peer.
     *
     * Under the hood this method will ensure that a {@link MediaPipe} component is attached to the given point.
     *
     * @function Call#setLocalSource
     * @param {string} name - The name of the stream, e.g. 'main'.
     * @param {?MediaNode} source - The media source.
     */

  }, {
    key: 'setLocalSource',
    value: function setLocalSource(name, source) {
      if (arguments.length < 2) {
        throw new TypeError('Call.setLocalSource: requires at least 2 arguments');
      }
      if (typeof name !== 'string') {
        throw new TypeError('Call.setLocalSource: name has to be a string');
      }
      if (source) {
        __WEBPACK_IMPORTED_MODULE_20_media_mediaNode__["a" /* default */].connect(source, this._getMediaPipe(name));
      } else {
        var input = __WEBPACK_IMPORTED_MODULE_21_media_mediaNodeInput__["a" /* default */].resolve(this._getMediaPipe(name));
        if (input.target) {
          input.target.disconnect(input);
        }
      }
    }
  }, {
    key: '_onAttachmentUpdate',
    value: function _onAttachmentUpdate() {
      var _this2 = this;

      if (!this._peerConnection) {
        return;
      }
      if (!this.peerId) {
        return __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'got attachment update while no peer id was set');
      }
      var streams = this._attachmentManager.getLocalStreamsForPeer(this.peerId);
      var currentStreams = this._peerConnection.getLocalStreams();

      var _streamDiff = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_webrtc_utils__["streamDiff"])(currentStreams, streams),
          _streamDiff2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_streamDiff, 2),
          added = _streamDiff2[0],
          removed = _streamDiff2[1];

      added.forEach(function (stream) {
        return _this2._peerConnection.addStream(stream);
      });
      removed.forEach(function (stream) {
        return _this2._peerConnection.removeStream(stream);
      });
    }
  }, {
    key: '_onRemoteStreamChange',
    value: function _onRemoteStreamChange(op, event) {
      var stream = event.stream;

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, op + ' remote stream \'' + stream.id + ':\'', stream);
      var streams = this._peerConnection.getRemoteStreams();
      this._attachmentManager.setRemoteStreamsForPeer(this.peerId, streams);
    }
  }, {
    key: '_setPeerId',
    value: function _setPeerId(peerId) {
      if (this._peerId !== peerId) {
        this._oldPeers = this._oldPeers || new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
        var now = Date.now();
        var switchTimeout = this._oldPeers.get(peerId);
        if (now < switchTimeout) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'ignoring peer change from ' + this._peerId + ' to ' + peerId + ', timeout has not expired');
          return false;
        }
        this._oldPeers.set(peerId, now + PEER_SWITCH_TIMEOUT_MS);

        if (this._peerId) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'changed peer, sending hangup to old peer');
          this._signaler.sendHangup();
        }

        this._reset();
        this._peerId = peerId;
        this._emit('peerId', peerId);
        if (this._statsFormatter) {
          this._statsFormatter.setPeerId(peerId);
        }
      }
      return true;
    }
  }, {
    key: 'handleSignalingMessage',
    value: function handleSignalingMessage(message) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].object('Call.handleSignalingMessage', 'message', message);
      try {
        this._signaler.handleMessage(message);
      } catch (error) {
        if (error.message === 'hangup') {
          if (this._signaler.transitionToClosed()) {
            this._closeCall('hangup', 'peer');
          }
        } else {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, this + ' error when handling signaling message: ' + error);
        }
      }
    }
  }, {
    key: '_createPeerConnection',
    value: function _createPeerConnection() {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].verbose(TAG, this + ' replacing peer connection');
      this._reset();

      this._peerConnection = __WEBPACK_IMPORTED_MODULE_13_webrtc_peerConnectionProxy__["a" /* default */].create(this._peerConnectionConfiguration);
      if (this._statsFormatter) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15_webrtc_dataChannelMonitor__["a" /* default */])(this._peerConnection, this._statsFormatter);
      }
      var dataChannelFactory = this._peerConnection.createDataChannel.bind(this._peerConnection);
      this._datamux.createDataChannels(dataChannelFactory);
      this._attachmentManager.setDatamuxForPeer(this._peerId, this._datamux, this._attachmentChannels);
      this._onAttachmentUpdate();
      this._peerConnection.addEventListener('addstream', this._onAddRemoteStream);
      this._peerConnection.addEventListener('removestream', this._onRemoveRemoteStream);

      this._emit('peerConnection', this._peerConnection);

      return this._peerConnection;
    }

    // Members

    /**
     * The id of the call.
     *
     * This is not guaranteed to be constant, as it can be changed due to negotiation
     * conflicts. If the id is changed, an `'id` event will be emitted.
     *
     * @readonly
     * @member {string} Call#id
     */

  }, {
    key: 'hangup',


    // Methods
    /**
     * Signal to the peer that the call is has been hung up, and then stop the call.
     *
     * When a call is hung up all components will be detached, and all resources cleaned up. It will
     * not be possible to start the call again.
     *
     * @function Call#hangup
     * @returns {Promise<Room>} A promise that is resolved if the hangup event is sent successfully.
     */
    value: function hangup() {
      if (this._signaler.transitionToClosed()) {
        this._signaler.sendHangup();
        this._closeCall('hangup', 'self');
      }
    }
    /**
     * Abruptly close the call without signaling to the peer.
     *
     * When a call is hung up all components will be detached, and all resources cleaned up. It will
     * not be possible to start the call again.
     *
     * @function Call#close
     */

  }, {
    key: 'close',
    value: function close() {
      if (this._signaler.transitionToClosed()) {
        this._closeCall('closed', 'self');
      }
    }
    /**
     * Starts an incoming call, or tries to reconnect the call if the connection has failed.
     *
     * @function Call#start
     */

  }, {
    key: 'start',
    value: function start() {
      this._signaler.start();
      return this;
    }
  }, {
    key: '_closeCall',
    value: function _closeCall(reason, source) {
      this._reset();
      this._datamux.cleanup();
      this._attachmentManager.cleanup();
      this._attachmentManager = null;
      if (this._onClosed) {
        this._onClosed(this);
      }
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'closed call: ' + this);
      this._emit('closed', {
        reason: reason,
        source: source,
        call: this
      });
    }
  }, {
    key: '_reset',
    value: function _reset() {
      if (this._peerConnection) {
        this._peerConnection.removeEventListener('addstream', this._onAddRemoteStream);
        this._peerConnection.removeEventListener('removestream', this._onRemoveRemoteStream);
      }
      this._signaler.reset();
      try {
        if (this._peerConnection && this._peerConnection.signalingState !== 'closed') {
          this._peerConnection.close();
        }
      } catch (e) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'failed to close peer connection: ', e);
      }
      this._peerConnection = null;
      this._datamux.reset();
      this._attachmentManager.cleanupPeer(this.peerId);
    }
  }, {
    key: 'attachments',
    get: function get() {
      return this._attachmentManager.getAttachments();
    }
  }, {
    key: 'id',
    get: function get() {
      return this._signaler.ticket;
    }

    // these two are added in callRegistry.js
    /**
     * The room that the call is taking place in.
     *
     * @readonly
     * @member {Room} Call#room
     */
    /**
     * The peer that the call is connecting to.
     *
     * @readonly
     * @member {User} Call#peer
     */

    /**
     * Your own id that the peer will see as {@link Call#peerId}.
     *
     * @readonly
     * @member {string} Call#ownId
     */

  }, {
    key: 'ownId',
    get: function get() {
      return this._ownId;
    }

    /**
     * The id of the peer that the call is connecting to.
     *
     * @readonly
     * @member {string} Call#peerId
     */

  }, {
    key: 'peerId',
    get: function get() {
      return this._peerId;
    }

    /**
     * The state of the signalling channel, `true` if the channel is open, `false` otherwise.
     *
     * @readonly
     * @member {boolean} Call#connected
     */

  }, {
    key: 'connected',
    get: function get() {
      return this._signaler.isConnected();
    }

    /**
     * Whether the call is closed or not. A closed call cannot be started again.
     *
     * @readonly
     * @member {boolean} Call#closed
     */

  }, {
    key: 'closed',
    get: function get() {
      return this._signaler.closed;
    }

    /**
     * Whether the call is stopped or not. The initial state of incoming calls is stopped,
     * and calls will also transition to the stopped state if the connection has failed.
     *
     * @readonly
     * @member {boolean} Call#stopped
     */

  }, {
    key: 'stopped',
    get: function get() {
      return this._signaler.stopped;
    }

    /**
     * The connection state of the call.
     *
     * @readonly
     * @member {PeerConnectionState} Call#connectionState
     */

  }, {
    key: 'connectionState',
    get: function get() {
      return this._signaler.connectionState;
    }

    /**
     * An error describing why the call connection is failing, or null if there is no error.
     * Will always be null if {@link Call#connectionState} is `'connected'` or `'closed'`.
     *
     * @readonly
     * @member {(ConnectionFailedError|ConnectionLostError)?} Call#errorState
     */

  }, {
    key: 'errorState',
    get: function get() {
      return this._signaler.errorState;
    }
  }, {
    key: 'error',
    get: function get() {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].warning('deprecated', 'call.error is deprecated, use call.errorState instead');
      return this._signaler.errorState;
    }
  }]);

  return Call;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_emitter__["a" /* default */])(null));

/* harmony default export */ __webpack_exports__["default"] = (Call);


Call._deprecatedEvents = {
  // FIXME: remove once call.error is removed
  error: function error(funcName) {
    return 'call.' + funcName + '(\'error\', ...) is deprecated, use call.' + funcName + '(\'errorState\', ...) instead';
  }
};

/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MediaBroadcaster; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return DataShare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return FileShare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return PeerMediaPipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return ProxySink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return ProxySource; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol_iterator__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol_iterator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol_iterator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_webrtc_fileRef__ = __webpack_require__(226);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_webrtc_rtcComponent__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_webrtc_candidater__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_webrtc_peerConnectionProxy__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_media_mediaTee__ = __webpack_require__(220);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_media_passthrough__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_media_streamSource__ = __webpack_require__(190);



























/**
 * A component that is used to broadcast media to all peers.
 *
 * Label: `'cct.media.broadcaster'`
 *
 * @example <caption>Example of connecting a MediaBroadcaster to a conference</caption>
 * var conference = room.startConference();
 *
 * var camera = new cct.DeviceSource();
 * var broadcaster = new cct.MediaBroadcaster();
 * camera.connect(broadcaster)
 *
 * broadcaster.on('remoteSource', function (update) {
 *   var peerId = update.peer;
 *   var peerCamera = update.source;
 *   peerCamera.connect(someVideoElements[peerId])
 * });
 *
 * conference.attach('my-broadcaster', broadcaster);
 *
 * @class MediaBroadcaster
 * @implements RtcComponent
 * @extends EventEmitter
 */
var MediaBroadcaster = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(MediaBroadcaster, _EmitterMixin);

  /**
   * Emitted when remote sources are added.
   *
   * @event MediaBroadcaster#added
   * @param {Array<MediaTee>} added - An array of remote sources that were added.
   */

  /**
   * Emitted when remote sources are removed.
   *
   * @event MediaBroadcaster#removed
   * @param {Array<MediaTee>} removed - An array of remote sources that were removed.
   */

  /**
   * Emitted when remote sources are updated.
   *
   * @event MediaBroadcaster#remoteSources
   * @param {Array<MediaTee>} remoteSources - The current list of remote sources.
   */

  function MediaBroadcaster() {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, MediaBroadcaster);

    var _this = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn___default()(this, (MediaBroadcaster.__proto__ || __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of___default()(MediaBroadcaster)).call(this, { label: 'cct.media.broadcaster' }));

    _this.tag = 'media-broadcaster';
    _this._input = new __WEBPACK_IMPORTED_MODULE_21_media_passthrough__["a" /* default */]();
    _this._peerSources = new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default.a();
    _this._remoteSources = [];
    return _this;
  }

  // eslint-disable-next-line
  /**
   * @private
   */


  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(MediaBroadcaster, [{
    key: 'rtcComponentDidReceivePeer',
    value: function rtcComponentDidReceivePeer(peer) {
      this._input.connect(peer);

      var source = new __WEBPACK_IMPORTED_MODULE_20_media_mediaTee__["a" /* default */]();
      peer.connect(source);

      source.peerId = peer.id;
      this._peerSources.set(peer.id, source);
      this._emit('added', [source]);
      this._remoteSources = [].concat(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray___default()(this._peerSources.values()));
      this._emit('remoteSources', this._remoteSources);
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidLosePeer',
    value: function rtcComponentDidLosePeer(peer) {
      var source = this._peerSources.get(peer.id);
      if (!source) {
        __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].warning(this.tag, 'could not find source for removed peer');
        return;
      }
      this._peerSources.delete(peer.id);
      this._emit('removed', [source]);
      this._remoteSources = [].concat(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_toConsumableArray___default()(this._peerSources.values()));
      this._emit('remoteSources', this._remoteSources);
    }

    /**
     * The input for the media that will be broadcasted to all peers.
     *
     * @readonly
     * @member {MediaNodeInput} MediaBroadcaster#input
     */

  }, {
    key: 'input',
    get: function get() {
      return this._input;
    }

    /**
     * The remote sources of all the peers that are broadcasting media.
     *
     * Each of the sources have a `peerId` property set, which identifies the peer
     * that the source is from.
     *
     * @readonly
     * @member {Array<MediaTee>} MediaBroadcaster#remoteSources
     */

  }, {
    key: 'remoteSources',
    get: function get() {
      return this._remoteSources;
    }
  }]);

  return MediaBroadcaster;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_16_webrtc_rtcComponent__["a" /* default */]));

/**
 * A component that allows data to be synchronized between all peers, using the Map API.
 *
 * Label: `'cct.data.share'`
 *
 * @class DataShare
 * @implements RtcComponent
 * @extends EventEmitter
 * @param {Object} [options] - Optional options object.
 * @param {string} [options.ownerId=null] - The owner id used for all updated to the store,
 *   see {@link AttachData#setWithOwnership} for more info.
 */
var DataShare = function (_EmitterMixin2) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(DataShare, _EmitterMixin2);

  function DataShare() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$ownerId = _ref.ownerId,
        ownerId = _ref$ownerId === undefined ? null : _ref$ownerId;

    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, DataShare);

    var _this2 = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn___default()(this, (DataShare.__proto__ || __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of___default()(DataShare)).call(this, { label: 'cct.data.share' }));

    _this2.tag = 'data-share';
    __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].optString(ownerId);
    _this2.ownerId = ownerId;
    return _this2;
  }

  /**
   * Emitted whenever any entry in the map is added, changed, or removed. Events are emitted for both
   * local and remote updates.
   *
   * @event DataShare#update
   * @param {Object} update - Information about the update that occured.
   * @param {string} update.key - The key for the entry that was updated.
   * @param {JsonTypes} update.value - The value that was updated. If the value was deleted this will
   *   be set to `undefined`.
   * @param {JsonTypes} update.oldValue - The previous value, or undefined if it did not exists.
   */

  /**
   * Emitted whenever a specific entry in the map is added, changed, or removed. Events are emitted for both
   * local and remote updates.
   *
   * The `<key>` part of the event name should be replaced with the key you want to listen for, i.e.
   * to listen for the entry for `'position'` to change, you should listen to the `'update:position'` event.
   *
   * @event DataShare#update:&lt;key&gt;
   * @param {JsonTypes} value - The value that was updated. If the value was deleted this will
   *   be set to `undefined`.
   * @param {JsonTypes} oldValue - The previous value, or undefined if it did not exists.
   */

  /**
   * The number of entries in the map.
   *
   * @readonly
   * @member {number} DataShare#size
   */


  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(DataShare, [{
    key: 'keys',


    /**
     * @returns {Iterator<string>} An iterator of all the keys in the map.
     */
    value: function keys() {
      this._checkAttached();
      return this.attachPoint.data.keys();
    }

    /**
     * @returns {Iterator<JsonTypes>} An iterator of all the values in the map.
     */

  }, {
    key: 'values',
    value: function values() {
      this._checkAttached();
      return this.attachPoint.data.values();
    }

    /**
     * @returns {Iterator<Array>} An iterator of all the entries in the map.
     */

  }, {
    key: 'entries',
    value: function entries() {
      this._checkAttached();
      return this.attachPoint.data.entries();
    }

    /**
     * @param {string} key - The key to look for.
     * @returns {boolean} True if there is an entry for the given key.
     */

  }, {
    key: 'has',
    value: function has(key) {
      this._checkAttached();
      return this.attachPoint.data.has(key);
    }

    /**
     * @param {string} key - The key of the value to retrive.
     * @returns {JsonTypes} Returns the value for the given key.
     */

  }, {
    key: 'get',
    value: function get(key) {
      this._checkAttached();
      return this.attachPoint.data.get(key);
    }

    /**
     * Sets set value for the given key.
     *
     * Setting a local value **will** cause an update event to be emitted for that key.
     * The update event does not get emitted synchronously, but is instead scheduled in a microtask.
     *
     * @param {string} key - The key of the value.
     * @param {JsonTypes} value - The value to set.
     */

  }, {
    key: 'set',
    value: function set(key, value) {
      var _this3 = this;

      this._checkAttached();
      var oldValue = this.attachPoint.data.get(key);
      var ret = this.attachPoint.data.setWithOwnership(key, value, this.ownerId);
      __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default.a.reject().catch(function () {
        _this3.rtcComponentUpdatedData({ key: key, value: value, oldValue: oldValue });
      });
      return ret;
    }

    /**
     * Deletes the entry for a given key.
     *
     * Deleting a local entry **will** cause an update event to be emitted for that key.
     * The update event does not get emitted synchronously, but is instead scheduled in a microtask.
     *
     * @param {string} key - The key of the entry to delete.
     * @returns {boolean} True if the entry existed.
     */

  }, {
    key: 'delete',
    value: function _delete(key) {
      var _this4 = this;

      this._checkAttached();
      var oldValue = this.attachPoint.data.get(key);
      var ret = this.attachPoint.data.deleteWithOwnership(key, this.ownerId);
      __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default.a.reject().catch(function () {
        _this4.rtcComponentUpdatedData({ key: key, value: undefined, oldValue: oldValue });
      });
      return ret;
    }

    /**
     * Clears all entries from the map.
     *
     * Clearing the map locally **will** cause an update event to be emitted for every entry.
     * The update event does not get emitted synchronously, but is instead scheduled in a microtask.
     */

  }, {
    key: 'clear',
    value: function clear() {
      var _this5 = this;

      return this.forEach(function (_, key) {
        return _this5.delete(key);
      });
    }

    /**
     * The iterator function passed to {@link DataShare#forEach}.
     *
     * @callback DataShare~ForEachCallback
     * @param {*} key - The key of the current entry.
     * @param {JsonTypes} value - The value of the current entry.
     * @param {DataShare} map - The map itself.
     */

    /**
     * Synchronously calls an interator function once for each entry in the map.
     *
     * Errors thrown inside the iterator function will cancel the iteration.
     *
     * @param {DataShare~ForEachCallback} func - The iterator function.
     * @param {*} [thisArg] - The value to use as `this` inside the iterator function.
     */

  }, {
    key: 'forEach',
    value: function forEach(func, thisArg) {
      this._checkAttached();
      return this.attachPoint.data.forEach(func, thisArg);
    }

    /**
     * This symbol allows the map to be used directly inside a `for..of` loop.
     *
     * @function DataShare#@@iterator
     * @returns {Object} An iterator for all the entries in this map.
     */

  }, {
    key: __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol_iterator___default.a,
    value: function value() {
      this._checkAttached();
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator___default()(this.attachPoint.data);
    }
  }, {
    key: '_checkAttached',
    value: function _checkAttached() {
      if (!this.attachPoint) {
        throw new TypeError('DataShare needs to be attached before it can be used.');
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentUpdatedData',
    value: function rtcComponentUpdatedData(_ref2) {
      var key = _ref2.key,
          value = _ref2.value,
          oldValue = _ref2.oldValue;

      this._emit('update', { key: key, value: value, oldValue: oldValue });
      this._emit('update:' + key, value, oldValue);
    }
  }, {
    key: 'size',
    get: function get() {
      this._checkAttached();
      return this.attachPoint.data.size;
    }
  }]);

  return DataShare;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_16_webrtc_rtcComponent__["a" /* default */]));

/**
 * A component that allows file sharing between peers, using the Map API.
 *
 * Label: `'cct.file.share'`
 *
 * @class FileShare
 * @implements RtcComponent
 * @extends EventEmitter
 */
var FileShare = function (_EmitterMixin3) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(FileShare, _EmitterMixin3);

  function FileShare() {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, FileShare);

    var _this6 = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn___default()(this, (FileShare.__proto__ || __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of___default()(FileShare)).call(this, { label: 'cct.file.share' }));

    _this6.tag = 'file-share';
    _this6._refMap = new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default.a(); // key -> FileRef
    _this6._fileRefs = new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default.a(); // FileRef._id -> FileRef
    return _this6;
  }

  /**
   * Emitted whenever any entry in the map is added, changed, or removed. Events are emitted for both
   * local and remote updates.
   *
   * @event FileShare#update
   * @param {Object} update - Information about the update that occured.
   * @param {string} update.key - The key for the entry that was updated.
   * @param {FileRef} update.value - The value that was updated. If the value was deleted this will
   *   be set to `undefined`.
   * @param {FileRef} update.oldValue - The previous value, or undefined if it did not exists.
   */

  /**
   * Emitted whenever a specific entry in the map is added, changed, or removed. Events are emitted for both
   * local and remote updates.
   *
   * The `<key>` part of the event name should be replaced with the key you want to listen for, i.e.
   * to listen for the entry for `'position'` to change, you should listen to the `'update:position'` event.
   *
   * @event FileShare#update:&lt;key&gt;
   * @param {FileRef} value - The value that was updated. If the value was deleted this will
   *   be set to `undefined`.
   * @param {FileRef} oldValue - The previous value, or undefined if it did not exists.
   */

  /**
   * The number of entries in the map.
   *
   * @readonly
   * @member {number} FileShare#size
   */


  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(FileShare, [{
    key: 'keys',


    /**
     * @returns {Iterator<string>} An iterator of all the keys in the map.
     */
    value: function keys() {
      this._checkAttached();
      return this._refMap.keys();
    }

    /**
     * @returns {Iterator<FileRef>} An iterator of all the file refs in the map.
     */

  }, {
    key: 'values',
    value: function values() {
      this._checkAttached();
      return this._refMap.values();
    }

    /**
     * @returns {Iterator<Array<*>>} An iterator of all the entries in the map.
     */

  }, {
    key: 'entries',
    value: function entries() {
      this._checkAttached();
      return this._refMap.entries();
    }

    /**
     * @param {string} key - The key to look for.
     * @returns {boolean} True if there is an entry for the given key.
     */

  }, {
    key: 'has',
    value: function has(key) {
      this._checkAttached();
      return this._refMap.has(key);
    }

    /**
     * @param {string} key - The key of the file ref to retrive.
     * @returns {FileRef} Returns the file ref for the given key.
     */

  }, {
    key: 'get',
    value: function get(key) {
      this._checkAttached();
      return this._refMap.get(key);
    }

    /**
     * Sets set file ref for the given key.
     *
     * Setting a local value **will** cause an update event to be emitted for that key.
     * The update event does not get emitted synchronously, but is instead scheduled in a microtask.
     *
     * @param {string} key - The key of the value.
     * @param {FileRef} fileRef - The value to set.
     */

  }, {
    key: 'set',
    value: function set(key, fileRef) {
      var _this7 = this;

      this._checkAttached();
      if (!(fileRef instanceof __WEBPACK_IMPORTED_MODULE_15_webrtc_fileRef__["a" /* default */])) {
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].error('fileShare.set', 'fileRef', 'must be a FileRef instance');
      }
      if (!fileRef.isLocal) {
        __WEBPACK_IMPORTED_MODULE_12_common_argCheck__["a" /* default */].error('fileShare.set', 'fileRef', 'must be a local FileRef');
      }
      var oldRef = this._refMap.get(key);
      if (fileRef === oldRef) {
        return;
      }
      this._fileRefs.set(fileRef._id, fileRef);
      this._refMap.set(key, fileRef);

      var value = this._fromFileRef(fileRef);
      var ret = this.attachPoint.data.setWithOwnership(key, value, this.attachPoint.ownId);
      __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default.a.reject().catch(function () {
        _this7._emit('update', { key: key, value: fileRef });
        _this7._emit('update:' + key, fileRef);
      });
      return ret;
    }
  }, {
    key: '_fromFileRef',
    value: function _fromFileRef(_ref3) {
      var isLocal = _ref3.isLocal,
          _id = _ref3._id,
          name = _ref3.name,
          size = _ref3.size,
          type = _ref3.type;

      if (!isLocal) {
        throw new TypeError('Tried to serialize remote FileRef');
      }
      return { id: _id, name: name, size: size, type: type };
    }
  }, {
    key: '_toFileRef',
    value: function _toFileRef(value, peer) {
      var id = value.id;

      var fileRef = this._fileRefs.get(id);
      if (!fileRef) {
        __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].debug(this.tag, 'got file ref meta ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(value) + ' for nonexistent id \'' + id + '\'');
        var createDataChannel = peer.createChannel.bind(peer);
        fileRef = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_14_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_15_webrtc_fileRef__["a" /* default */], value, createDataChannel, peer.id);
        this._fileRefs.set(id, fileRef);
      } else {
        __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].debug(this.tag, 'got file ref meta ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(value) + ' for existing id \'' + id + '\', ' + fileRef);
      }
      return fileRef;
    }

    /**
     * Deletes the entry for a given key.
     *
     * Deleting a local entry **will** cause an update event to be emitted for that key.
     * The update event does not get emitted synchronously, but is instead scheduled in a microtask.
     *
     * @param {string} key - The key of the entry to delete.
     * @returns {boolean} True if the entry existed.
     */

  }, {
    key: 'delete',
    value: function _delete(key) {
      var _this8 = this;

      this._checkAttached();
      // TODO: not enough to set null here
      var fileRef = this._refMap.get(key);
      if (fileRef) {
        this._fileRefs.delete(fileRef._id);
      }
      this._refMap.delete(key);

      var ret = this.attachPoint.data.deleteWithOwnership(key, this.attachPoint.ownId);
      __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_promise___default.a.reject().catch(function () {
        _this8._emit('update', { key: key, value: undefined });
        _this8._emit('update:' + key, undefined);
      });
      return ret;
    }

    /**
     * Clears all entries from the map.
     *
     * Clearing the map locally **will** cause an update event to be emitted for every entry.
     * The update event does not get emitted synchronously, but is instead scheduled in a microtask.
     */

  }, {
    key: 'clear',
    value: function clear() {
      var _this9 = this;

      return this.forEach(function (_, key) {
        return _this9.delete(key);
      });
    }

    /**
     * The iterator function passed to {@link FileShare#forEach}.
     *
     * @callback FileShare~ForEachCallback
     * @param {*} key - The key of the current entry.
     * @param {FileRef} value - The value of the current entry.
     * @param {FileShare} map - The map itself.
     */

    /**
     * Synchronously calls an interator function once for each entry in the map.
     *
     * Errors thrown inside the iterator function will cancel the iteration.
     *
     * @param {FileShare~ForEachCallback} func - The iterator function.
     * @param {*} [thisArg] - The value to use as `this` inside the iterator function.
     */

  }, {
    key: 'forEach',
    value: function forEach(func, thisArg) {
      this._checkAttached();
      return this._refMap.forEach(func, thisArg);
    }

    /**
     * This symbol allows the map to be used directly inside a `for..of` loop.
     *
     * @function FileShare#@@iterator
     * @returns {Object} An iterator for all the entries in this map.
     */

  }, {
    key: __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_symbol_iterator___default.a,
    value: function value() {
      this._checkAttached();
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_get_iterator___default()(this._refMap);
    }
  }, {
    key: '_checkAttached',
    value: function _checkAttached() {
      if (!this.attachPoint) {
        throw new TypeError('FileShare needs to be attached before it can be used.');
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidReceivePeer',
    value: function rtcComponentDidReceivePeer(peer) {
      var _this10 = this;

      this.attachPoint.data.owners.forEach(function (ownerId, key) {
        if (ownerId === peer.id) {
          var value = _this10.attachPoint.data.get(key);
          _this10.rtcComponentUpdatedData({ key: key, value: value, ownerId: ownerId });
        }
      });
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidLosePeer',
    value: function rtcComponentDidLosePeer(peer) {
      var _this11 = this;

      var deleted = [];
      this._fileRefs.forEach(function (fileRef, id) {
        if (fileRef.isLocal) {
          return;
        }
        if (fileRef.peerId === peer.id) {
          _this11._fileRefs.delete(id);
          deleted.push(fileRef._id);
        }
      });
      this._refMap.forEach(function (fileRef, key) {
        if (deleted.indexOf(fileRef._id) !== -1) {
          _this11._refMap.delete(key);
          _this11._emit('update', { key: key, value: null, oldValue: fileRef });
          _this11._emit('update:' + key, null, fileRef);
        }
      });
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentReceivedChannel',
    value: function rtcComponentReceivedChannel(peer, channel) {
      var _this12 = this;

      if (channel.protocol !== 'cct.data.file.v1') {
        return __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].warning(this.tag, 'got channel with unknown protocol: ' + channel.protocol);
      }
      var fileRef = this._fileRefs.get(channel.label);

      if (fileRef) {
        fileRef._startTransfer(channel, peer).catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].error(_this12.tag, 'File transfer error, ' + error);
          channel.close();
        });
      } else {
        __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].warning(this.tag, 'got transfer request for unknown file: ' + channel.label);
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentUpdatedData',
    value: function rtcComponentUpdatedData(_ref4) {
      var key = _ref4.key,
          value = _ref4.value,
          ownerId = _ref4.ownerId;

      if (!ownerId) {
        return __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].error(this.tag, 'got data without owner for key: \'' + key + '\', ignoring');
      }
      var peer = this.attachPoint.peers.get(ownerId);
      if (!peer) {
        return __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].debug(this.tag, 'peer not found: ' + ownerId);
      }
      var oldValue = this._refMap.get(key);

      if (value) {
        var fileRef = this._toFileRef(value, peer);
        if (oldValue !== fileRef) {
          this._refMap.set(key, fileRef);
          this._emit('update', { key: key, value: fileRef, oldValue: oldValue });
          this._emit('update:' + key, fileRef, oldValue);
        }
      } else {
        this._refMap.delete(key);
        this._emit('update', { key: key, value: undefined, oldValue: oldValue });
        this._emit('update:' + key, undefined, oldValue);
      }
    }
  }, {
    key: 'size',
    get: function get() {
      this._checkAttached();
      return this._refMap.size;
    }
  }]);

  return FileShare;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_16_webrtc_rtcComponent__["a" /* default */]));

/**
 * A simple component that allows a single media stream to be sent and received within a call.
 * This component can only be used by calls, and will throw an error if attached to a conference.
 *
 * Media does not have to be sent both ways, i.e. the component will work even if none or just one
 * of the peers are sending media.
 *
 * This component is usually not used directly, as it is used in the implementation of
 * {@link Call#setLocalSource} and {@link Call#getRemoteSource}.
 *
 * Label: `'cct.media.direct'`
 *
 * @class PeerMediaPipe
 * @implements RtcComponent
 * @extends ConnectMixin
 */
var PeerMediaPipe = function (_MediaNode$connectMix) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(PeerMediaPipe, _MediaNode$connectMix);

  function PeerMediaPipe() {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, PeerMediaPipe);

    var _this13 = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn___default()(this, (PeerMediaPipe.__proto__ || __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of___default()(PeerMediaPipe)).call(this, { label: 'cct.media.direct' }));

    _this13.tag = 'direct-media';

    _this13._remoteSource = new __WEBPACK_IMPORTED_MODULE_20_media_mediaTee__["a" /* default */]();
    _this13._localSource = new __WEBPACK_IMPORTED_MODULE_21_media_passthrough__["a" /* default */]();
    return _this13;
  }

  // eslint-disable-next-line
  /**
   * @private
   */


  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(PeerMediaPipe, [{
    key: 'rtcComponentWillAttach',
    value: function rtcComponentWillAttach(attachPoint) {
      if (attachPoint.type !== 'call') {
        throw new Error('Peer media pipe may only be attached to calls.');
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidReceivePeer',
    value: function rtcComponentDidReceivePeer(peer) {
      if (this.attachPoint.peers.size > 1) {
        throw new Error("Peer media pipe can't handle a second peer, something went wrong.");
      }
      this._localSource.connect(peer);
      peer.connect(this._remoteSource);
    }

    /**
     * The input for the media that will be sent to the peer.
     *
     * @member {MediaNodeInput} PeerMediaPipe#input
     */

  }, {
    key: 'input',
    get: function get() {
      return this._localSource;
    }

    /**
     * Output for media that is sent from the peer.
     *
     * @member {MediaNodeOutput} PeerMediaPipe#output
     */

  }, {
    key: 'output',
    get: function get() {
      return this._remoteSource;
    }
  }]);

  return PeerMediaPipe;
}(__WEBPACK_IMPORTED_MODULE_19_media_mediaNode__["a" /* default */].connectMixin(__WEBPACK_IMPORTED_MODULE_16_webrtc_rtcComponent__["a" /* default */]));

// Private API for now
var ProxySink = function (_EmitterMixin4) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(ProxySink, _EmitterMixin4);

  function ProxySink() {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, ProxySink);

    var _this14 = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ProxySink.__proto__ || __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of___default()(ProxySink)).call(this, { label: 'cct.proxy.sink', remoteLabel: 'cct.proxy.source' }));

    _this14.tag = 'proxy-sink';

    _this14._onMessage = _this14._onMessage.bind(_this14);

    _this14._offer = null;
    _this14._answer = null;
    _this14._localCandidates = [];
    _this14._remoteCandidates = [];
    return _this14;
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(ProxySink, [{
    key: 'setOffer',
    value: function setOffer(offer) {
      if (offer) {
        offer = { // Guard for un-serializeable temasys objects
          type: offer.type,
          sdp: offer.sdp
        };
      } else {
        offer = null;
      }
      this._offer = offer;
      this._answer = null;
      this._localCandidates.splice(0);
      this._remoteCandidates.splice(0);
      if (this._channel) {
        this._channel.send({ type: 'offer', content: offer });
      }
      __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].debug(this.tag, 'offer set', offer);
    }
  }, {
    key: 'addCandidate',
    value: function addCandidate(candidate) {
      if (candidate) {
        candidate = new __WEBPACK_IMPORTED_MODULE_17_webrtc_candidater__["b" /* Candidate */](candidate);
        this._localCandidates.push(candidate);
        if (this._channel) {
          this._channel.send({ type: 'candidate', content: candidate });
        }
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentWillAttach',
    value: function rtcComponentWillAttach(attachPoint) {
      if (attachPoint.type !== 'call') {
        throw new Error('ProxySink may only be attached to calls.');
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidReceivePeer',
    value: function rtcComponentDidReceivePeer(peer) {
      var _this15 = this;

      if (this.attachPoint.peers.size > 1) {
        throw new Error("ProxySink can't handle a second peer, something went wrong.");
      }

      this._channel = peer.createChannel({ label: 'proxy', pairingId: 'proxy' });
      this._channel.on('message', this._onMessage);
      this._channel.send({ type: 'offer', content: this._offer });
      this._localCandidates.forEach(function (candidate) {
        _this15._channel.send({ type: 'candidate', content: candidate });
      });

      __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].debug(this.tag, 'connected to peer, sent offer and candidates', this._offer, this._localCandidates);
      this._emit('connected', this);
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidLosePeer',
    value: function rtcComponentDidLosePeer() {
      this._offer = null;
      this._answer = null;
      this._channel = null;
      this._localCandidates.splice(0);
      this._remoteCandidates.splice(0);
    }
  }, {
    key: '_onMessage',
    value: function _onMessage(_ref5) {
      var type = _ref5.type,
          content = _ref5.content;

      __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].verbose(this.tag, 'Got message with type \'' + type + '\'.');
      if (type === 'candidate') {
        var candidate = new RTCIceCandidate(content);
        this._remoteCandidates.push(candidate);
        this._emit('candidate', candidate);
      } else if (type === 'answer') {
        var answer = new RTCSessionDescription(content);
        this._answer = answer;
        this._emit('answer', answer);
      } else {
        __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].error(this.tag, 'Got unknown message type: ' + type + '.');
      }
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'connected',
    get: function get() {
      return !!this._channel;
    }
  }, {
    key: 'offer',
    get: function get() {
      return this._offer;
    }
  }, {
    key: 'answer',
    get: function get() {
      return this._answer;
    }
  }, {
    key: 'remoteCandidates',
    get: function get() {
      return this._remoteCandidates;
    }
  }]);

  return ProxySink;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_13_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_16_webrtc_rtcComponent__["a" /* default */]));

// Private API for now
var ProxySource = function (_MediaNode$connectMix2) {
  __WEBPACK_IMPORTED_MODULE_10_babel_runtime_helpers_inherits___default()(ProxySource, _MediaNode$connectMix2);

  function ProxySource() {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connectionConfig = _ref6.connectionConfig;

    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, ProxySource);

    var _this16 = __WEBPACK_IMPORTED_MODULE_9_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ProxySource.__proto__ || __WEBPACK_IMPORTED_MODULE_6_babel_runtime_core_js_object_get_prototype_of___default()(ProxySource)).call(this, { label: 'cct.proxy.source', remoteLabel: 'cct.proxy.sink' }));

    _this16.tag = 'proxy-source';

    _this16._onMessage = _this16._onMessage.bind(_this16);

    _this16._source = new __WEBPACK_IMPORTED_MODULE_22_media_streamSource__["a" /* default */]();
    _this16._connectionConfig = connectionConfig;
    _this16._onAddStream = _this16._onAddStream.bind(_this16);
    _this16._onRemoveStream = _this16._onRemoveStream.bind(_this16);
    _this16._onIceCandidate = _this16._onIceCandidate.bind(_this16);
    return _this16;
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(ProxySource, [{
    key: 'rtcComponentWillAttach',


    // eslint-disable-next-line
    /**
     * @private
     */
    value: function rtcComponentWillAttach(attachPoint) {
      if (attachPoint.type !== 'call') {
        throw new Error('ProxySource may only be attached to calls.');
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidReceivePeer',
    value: function rtcComponentDidReceivePeer(peer) {
      if (this.attachPoint.peers.size > 1) {
        throw new Error("ProxySource can't handle a second peer, something went wrong.");
      }
      this._channel = peer.createChannel({ label: 'proxy', pairingId: 'proxy' });
      this._channel.on('message', this._onMessage);
    }
  }, {
    key: '_createPeerConnection',
    value: function _createPeerConnection() {
      this._peerConnection = __WEBPACK_IMPORTED_MODULE_18_webrtc_peerConnectionProxy__["a" /* default */].create(this._connectionConfig);
      this._peerConnection.addEventListener('addstream', this._onAddStream);
      this._peerConnection.addEventListener('removestream', this._onRemoveStream);
      this._peerConnection.addEventListener('icecandidate', this._onIceCandidate);
    }
  }, {
    key: '_cleanupPeerConnection',
    value: function _cleanupPeerConnection() {
      this._source.setStream(null);
      if (this._peerConnection) {
        this._peerConnection.removeEventListener('addstream', this._onAddStream);
        this._peerConnection.removeEventListener('removestream', this._onRemoveStream);
        this._peerConnection.removeEventListener('icecandidate', this._onIceCandidate);
        try {
          this._peerConnection.close();
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].verbose(this.tag, 'Failed to close peer connection: ' + error);
        }
        this._peerConnection = null;
      }
    }
  }, {
    key: '_onAddStream',
    value: function _onAddStream(_ref7) {
      var stream = _ref7.stream;

      __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].debug(this.tag, 'Added stream \'' + stream.id + '\' to proxy source connection.');
      this._source.setStream(stream);
    }
  }, {
    key: '_onRemoveStream',
    value: function _onRemoveStream(_ref8) {
      var stream = _ref8.stream;

      __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].debug(this.tag, 'Removed stream \'' + stream.id + '\' from proxy source connection.');
      if (this.output.stream === stream) {
        this._source.setStream(null);
      }
    }
  }, {
    key: '_onIceCandidate',
    value: function _onIceCandidate(_ref9) {
      var candidate = _ref9.candidate;

      if (candidate) {
        candidate = new __WEBPACK_IMPORTED_MODULE_17_webrtc_candidater__["b" /* Candidate */](candidate);
        __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].verbose(this.tag, 'got candidate: ' + candidate);
        if (this._channel) {
          this._channel.send({ type: 'candidate', content: candidate });
        } else {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].info(this.tag, 'Ignoring candidate since peer was not connected');
        }
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidLosePeer',
    value: function rtcComponentDidLosePeer() {
      this._channel = null;
      this._cleanupPeerConnection();
    }
  }, {
    key: '_onMessage',
    value: function _onMessage(_ref10) {
      var type = _ref10.type,
          content = _ref10.content;

      if (type === 'offer') {
        this._setOffer(content);
      } else if (type === 'candidate') {
        this._addCandidate(content);
      } else {
        __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].error(this.tag, 'Got unknown message type: ' + type + '.');
      }
    }
  }, {
    key: '_setOffer',
    value: function _setOffer(offer) {
      var _this17 = this;

      this._cleanupPeerConnection();
      if (offer) {
        this._createPeerConnection();
        this._peerConnection.performAnswer({ offer: offer }).then(function (answer) {
          if (_this17._channel) {
            _this17._channel.send({ type: 'answer', content: answer });
          }
        }).catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].error(_this17.tag, 'Failed to set offer and generate answer: ' + error);
        });
      }
    }
  }, {
    key: '_addCandidate',
    value: function _addCandidate(candidate) {
      var _this18 = this;

      if (this._peerConnection) {
        this._peerConnection.addIceCandidate(candidate).catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_11_common_log__["default"].error(_this18.tag, 'Failed to add candidate: ' + error);
        });
      }
    }
  }, {
    key: 'output',
    get: function get() {
      return this._source;
    }
  }]);

  return ProxySource;
}(__WEBPACK_IMPORTED_MODULE_19_media_mediaNode__["a" /* default */].connectMixin(__WEBPACK_IMPORTED_MODULE_16_webrtc_rtcComponent__["a" /* default */]));

/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FileTransfer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return FileDownload; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_queue__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__ = __webpack_require__(161);

















var FILE_TRANSFER_SLICE_SIZE = 1024 * 64;
var FILE_TRANSFER_CHUNK_SIZE = 64 * FILE_TRANSFER_SLICE_SIZE; // 4 MiB
var FILE_TRANSFER_TIMEOUT_MS = 8000;

var TAG = 'file-ref';

/**
 * Represents a reference to a file, which resides either locally, or at some remote peer.
 *
 * If the file is available locally it can be accessed directly,
 *  otherwise it has to be downloaded first.
 *
 * @class FileRef
 * @abstract
 */

var FileRef = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(FileRef, _EmitterMixin);

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(FileRef, null, [{
    key: 'fromFile',

    /**
     * Emitted when the file download ends, both on success and failure.
     *
     * @event FileRef#end
     * @param {'done'|'error'|'aborted'} reason - A string identifying the reason the download ended.
     */

    /**
     * Emitted when the file download ends before it is completed.
     *
     * @event FileRef#error
     * @oaram {Error} error - The error that caused the download to fail
     */

    /**
     * Emitted when the file download is completed successfully.
     *
     * @event FileRef#load
     */

    /**
     * Emitted each time the progress of the file download changes.
     *
     * @event FileRef#progress
     */

    /**
     * Emitted each time a remote peer starts downloading the file.
     *
     * @event FileRef#transfer
     * @param {FileTransfer} transfer - The object representing the transfer to the remote peer
     */

    /**
     * Emitted when the list of file transfers is changes.
     *
     * @event FileRef#transfers
     * @param {FileTransfer[]} transfers - A list of file transfers
     */

    /**
     * Creates a new file reference from a file.
     *
     * @param {external:File} file - An HTML5 file object.
     * @returns {FileRef} - A new file ref.
     */
    value: function fromFile(file) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["priv"])(FileRef, {
        file: file
      });
    }

    /**
     * Creates a new file reference from a blob and a filename.
     *
     * @param {string} filename - The filename to be used to the file.
     * @param {external:Blob} blob - An HTML5 blob object.
     * @returns {FileRef} - A new file ref.
     */

  }, {
    key: 'fromBlob',
    value: function fromBlob(filename, blob) {
      blob.lastModifiedDate = new Date();
      blob.name = filename;
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["priv"])(FileRef, {
        file: blob
      });
    }

    /**
     * Creates a new file reference from a data uri and a filename.
     *
     * @param {string} filename - The filename to be used to the file.
     * @param {string} dataUri - A data uri.
     * @returns {FileRef} - A new file ref.
     */

  }, {
    key: 'fromDataUri',
    value: function fromDataUri(filename, dataUri) {
      var parsed = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["parseDataUri"])(dataUri);
      var buffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["binaryStringToArrayBuffer"])(parsed.binaryString);
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["priv"])(FileRef, {
        file: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["bufferToFile"])(buffer, filename, parsed.mimeType)
      });
    }

    /**
     * Creates a new file reference from a binary string, mime type, and a filename.
     *
     * @param {string} filename - The filename to be used to the file.
     * @param {string} mimeType - The mime type of the file.
     * @param {string} binaryString - File contents as a binary string.
     * @returns {FileRef} - A new file ref.
     */

  }, {
    key: 'fromBinaryString',
    value: function fromBinaryString(filename, mimeType, binaryString) {
      var buffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["binaryStringToArrayBuffer"])(binaryString);
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["priv"])(FileRef, {
        file: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["bufferToFile"])(buffer, filename, mimeType)
      });
    }
  }]);

  function FileRef(priv, config, dataChannelFactory, peerId) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, FileRef);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (FileRef.__proto__ || __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default()(FileRef)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["assertPriv"])('FileRef', priv);

    if (peerId) {
      _this._id = config.id;
      _this._file = null;
      _this._name = config.name;
      _this._size = config.size;
      _this._type = config.type;
      _this._download = null;
      _this._downloadPromise = null;
      _this._transfers = [];
      _this._progress = 0;
      _this._peerId = peerId;
      _this._dataChannelFactory = dataChannelFactory;
    } else {
      _this._id = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["randomString"])(16);
      _this._file = config.file;
      _this._name = config.file.name;
      _this._size = config.file.size;
      _this._type = config.file.type;
      _this._transfers = [];
      _this._progress = 1;
      _this._peerId = null;

      FileRef._localFileRefs[_this._id] = _this;
    }
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(FileRef, [{
    key: 'toString',
    value: function toString() {
      return 'fileRef{id=' + this._id + ',name=' + this._name + ',size=' + this._size + ',type=' + this._type + ',peerId=' + this._peerId + '}';
    }

    /**
     * The referenced file, or null if it isn't available locally.
     *
     * @readonly
     * @member {external:File} FileRef#file
     */

  }, {
    key: 'fetch',


    /**
     * Downloads the file from a remote peer. If the file has already been downloaded
     * or the reference points to a local file, the returned promise will be immediately resolved.
     *
     * Calling this method multiple times will not cause multiple downloads, subsequent call will
     * return the same promise. The exception to that rule is if the previous download failed, in
     * that case a new download will be started.
     *
     * This method of downloading the file will cause the entire file to be stored in memory, so it
     * can only be used with files that are a couple of hundred MB in size. For large files, use
     * {@link FileRef#stream} instead.
     *
     * @name FileRef#fetch
     * @function
     * @returns {Promise<external:File>} - A promise for the file.
     */
    value: function fetch() {
      var _this2 = this;

      if (this._file) {
        return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve(this._file);
      }
      if (!this._downloadPromise) {
        var chunks = [];
        this._download = this.stream();
        this._download.on('chunk', function (chunk) {
          return chunks.push(chunk);
        });
        this._download.on('progress', function (_progress) {
          _this2._progress = _progress;
          _this2._emit('progress', _this2._progress);
        });
        this._downloadPromise = this._download.promise.then(function () {
          _this2._file = new Blob(chunks, { type: _this2._type });
          _this2._file.name = name;
          _this2._file.lastModifiedDate = new Date();
          _this2._emit('load', _this2._file);
          _this2._emit('end', 'done');
          return _this2._file;
        }, function (error) {
          _this2._emit('error', error);
          if (error.name === 'TransferInterruptedError' && error.reason === 'aborted') {
            _this2._emit('end', 'aborted');
          } else {
            _this2._emit('end', 'error');
          }
          _this2._progress = 0;
          _this2._emit('progress', 0);
          throw error;
        });
      }
      return this._downloadPromise;
    }

    /**
     * Downloads the file from a remote peer. As opposed to {@link FileRef#fetch}, this method
     * returns a {@link FileDownload} instance. It is also disconnected from the {@link FileRef} instance,
     * and has it's own progress tracking.
     *
     * This method allows much larger files to be transferred compared to {@link FileRef#fetch},
     * since the entire file doesn't need to be loaded into memory at once.
     *
     * Each call to this method will start a new separate download.
     *
     * @returns {FileDownload} - A newly created {@link FileDownload} instance.
     */

  }, {
    key: 'stream',
    value: function stream() {
      if (!this._peerId) {
        throw new TypeError('Only remote files can be streamed.');
      }
      var channel = this._dataChannelFactory({
        label: this._id,
        protocol: 'cct.data.file.v1'
      });
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, 'created download channel: ' + channel);
      return FileDownload.stream({ channel: channel, size: this._size });
    }

    /**
     * Aborts any ongoing file download. Has no effect if the file download
     * is complete or hasn't started.
     *
     * @name FileRef#abort
     * @function
     * @returns {boolean} - True if a download was aborted, false otherwise.
     */

  }, {
    key: 'abort',
    value: function abort() {
      if (this._download) {
        return this._download.abort();
      } else {
        return false;
      }
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      if (!this._file) {
        throw new TypeError('Tried to serialize remote FileRef');
      }
      return {
        __cct_type__: 'file',
        id: this._id,
        name: this._name,
        size: this._size,
        type: this._type
      };
    }
  }, {
    key: '_startTransfer',
    value: function _startTransfer(channel, peer) {
      var _this3 = this;

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'starting transfer to ' + peer + ' via ' + channel);

      var transfer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["priv"])(FileTransfer, channel, peer, this._file, function () {
        var index = _this3._transfers.indexOf(transfer);
        if (index !== -1) {
          _this3._transfers.splice(index, 1);
        }
        _this3._emit('transfers', _this3._transfers);
      });
      var executePromise = transfer._execute();
      this._transfers.push(transfer);
      this._emit('transfer', transfer);
      this._emit('transfers', this._transfers);
      return executePromise;
    }
  }, {
    key: 'file',
    get: function get() {
      return this._file;
    }

    /**
     * The name of the file.
     *
     * @readonly
     * @member {string} FileRef#name
     */

  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }
  }, {
    key: 'peer',
    get: function get() {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].warning('deprecated', 'FileRef.peer is deprecated, use FileTransfer.peerId instead');
      return this._peerId || null;
    }

    /**
     * The id of the peer that shared the file, or null if the file is local.
     *
     * @readonly
     * @member {string?} FileRef#peerId
     */

  }, {
    key: 'peerId',
    get: function get() {
      return this._peerId || null;
    }

    /**
     * The size of the file in bytes.
     *
     * @readonly
     * @member {number} FileRef#size
     */

  }, {
    key: 'size',
    get: function get() {
      return this._size;
    }

    /**
     * The mime type of the file.
     *
     * @readonly
     * @member {string} FileRef#type
     */

  }, {
    key: 'type',
    get: function get() {
      return this._type;
    }

    /**
     * A list of ongoing transfers of the file to other peers.
     *
     * @readonly
     * @member {FileTransfer[]} FileRef#transfers
     */

  }, {
    key: 'transfers',
    get: function get() {
      return this._transfers;
    }

    /**
     * True if the file reference points to a local file, false otherwise.
     *
     * @readonly
     * @member {boolean} FileRef#isLocal
     */

  }, {
    key: 'isLocal',
    get: function get() {
      return !!this._file;
    }

    /**
     * The progress of the file download in the range [0, 1].
     *
     * Will always be 1 for local files.
     *
     * @readonly
     * @member {number} FileRef#progress
     */

  }, {
    key: 'progress',
    get: function get() {
      return this._progress;
    }
  }]);

  return FileRef;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_emitter__["a" /* default */])(null));

/* harmony default export */ __webpack_exports__["a"] = (FileRef);


__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["hiddenProp"])(FileRef, '_localFileRefs', {});

/**
 * A utility to split a file into chunks. The main purpose is to always be one read ahead
 * of the consumer, to speed up the transfer process. Reading a chunk can take 40ms or more,
 * which could be enough time to empty the send buffer on a quick network.
 *
 * @class FileChunker
 * @private
 */

var FileChunker = function () {
  function FileChunker(file) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, FileChunker);

    this._file = file;
    this._chunkStart = 0;
    this.totalBytes = file.size;
    this.chunkCount = Math.ceil(this.totalBytes / FILE_TRANSFER_CHUNK_SIZE);

    this._read();
  }

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(FileChunker, [{
    key: '_read',
    value: function _read() {
      if (this._chunkStart >= this.totalBytes) {
        this._nextChunk = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve(null);
        return;
      }

      var chunkStart = this._chunkStart;
      var chunkEnd = this._chunkStart + FILE_TRANSFER_CHUNK_SIZE;
      var chunk = this._file.slice(chunkStart, chunkEnd);
      this._chunkStart = chunkEnd;

      this._nextChunk = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["blobToArrayBuffer"])(chunk).then(function (chunkBuffer) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["arrayBufferSha1IfSupported"])(chunkBuffer).then(function (sha1) {
          var byteLength = chunkBuffer.byteLength;

          return { chunkBuffer: chunkBuffer, byteLength: byteLength, sha1: sha1 };
        });
      });
    }
  }, {
    key: 'next',
    value: function next() {
      var nextChunk = this._nextChunk;
      this._read();
      return nextChunk;
    }
  }, {
    key: 'cleanup',
    value: function cleanup() {
      this._file = null;
      this._nextChunk = null;
    }
  }]);

  return FileChunker;
}();

/**
 * Represents the transfer of a local file to a remote peer.
 *
 * @abstract
 * @class FileTransfer
 */


var FileTransfer = function (_EmitterMixin2) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(FileTransfer, _EmitterMixin2);

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(FileTransfer, null, [{
    key: 'transferFileInChannel',

    /**
     * A low-level API for sending a file over a data channel to be received by a {@link FileDownload}.
     *
     * As soon as this method is called and the channel has been opened, the file transfer will begin, which
     * means that a {@link FileDownload} must be ready to receive the file at that time.
     *
     * @private
     * @param {File|Blob} file - The file to be sent.
     * @param {DataChannel} channel - The data channel to send the file through.
     * @returns {Promise} - A promise that is resolved when the transfer is complete, or is rejected
     *   with a data channel error.
     */
    value: function transferFileInChannel(file, channel) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].object('FileTransfer.transferFileInChannel', 'file', file);
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].object('FileTransfer.transferFileInChannel', 'channel', channel);
      var transfer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["priv"])(FileTransfer, channel, null, file);
      return transfer._execute();
    }

    /**
     * Emitted when the file transfer is completed successfully.
     *
     * @event FileTransfer#done
     */

    /**
     * Emitted when the file transfer fails.
     *
     * @event FileTransfer#error
     * @oaram {Error} error - The error that caused the transfer to fail.
     */

    /**
     * Emitted when the file transfer ends, both on success and failure.
     *
     * @event FileTransfer#end
     * @param {'done'|'error'|'aborted'} reason - A string identifying the reason the transfer ended.
     */

    /**
     * Emitted when the file transfer is completed successfully.
     *
     * @event FileTransfer#done
     */

    /**
     * Emitted each time the progress of the file transfer changes.
     *
     * @event FileTransfer#progress
     */

  }]);

  function FileTransfer(priv, channel, peer, file, onEnded) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, FileTransfer);

    var _this4 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (FileTransfer.__proto__ || __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default()(FileTransfer)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["assertPriv"])('FileTransfer', priv);
    _this4._channel = channel;
    _this4._peer = peer;
    _this4._chunker = new FileChunker(file);
    _this4._onEnded = onEnded;

    _this4._done = false;
    _this4._ended = false;
    _this4._error = null;
    _this4._progress = 0;
    return _this4;
  }

  /**
   * Aborts the file transfer, if it is still ongoing.
   *
   * @function FileTransfer#abort
   */


  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(FileTransfer, [{
    key: 'abort',
    value: function abort() {
      this._end('aborted');
    }
  }, {
    key: '_end',
    value: function _end(reason) {
      if (!this._ended) {
        this._ended = true;
        this._onEnded && this._onEnded();
        this._emit('end', reason);
        this._chunker.cleanup();
        this._chunker = null;
      }
    }
  }, {
    key: '_execute',
    value: function _execute() {
      var _this5 = this;

      return this._channel.sendWithGenerator(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee() {
        var sentBytes, totalBytes, chunkSha1s, nextChunk, chunkBuffer, byteLength, _sha, bufferView, chunkSpec, offset, slice, sha1, sha1SumBuffer, fileSpec;

        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // For tracking progress
                sentBytes = 0;
                totalBytes = this._chunker.totalBytes;
                chunkSha1s = [];

              case 3:
                _context.next = 5;
                return this._chunker.next();

              case 5:
                nextChunk = _context.sent;

                if (nextChunk) {
                  _context.next = 8;
                  break;
                }

                return _context.abrupt('break', 28);

              case 8:
                chunkBuffer = nextChunk.chunkBuffer, byteLength = nextChunk.byteLength, _sha = nextChunk.sha1;

                if (_sha) {
                  chunkSha1s.push(_sha);
                  _sha = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["bufferToHex"])(_sha);
                }
                bufferView = new window.Uint8Array(chunkBuffer);
                chunkSpec = { type: 'chunk', byteLength: byteLength, sha1: _sha };

                __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].verbose(TAG, 'file transfer sent chunk spec: ' + chunkSpec);
                _context.next = 15;
                return chunkSpec;

              case 15:
                offset = 0;

              case 16:
                if (!(offset < byteLength)) {
                  _context.next = 26;
                  break;
                }

                slice = bufferView.subarray(offset, offset + FILE_TRANSFER_SLICE_SIZE);
                _context.next = 20;
                return slice;

              case 20:
                offset += slice.byteLength;

                sentBytes += slice.byteLength;
                this._progress = sentBytes / totalBytes;
                this._emit('progress', this._progress);
                _context.next = 16;
                break;

              case 26:
                _context.next = 3;
                break;

              case 28:
                sha1 = null;

                if (!chunkSha1s.length) {
                  _context.next = 34;
                  break;
                }

                sha1SumBuffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["concatenateArrayBuffers"])(chunkSha1s);
                _context.next = 33;
                return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["arrayBufferSha1IfSupported"])(sha1SumBuffer).then(__WEBPACK_IMPORTED_MODULE_11_common_utils__["bufferToHex"]);

              case 33:
                sha1 = _context.sent;

              case 34:
                fileSpec = {
                  type: 'file',
                  chunkCount: this._chunker.chunkCount,
                  byteLength: totalBytes,
                  sha1: sha1
                };
                _context.next = 37;
                return fileSpec;

              case 37:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }).bind(this), { timeoutMs: FILE_TRANSFER_TIMEOUT_MS }).then(function () {
        _this5._emit('done');
        _this5._end('done');
      }, function (error) {
        _this5._error = error;
        _this5._emit('error', error);
        _this5._end('error');
        throw error;
      });
    }
  }, {
    key: 'peer',
    get: function get() {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].warning('deprecated', 'FileTransfer.peer is deprecated, use FileTransfer.peerId instead');
      return this._peer;
    }

    /**
     * The id of the remote peer that the file is being transferred to.
     *
     * @readonly
     * @member {string} FileTransfer#peer
     */

  }, {
    key: 'peerId',
    get: function get() {
      return this._peer.id;
    }

    /**
     * The progress of the file transfer, in the range [0, 1].
     *
     * @readonly
     * @member {number} FileTransfer#progress
     */

  }, {
    key: 'progress',
    get: function get() {
      return this._progress;
    }

    /**
     * The error that ended the file transfer, or null
     * if the transfer hasn't ended with an error.
     *
     * @readonly
     * @member {Error} FileTransfer#error
     */

  }, {
    key: 'error',
    get: function get() {
      return this._error;
    }
  }]);

  return FileTransfer;
}(__WEBPACK_IMPORTED_MODULE_9_common_emitter__["a" /* default */]);

/**
 * Represents the download of a single file from a remote peer.
 *
 * The download will emit `'chunk'` events for every chunk of the file that is
 * downloaded. The size of each chunk is 4MiB, unless it's the last chunk, which
 * may be smaller.
 *
 * To reconstruct the file, all chunks should be concatenated in the order they are emitted.
 *
 * The chunks are not stored internally, so if the `'chunk'` events are not captured, the
 * chunks will be lost.
 *
 * The {@link FileDownload#promise} property exposes a promise that will be resolved
 * when the download is complete, i.e. the last chunk has been received. If the download
 * is interrupted, aborted, or corrupt, the promise will be rejected.
 *
 * @class FileDownload
 * @abstract
 */
var FileDownload = function (_EmitterMixin3) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(FileDownload, _EmitterMixin3);

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(FileDownload, null, [{
    key: 'stream',

    /**
     * Emitted when the progress of the download is updated.
     *
     * @event FileDownload#progress
     * @param {number} progress - The progress in the range [0, 1].
     */

    /**
     * Emitted when a full chunk of the file has been downloaded and verified.
     *
     * @event FileDownload#chunk
     * @param {ArrayBuffer} chunk - The chunk of the file.
     */

    /**
     * A low-level API for downloading files that are being sent using a {@link FileTransfer}.
     *
     * This expects that the next messages emitted from the channel are the ones sent by a transfer,
     * which means that this should usually by used just after creating a channel, or after some other
     * signaling mechanism has completed.
     *
     * @private
     * @param {Options} options - Options object.
     * @param {DataChannel} options.channel - The channel from which the file is downloaded.
     * @param {number} [options.size=-1] - The expected size of the file in bytes, used to keep track of progress.
     *   The download will stop just because the given number of bytes has been downloaded.
     * @param {string} [options.mimeType] - The mime type of the file, will be used as
     *   the type of the blob if given.
     * @param {boolean} [options.leaveChannelOpen=false] - Whether to leave the channel
     *   open after the download is complete.
     * @returns {FileDownload} A newly created file download instance.
     */
    value: function stream(options) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].options('FileDownload.fetch', 'options', options).object('channel').optNumber('size').optBoolean('leaveChannelOpen');
      var download = new FileDownload(options);
      download._execute();
      return download;
    }

    /**
     * This is a higher-level version of {@link FileDownload.stream}, which merges together the downloaded
     * chunks into a {@link external:Blob}. This method does not expose the download instance
     * so it is not possible to keep track of the progress.
     *
     * @private
     * @param {Options} options - Options object.
     * @param {DataChannel} options.channel - The channel from which the file is downloaded.
     * @param {string} [options.mimeType] - The mime type of the file, will be used as
     *   the type of the blob if given.
     * @param {boolean} [options.leaveChannelOpen=false] - Whether to leave the channel
     *   open after the download is complete.
     * @returns {Promise<external:Blob>} A promise that resolves to a blob of the downloaded file, or
     *   may be rejected for the same reasons as {@link FileDownload#promise}.
     */

  }, {
    key: 'fetch',
    value: function fetch(options) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].options('FileDownload.fetch', 'options', options).object('channel').optString('mimeType').optBoolean('leaveChannelOpen');

      var channel = options.channel,
          leaveChannelOpen = options.leaveChannelOpen,
          mimeType = options.mimeType;

      var download = new FileDownload({ channel: channel, leaveChannelOpen: leaveChannelOpen });
      var chunks = [];
      download.on('chunk', function (chunk) {
        return chunks.push(chunk);
      });
      return download._execute().then(function () {
        var blob = new Blob(chunks, { type: mimeType });
        chunks.length = 0;
        return blob;
      });
    }
  }]);

  function FileDownload(_ref) {
    var channel = _ref.channel,
        _ref$size = _ref.size,
        size = _ref$size === undefined ? -1 : _ref$size,
        _ref$leaveChannelOpen = _ref.leaveChannelOpen,
        leaveChannelOpen = _ref$leaveChannelOpen === undefined ? false : _ref$leaveChannelOpen;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, FileDownload);

    var _this6 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (FileDownload.__proto__ || __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default()(FileDownload)).call(this));

    _this6._size = size;
    _this6._channel = channel;
    _this6._leaveChannelOpen = leaveChannelOpen;
    _this6._state = null;
    _this6._downloaded = 0;
    _this6._chunkCount = 0;
    _this6._chunkProcessQueue = new __WEBPACK_IMPORTED_MODULE_10_common_queue__["a" /* default */]();
    _this6._chunkSha1s = [];
    _this6._deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["defer"])();
    return _this6;
  }

  /**
   * The progress of the file download, in the range [0, 1].
   *
   * @readonly
   * @member {number} FileDownload#progress
   */


  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(FileDownload, [{
    key: 'abort',


    /**
     * Aborts the file download. This will cause {@link FileDownload#promise} to be rejected with
     * a {@link TransferInterruptedError} with `reason` set to 'aborted'.
     *
     * @returns {boolean} - True if the download was aborted, or false if it was already finished.
     */
    value: function abort() {
      if (this._state !== 'downloading') {
        return false;
      }
      this._end('aborted', new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["c" /* TransferInterruptedError */]('aborted', this._downloaded, this._size));
      return true;
    }
  }, {
    key: '_execute',
    value: function _execute() {
      var _this7 = this;

      if (this._state !== null) {
        throw new Error('tried to execute file download at invalid state: ' + this._state);
      }
      this._state = 'downloading';

      this._channel.receiveWithGenerator(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee2() {
        var spec, byteLength, chunk, offset, slice;
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return;

              case 2:
                spec = _context2.sent;

                __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].verbose(TAG, 'file download got spec: ' + spec);

                if (!(spec.type === 'chunk')) {
                  _context2.next = 23;
                  break;
                }

                byteLength = spec.byteLength;
                chunk = new Uint8Array(byteLength);
                offset = 0;

              case 8:
                if (!(offset < byteLength)) {
                  _context2.next = 20;
                  break;
                }

                _context2.t0 = Uint8Array;
                _context2.next = 12;
                return;

              case 12:
                _context2.t1 = _context2.sent;
                slice = new _context2.t0(_context2.t1);

                chunk.set(slice, offset);
                offset += slice.byteLength;

                this._downloaded += slice.byteLength;
                if (this._size >= 0) {
                  this._emit('progress', this._downloaded / this._size);
                }
                _context2.next = 8;
                break;

              case 20:

                this._emitChunk(chunk, spec);
                _context2.next = 28;
                break;

              case 23:
                if (!(spec.type === 'file')) {
                  _context2.next = 27;
                  break;
                }

                this._finish(spec);
                _context2.next = 28;
                break;

              case 27:
                throw new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["f" /* FileTransferError */]('Unexpected message \'' + spec + '\', expected spec');

              case 28:
                _context2.next = 0;
                break;

              case 30:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }).bind(this), { timeoutMs: FILE_TRANSFER_TIMEOUT_MS }).catch(function (error) {
        if (_this7._state === 'downloading') {
          if (error.name === 'ChannelClosedError') {
            _this7._end('error', new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["c" /* TransferInterruptedError */]('closed', _this7._downloaded, _this7._size));
          } else {
            _this7._end('error', error);
          }
        }
      });

      return this._deferred.promise;
    }
  }, {
    key: '_emitChunk',
    value: function _emitChunk(chunk, chunkSpec) {
      var _this8 = this;

      if (this._state !== 'downloading') {
        return;
      }
      var sha1 = chunkSpec.sha1,
          byteLength = chunkSpec.byteLength;

      if (chunk.byteLength !== byteLength) {
        var msg = 'Chunk size ' + chunk.byteLength + ' does not match the expected size ' + byteLength;
        this._end('error', new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["f" /* FileTransferError */](msg));
        return;
      }

      this._chunkProcessQueue.push(function () {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["arrayBufferSha1IfSupported"])(chunk).then(function (actualSha1) {
          if (_this8._state !== 'downloading') {
            return;
          }

          if (sha1 && actualSha1) {
            if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["bufferToHex"])(actualSha1) === sha1) {
              _this8._chunkSha1s.push(actualSha1);
            } else {
              _this8._end('error', new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["f" /* FileTransferError */]('Chunk checksums don\'t match, ' + sha1 + ' != ' + actualSha1));
              return;
            }
          }
          _this8._chunkCount += 1;
          _this8._emit('chunk', chunk.buffer);
        });
      }).catch(function (error) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'Error processing chunk: ' + error);
      });
    }
  }, {
    key: '_finish',
    value: function _finish(fileSpec) {
      var _this9 = this;

      if (this._state !== 'downloading') {
        return;
      }
      var sha1 = fileSpec.sha1,
          byteLength = fileSpec.byteLength,
          chunkCount = fileSpec.chunkCount;


      if (this._downloaded !== byteLength) {
        var msg = 'File size ' + this._downloaded + ' does not match the expected size ' + byteLength;
        this._end('error', new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["f" /* FileTransferError */](msg));
        return;
      }

      this._chunkProcessQueue.push(function () {
        if (_this9._chunkSha1s.length) {
          var sha1SumBuffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["concatenateArrayBuffers"])(_this9._chunkSha1s);
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["arrayBufferSha1IfSupported"])(sha1SumBuffer);
        } else {
          return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve();
        }
      }).then(function (actualSha1) {
        if (_this9._state !== 'downloading') {
          return;
        }

        if (_this9._chunkCount !== chunkCount) {
          var _msg = 'File chunk count ' + _this9._chunkCount + ' does not match the expected ' + chunkCount;
          _this9._end('error', new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["f" /* FileTransferError */](_msg));
          return;
        }

        if (sha1 && actualSha1) {
          if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_utils__["bufferToHex"])(actualSha1) !== sha1) {
            _this9._end('error', new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["f" /* FileTransferError */]('File checksums don\'t match, ' + sha1 + ' != ' + actualSha1));
            return;
          }
        }
        _this9._end('done');
      }).catch(function (error) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'Error processing file: ' + error);
      });
    }
  }, {
    key: '_end',
    value: function _end(state) {
      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (error) {
        this._chunkCount = 0;
        this._downloaded = 0;
        this._emit('progress', 0);
        this._deferred.reject(error);
      } else {
        this._deferred.resolve();
      }

      this._state = state;
      this._error = error;
      this._clearListeners();
      if (!this._leaveChannelOpen) {
        this._channel.close();
        this._channel = null;
      }
      this._chunkProcessQueue.clear();
      this._chunkProcessQueue = null;
      this._chunkSha1s = null;
    }
  }, {
    key: 'progress',
    get: function get() {
      return this._downloaded / this._size;
    }

    /**
     * A promise that will be resolved when the download is complete, i.e. the last chunk
     * has been received.
     *
     * If the download is aborted, the promise will be rejected with a {@link TransferInterruptedError}
     * with `reason` set to 'aborted'.
     *
     * If the download failes because the connection failed, the promise will be rejected with a
     * {@link TransferInterruptedError} with `reason` set to 'closed'.
     *
     * If the file transfer either encounters a protocol error, or if the transmitted file was
     * correupted, the promise will be rejected with a {@link FileTransferError}.
     *
     * @returns {Promise} A promise that is resolved or rejected when the transfer ends.
     */

  }, {
    key: 'promise',
    get: function get() {
      return this._deferred.promise;
    }
  }]);

  return FileDownload;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_emitter__["a" /* default */])(null));

/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign__ = __webpack_require__(288);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_datamux_channelDriver__ = __webpack_require__(268);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_datamux_channelController__ = __webpack_require__(267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_datamux_registry__ = __webpack_require__(269);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_datamux_channel__ = __webpack_require__(266);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_datamux_activityTracker__ = __webpack_require__(263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_datamux_bandwidthEstimation__ = __webpack_require__(264);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_datamux_buffers__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_datamux_transfer__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_datamux_constants__ = __webpack_require__(182);


// This module contains the main datamux implementation,
// which ties together the other utilities.
// It is the only internal API that is exposed to the
// rest of the library.























var isWebRtcPlugin =  false ? false : __webpack_require__(66).isWebRtcPlugin;

var TAG = 'datamux';

/*
Data channels in WebRTC have a number of problems that make them difficult to use:

- Only supported message types are strings and arraybuffers, which means that
    applications need to handle serialization and type conversions.
- They have somewhat arbitrary limits on message size, which varies depending
    on the browsers involved. Large messages will be divided automatically, but there is
    no obvious way for the sender or the receiver to detect that a message has been split.
- If the application tries to send too much data too quickly the channel will
    be closed, and the method of sending data at the correct pace varies
    between WebRTC implementations.
- Between Chrome and Firefox opening new data channel breaks after the first
    renegotiation, so all channels have to be opened at the start of a connection.
- Channels will silently stop working if data is not sent at regular intervals,
    forcing the application to have heartbeats going in both directions.

All of these issues is too much complexity to leave to application developers, so
we provide an abstraction that aims to solve all of the above issues. The biggest
downside of this abstraction apart from the internal complexity it adds, is that we
will only support messaging in reliable and ordered mode.

The abstraction should provide the following:
  - All channels opened at connection time, one main channel and a number or transfer channels.
  - Transfer channels are used to transfer large (> 4096 byte) objects.
  - Latency of small messages need to be kept low by separating them from large transfers.
  - Large messages are transparently broken down and reconstructed.
  - Support for sending object as JSON with support for serialization of some data types.
  - Should at least support serialization of ArrayBuffers, typed arrays, Blobs.
  - Message sending is throttled to maximize throughput without disconnecting channels.
  - Application needs to be aware of the throttling to avoid back pressure.
  - Replacing the RTCPeerConnection should result in a channel disconnect and reconnect.
  - Channels are kept alive with heartbeats.
  - Channel RTT is measured as part of the heartbeats.
  - The API should be similar to the existing data channel API, but with the above features.

Here's a diagram of the internal API design:

    DataChannelMultiplexer ---> N x MuxedDataChannel
      1 x |     1 x |
          |         v
          |   PriorityChannelSender // main channel sender
          |     1 x |
          |         v
          |   RTCDataChannel // main channel
          v
    TransferChannelController ---> N x TransferItem, N x TransferAssembler
      N x |
          v
    PriorityChannelSender // transfer channel senders
      1 x |
          v
    RTCDataChannel // transfer channels

The DataChannelMultiplexer is responsible for the main channel messaging protocol
and message serialization. It will split out large chunks of data and hand them
off to the transfer manager.

MuxedDataChannel is the public API to be used by the application. They work a lot
like normal WebRTC DataChannels, but with the improvements mentioned above.

The TransferChannelController is responsible for the transfer message protocol, but
not the data serialization.

TransferItem and TransferAssembler are responsible for serializing and deserializing
transfers.

PriorityChannelSender makes sure data is not sent too quickly, but also makes it
possible to manage back-pressure to avoid large send queues and delays.

RTCDataChannel are the regular built-in WebRTC DataChannels. They are set up at
connection time using pre-negotiated ids and always run in reliable and ordered mode.

Pausing:

The concept of pausing the datamux had to be added because of how the
conference API works. A connection to a peer in a conference may be
in the state where the connection is up, but the peer or oneself is
not a member of the raft configuration. We refer to that state as paused,
since we want to keep the connection around and resume it once we're both
a member of the raft configuration.

In the paused state, the RtcComponent API will report the peer as
disconnected, and it should not be possible to open channels to that peer.
Furthermore, any channels that have been opened and messages that have
been sent should all be cleared. Although we still want to keep the builtin
channels around.

We make one important assumption from the conference/raft abstraction layer
in our implementation: pauses are always symmetrical, i.e. if we are
paused, the peer will also be paused once, or we are disconnected.

With the above assumption the signaling becomes significantly simpler,
since it's enough that we close our own channels, and then send information
about what channels we closed to the peer.

We signal the channels we close by sending the next ID in our channel id
counter. Any channels below that ID are the ones we closed, except for
builtin ones. The peer sets this as the new minimum channel ID, and if
any messages are received for channels lower than that ID, they are ignored.

Closing namespace:

Being able to close all channels in a channel had to be added because it's possible
to detach an RtcComponent, which should lead to the channels being closed on both ends.

When closing a namespace, all channels and pairing infos are removed and moved
to the close state. This is only done locally, which means that the signaling in the
attachment manager is relied upon for making sure the same channels are closed on the
remote side.

Removing transfer channels:

Earlier implementations used transfer channels for transmitting large chunks of data.
It was also possible to have multiple transfer channels, with the transfers spread
out across them. However, testing showed that the fewer channels you use, the more
reliable the connection will be. The most critical issue is that sent data is not
properly distributed across all channels. One channel would frequently be the only one
transmitting data, while the other ones waited, breaking pinging on the other channels.
This was especially frequent on low-throughput networks.

The pros of using transfer channels apart from hoping to be able to maintain a higher
throughput, was that the send queue implementation and protocol was simpler. Now we have
to keep track of individual data chunks, since they will be interleaved with smaller messages.

*/

// Maximum size for high-priority messages. If they are
// largeer they will be put in the low-priority queue.
var HIGH_PRIORITY_MTU = 4096;

var CONNECT_TIMEOUT_MS = 10000;

var CHANNEL_BASE_ID = 20; // The negotiated RtcDataChannel id

var TRANSFER_PLACEHOLDER_PREFIX = '__c3_t';

var STATE_CONNECTED = 'connected';
var STATE_CONNECTING = 'connecting';
var STATE_DISCONNECTED = 'disconnected';

var DataChannelMultiplexer = function () {
  function DataChannelMultiplexer() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_classCallCheck___default()(this, DataChannelMultiplexer);

    var onChannel = options.onChannel,
        onConnect = options.onConnect,
        onDisconnect = options.onDisconnect,
        onRttChange = options.onRttChange,
        onUpStateChange = options.onUpStateChange,
        targetKbps = options.targetKbps,
        transferEncoding = options.transferEncoding,
        _options$disablePingi = options.disablePinging,
        disablePinging = _options$disablePingi === undefined ? false : _options$disablePingi,
        _options$connectTimeo = options.connectTimeoutMs,
        connectTimeoutMs = _options$connectTimeo === undefined ? CONNECT_TIMEOUT_MS : _options$connectTimeo;


    this._onMessage = this._onMessage.bind(this);
    this._onConnectTimeout = this._onConnectTimeout.bind(this);

    this._onChannel = onChannel;
    this._onConnectCallback = onConnect;
    this._onDisconnectCallback = onDisconnect;
    this._onRttChangeCallback = onRttChange;
    this._onUpStateChangeCallback = onUpStateChange;

    this._channel = null;
    this._transferReceiver = new __WEBPACK_IMPORTED_MODULE_18_datamux_transfer__["a" /* TransferReceiver */]();
    this._transferIdCounter = 1;
    this._connectionState = STATE_DISCONNECTED;
    this._connectTimeoutId = null;
    this._disablePinging = disablePinging;
    this._onConnectTimeoutMs = connectTimeoutMs;

    if (!transferEncoding) {
      if (isWebRtcPlugin) {
        transferEncoding = 'base64';
      } else {
        transferEncoding = 'binary';
      }
    }

    if (!targetKbps) {
      if (isWebRtcPlugin) {
        targetKbps = 400;
      } else {
        targetKbps = Infinity;
      }
    }

    this._activityTracker = new __WEBPACK_IMPORTED_MODULE_15_datamux_activityTracker__["a" /* default */]();
    this._sendBuffer = new __WEBPACK_IMPORTED_MODULE_17_datamux_buffers__["a" /* PrioritizedBuffer */]();
    this._channelController = new __WEBPACK_IMPORTED_MODULE_12_datamux_channelController__["a" /* default */]({
      buffer: this._sendBuffer,
      channelDriver: new __WEBPACK_IMPORTED_MODULE_11_datamux_channelDriver__["a" /* default */](),
      activityTracker: this._activityTracker,
      bandwidthEstimator: new __WEBPACK_IMPORTED_MODULE_16_datamux_bandwidthEstimation__["a" /* BandwidthEstimator */]({
        initialTargetKbps: targetKbps
      }),
      transferEncoding: transferEncoding
    });

    // This is used to figure out if Temasys are randomly
    // sending us old events or not.
    // It is incremented when removing listeners, and then we
    // only handle events that match the current epoch.
    this._eventEpoch = 1;

    this._channelRegistry = new __WEBPACK_IMPORTED_MODULE_13_datamux_registry__["a" /* default */]();
    // These are channels that we have received an open message for while
    // we were paused, so we wait for a resume before we open them.
    this._pendingRemoteChannels = new __WEBPACK_IMPORTED_MODULE_5_babel_runtime_core_js_map___default.a();

    // Builtin channels can only be created synchronously after instantiation
    // and before other channel types
    this._builtinsLocked = false;
    __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default.a.reject().catch(function () {
      _this._builtinsLocked = true;
    });
  }

  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_createClass___default()(DataChannelMultiplexer, [{
    key: 'createDataChannels',
    value: function createDataChannels(dataChannelFactory) {
      this.reset();
      this._builtinsLocked = true;
      this._connectionState = STATE_CONNECTING;

      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].info(TAG, this, 'creating RTCDataChannels');

      this._channel = dataChannelFactory('datamux', {
        ordered: true,
        reliable: true,
        negotiated: true,
        protocol: 'c3.datamux',
        id: CHANNEL_BASE_ID
      });

      // binaryType must be set early for mocked channels
      this._channel.binaryType = 'arraybuffer';
      this._channel.onopen = this._onChannelOpened.bind(this, this._eventEpoch);
      this._channel.onclose = this._onChannelClosed.bind(this, this._eventEpoch);
      this._channel.onerror = this._onChannelError.bind(this, this._eventEpoch);

      // Mainly for mocked tests, but who knows, maybe this can
      // happen in the wild as well?
      if (this._channel.readyState === 'open') {
        this._onChannelOpened(this._eventEpoch);
      }

      this._connectTimeoutId = setTimeout(this._onConnectTimeout, this._onConnectTimeoutMs);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'channelMuxer{state=' + this._connectionState + ',' + this._channelController + ',' + this._channelRegistry + '}';
    }
  }, {
    key: 'setPausedState',


    /**
     * Pauses the datamux. This will close or disconnect all non-builtin
     * mux channels and clear all send and receive buffers. It will not
     * touch the underlying connection however, and the datamux may be
     * resumed at a later time.
     *
     * The paused state takes presedence over the connected state, i.e. if the
     * underlying connection is disconnected and a new one is opened, the datamux
     * will still remain in paused state.
     *
     * @param {boolean} isPaused - Whether or not the datamux is paused.
     */
    value: function setPausedState(isPaused) {
      var _this2 = this;

      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].boolean('datamux.setPausedState', 'isPaused', isPaused);
      if (this._paused === isPaused) {
        return;
      }
      this._paused = isPaused;

      if (this._connectionState !== STATE_CONNECTED) {
        return;
      }

      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].info(TAG, this, isPaused ? 'paused' : 'resumed');

      if (isPaused) {
        var nextId = this._channelRegistry.clearAppConnections();
        this._sendBuffer.pushMessage(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["a" /* MT_CLEAR */] + nextId);
      } else {
        this._pendingRemoteChannels.forEach(function (channel, remoteId) {
          _this2._openChannel(remoteId, channel);
        });
      }
      this._pendingRemoteChannels.clear();
    }
  }, {
    key: 'cleanup',
    value: function cleanup() {
      this.reset();
      this._channelRegistry.cleanup();
      this._channelRegistry = null;
      this._pendingRemoteChannels = null;
      this._transferReceiver = null;
      this._activityTracker = null;
      this._channelController = null;
      this._sendBuffer = null;
    }
  }, {
    key: 'reset',
    value: function reset() {
      if (this._connectTimeoutId) {
        clearTimeout(this._connectTimeoutId);
        this._connectTimeoutId = null;
      }
      this._connectionState = STATE_DISCONNECTED;
      this._channelRegistry.clearConnections();
      this._pendingRemoteChannels.clear();
      this._transferReceiver.clear();
      this._transferIdCounter = 1;
      if (this._channelController.running) {
        this._channelController.stop();
      }
      if (this._activityTracker.running) {
        this._activityTracker.stop();
      }
      this._eventEpoch += 1;

      if (this._channel) {
        this._channel.onopen = null;
        this._channel.onclose = null;
        this._channel.onerror = null;
        try {
          var readyState = this._channel.readyState;

          if (readyState !== 'closed' && readyState !== 'closing') {
            this._channel.close();
          }
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].warning(TAG, 'failed to close channel, ' + error);
        }
        this._channel = null;
      }
    }
  }, {
    key: '_onConnected',
    value: function _onConnected() {
      var _this3 = this;

      this._connectionState = STATE_CONNECTED;

      clearTimeout(this._connectTimeoutId);
      this._connectTimeoutId = null;

      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].info(TAG, this, 'connected');
      this._channelController.start({
        channel: this._channel,
        onMessage: this._onMessage,
        onRttChange: this._onRttChangeCallback,
        disablePinging: this._disablePinging
      });
      this._activityTracker.start({
        onActiveStateChange: this._onUpStateChangeCallback,
        onDisconnect: function onDisconnect() {
          return _this3._onChannelTimeout(_this3._channel);
        }
      });
      this._transferReceiver.clear();
      this._transferIdCounter = 1;

      this._channelRegistry.connectBuiltins();
      this._channelRegistry.forEachLocalChannel(function (channel) {
        var initMessage = _this3._createChannelInitMessage(channel);
        _this3._sendBuffer.pushMessage(initMessage);
        __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, _this3, 'sent init message, ' + initMessage);
      });

      this._onConnectCallback && this._onConnectCallback();
    }
  }, {
    key: '_onDisconnected',
    value: function _onDisconnected(reason) {
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'disconnected because of ' + reason);
      var alreadyDisconnected = this._connectionState === STATE_DISCONNECTED;
      this.reset();
      if (!alreadyDisconnected) {
        this._onDisconnectCallback && this._onDisconnectCallback(reason);
      }
    }
  }, {
    key: '_onChannelOpened',
    value: function _onChannelOpened(epoch) {
      if (epoch !== this._eventEpoch) {
        return;
      }
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].info(TAG, this, 'channel \'' + this._channel.label + '\' opened');
      this._onConnected();
    }
  }, {
    key: '_onChannelClosed',
    value: function _onChannelClosed(epoch) {
      if (epoch !== this._eventEpoch) {
        return;
      }
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].info(TAG, this, 'channel \'' + this._channel.label + '\' closed');
      this._onDisconnected('closed');
    }
  }, {
    key: '_onChannelTimeout',
    value: function _onChannelTimeout() {
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].info(TAG, this, 'channel \'' + this._channel.label + '\' communication timed out');
      this._onDisconnected('channelTimeout');
    }
  }, {
    key: '_onChannelError',
    value: function _onChannelError(epoch, error) {
      if (epoch !== this._eventEpoch) {
        return;
      }
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].error(TAG, this, 'channel \'' + this._channel.label + '\' received error, ' + error);
      this._onDisconnected('channelError');
    }
  }, {
    key: '_onConnectTimeout',
    value: function _onConnectTimeout() {
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].info(TAG, this, 'timeout out while trying to connect channels');
      this._onDisconnected('connectTimeout');
    }
  }, {
    key: 'createChannel',
    value: function createChannel(config) {
      __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].options('DataChannel constructor', 'config', config).string('label').optString('protocol').optString('namespaceId').optString('pairingId').optBoolean('builtin');

      if (this._paused) {
        throw new Error('may not create channels while connection is paused');
      }

      var label = config.label,
          protocol = config.protocol,
          namespaceId = config.namespaceId,
          pairingId = config.pairingId,
          builtin = config.builtin;

      protocol = protocol || '';
      namespaceId = namespaceId || '';

      if (!builtin && this._connectionState !== STATE_CONNECTED) {
        throw new Error('must be connected to create channels');
      }

      this._channelRegistry.validateConfig({ label: label, protocol: protocol, namespaceId: namespaceId, pairingId: pairingId, builtin: builtin });

      var localId = this._channelRegistry.getNextId();
      var channel = new __WEBPACK_IMPORTED_MODULE_14_datamux_channel__["a" /* default */]({
        isLocal: true,
        localId: localId,
        label: label,
        protocol: protocol,
        namespaceId: namespaceId,
        pairingId: pairingId,
        builtin: builtin,
        onMessage: this._forwardMuxChannelMessage.bind(this, localId),
        onClose: this._onLocalMuxChannelClosed.bind(this, localId)
      });
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'created ' + (builtin ? 'buildin ' : '') + 'channel ' + channel);

      if (builtin) {
        if (this._builtinsLocked) {
          throw new Error('builtin channels can only be created internally up instantiation');
        }
        this._channelRegistry.addBuiltin(channel);
      } else {
        this._builtinsLocked = true;

        this._channelRegistry.addLocal(channel);

        if (this._connectionState === STATE_CONNECTED) {
          var initMessage = this._createChannelInitMessage(channel);
          this._sendBuffer.pushMessage(initMessage);
          __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'sent init message, ' + initMessage);
        }
      }

      return channel;
    }
  }, {
    key: 'closeChannelsInNamespace',
    value: function closeChannelsInNamespace(namespaceId) {
      this._channelRegistry.clearNamespace(namespaceId);
    }
  }, {
    key: '_createChannelInitMessage',
    value: function _createChannelInitMessage(channel) {
      var messageType = __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["b" /* MT_OPEN */];
      var params = [channel._label, channel._protocol, channel._namespaceId];
      if (channel._pairingId) {
        messageType = __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["c" /* MT_DECLARE */];
        params.push(channel._pairingId);
      }
      var paramStr = params.map(function (param) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["utf8ToUrlSafeBase64"])(param);
      }).join(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["d" /* M_SEP */]);
      return messageType + channel._localId.toString(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]) + __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["d" /* M_SEP */] + paramStr;
    }

    // Returns [transferId, transferPromise] if the value had to be
    // transferred, otherwise return undefined.
    // Transfers are a more advanced way of sending data that doesn't
    // fit into a message.
    // When transferring a value, it's converted into a TransferItem,
    // and the receiving end uses a TransferAssembler to reassemble
    // the value.

  }, {
    key: '_maybeTransferValue',
    value: function _maybeTransferValue(value) {
      var _this4 = this;

      if (!__WEBPACK_IMPORTED_MODULE_18_datamux_transfer__["b" /* TransferItem */].supportsType(value)) {
        return;
      }

      var transferId = this._transferIdCounter;
      this._transferIdCounter += 1;

      var transferPromise = __WEBPACK_IMPORTED_MODULE_18_datamux_transfer__["b" /* TransferItem */].createFromData(value).then(function (transferItem) {
        var transferHeader = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_18_datamux_transfer__["c" /* createTransferHeader */])({ transferId: transferId, transferItem: transferItem });

        _this4._sendBuffer.pushTransfer(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["f" /* MT_TRANSFER_HEADER */] + transferHeader);
        _this4._sendBuffer.pushTransfer(transferItem);

        return transferItem.promise;
      });

      return [transferId, transferPromise];
    }
  }, {
    key: '_forwardMuxChannelMessage',
    value: function _forwardMuxChannelMessage(localId, message) {
      var _this5 = this;

      if (this._connectionState !== STATE_CONNECTED) {
        throw new Error('tried to forward message when datamux was not connected');
      }

      // Here we stringify the message and replace all binary values with transfer placeholders.
      // The result will always be a JSON encoded string, so if we're sending a binary blob,
      // we will get a JSON encoded placeholder string back, e.g. "__c3_t5", including quotes.
      var transferPromises = [];
      var data = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_json_stringify___default()(message, function (key, value) {
        if ((typeof value === 'undefined' ? 'undefined' : __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_typeof___default()(value)) !== 'object' || value === null) {
          return value;
        }
        var transferResult = _this5._maybeTransferValue(value);
        if (transferResult) {
          var _transferResult = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(transferResult, 2),
              transferId = _transferResult[0],
              transferPromise = _transferResult[1];

          transferPromises.push(transferPromise);
          return TRANSFER_PLACEHOLDER_PREFIX + transferId.toString(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]);
        } else {
          return value;
        }
      });

      // If the resulting JSON encoded string is too long, we will send it as a transfer instead.
      // The message will be replaced by a transfer placeholder string, this time without quotes.
      if (data.length > HIGH_PRIORITY_MTU) {
        var _maybeTransferValue2 = this._maybeTransferValue(data),
            _maybeTransferValue3 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_maybeTransferValue2, 2),
            transferId = _maybeTransferValue3[0],
            transferPromise = _maybeTransferValue3[1];

        transferPromises.push(transferPromise);
        data = TRANSFER_PLACEHOLDER_PREFIX + transferId.toString(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]);
      }

      this._sendBuffer.pushMessage(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["g" /* MT_DATA */] + localId.toString(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]) + __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["d" /* M_SEP */] + data);
      return __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default.a.all(transferPromises);
    }
  }, {
    key: '_onLocalMuxChannelClosed',
    value: function _onLocalMuxChannelClosed(localId, channel) {
      this._channelRegistry.remove(channel);
      if (this._connectionState === STATE_CONNECTED) {
        this._sendBuffer.pushMessage(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["h" /* MT_CLOSE */] + localId.toString(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]));
      }
    }
  }, {
    key: '_onMessage',
    value: function _onMessage(data) {
      if (typeof data !== 'string') {
        return this._transferReceiver.handleBinaryData(data);
      }

      var messageType = data[0];
      var message = data.slice(1);

      // Handle message types without remote channel id prefix
      switch (messageType) {
        case __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["f" /* MT_TRANSFER_HEADER */]:
          return this._transferReceiver.setHeader(message);
      }

      // All other message types are prefixed with a remote channel id
      var sepIndex = data.indexOf(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["d" /* M_SEP */]);
      var channelIdStr = data.slice(1, sepIndex < 0 ? undefined : sepIndex);
      var remoteId = parseInt(channelIdStr, __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]);
      var body = data.slice(sepIndex + __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["d" /* M_SEP */].length);

      var isInteger = (remoteId | 0) === remoteId;
      var isPositive = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_math_sign___default()(remoteId) === 1;
      if (!isInteger || !isPositive) {
        __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].error(TAG, 'received message with invalid channel id, \'' + channelIdStr + '\'');
        return;
      }

      switch (messageType) {
        case __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["g" /* MT_DATA */]:
          return this._handleDataMessage(remoteId, body);
        case __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["b" /* MT_OPEN */]:
          return this._handleOpenMessage(remoteId, body);
        case __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["i" /* MT_OPEN_ACK */]:
          return this._handleOpenAckMessage(remoteId, body);
        case __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["h" /* MT_CLOSE */]:
          return this._handleCloseMessage(remoteId, body);
        case __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["c" /* MT_DECLARE */]:
          return this._handleDeclareMessage(remoteId, body);
        case __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["a" /* MT_CLEAR */]:
          return this._handleClearMessage(remoteId);
        default:
          __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].warning(TAG, 'received message with unknown type, \'' + messageType + '\'');
      }
    }
  }, {
    key: '_handleDataMessage',
    value: function _handleDataMessage(remoteId, data) {
      var _this6 = this;

      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].verbose(TAG, this, 'received data message with remote id ' + remoteId);
      var channel = this._channelRegistry.getByRemoteId(remoteId);
      if (!channel) {
        __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, 'got message for unknown channel, ' + remoteId);
        return;
      }
      if (this._paused && !channel._builtin) {
        __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].verbose(TAG, this, 'ignored data message for app channel while paused');
        return;
      }

      var messagePromise;

      // Check if we've received a plain transfer placeholder, i.e. a placeholder for the
      // JSON encoded string of the message.
      if (data.indexOf(TRANSFER_PLACEHOLDER_PREFIX) === 0) {
        var transferId = parseInt(data.slice(TRANSFER_PLACEHOLDER_PREFIX.length), __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]);
        messagePromise = this._transferReceiver.awaitDownload(transferId).then(function (result) {
          // Now that we have received the JSON message we can parse it as usual.
          return _this6._parseDataMessageJson(result);
        });
      } else {
        messagePromise = this._parseDataMessageJson(data);
      }

      channel._handleRecievedMessagePromise(messagePromise);
    }
  }, {
    key: '_parseDataMessageJson',
    value: function _parseDataMessageJson(data) {
      var _this7 = this;

      // used to look up the transfer result in the array of promise results
      var transferIndices = {};
      var transferPromises = [];
      // Start off by deserializing and check if we encounter any transfer placeholders
      var message = JSON.parse(data, function (key, value) {
        if (typeof value === 'string' && value.indexOf(TRANSFER_PLACEHOLDER_PREFIX) === 0) {
          var transferId = parseInt(value.slice(TRANSFER_PLACEHOLDER_PREFIX.length), __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]);
          var promise = _this7._transferReceiver.awaitDownload(transferId);
          transferIndices[transferId] = transferPromises.length;
          transferPromises.push(promise);
        } else {
          return value;
        }
      });

      if (transferPromises.length === 0) {
        return __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default.a.resolve(message); // skip second parse if we didn't have any transfers
      } else {
        return __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_promise___default.a.all(transferPromises).then(function (results) {
          // Deserialize again, this time with synchronous access to all transfer results
          return JSON.parse(data, function (key, value) {
            if (typeof value === 'string' && value.indexOf(TRANSFER_PLACEHOLDER_PREFIX) === 0) {
              var transferId = parseInt(value.slice(TRANSFER_PLACEHOLDER_PREFIX.length), __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]);
              var index = transferIndices[transferId];
              return results[index];
            } else {
              return value;
            }
          });
        });
      }
    }
  }, {
    key: '_handleOpenMessage',
    value: function _handleOpenMessage(remoteId, data) {
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'received open message with remote id ' + remoteId + ', ' + data);

      var _data$split = data.split(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["d" /* M_SEP */]),
          _data$split2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_data$split, 3),
          base64Label = _data$split2[0],
          base64Protocol = _data$split2[1],
          base64NamespaceId = _data$split2[2];

      var existingChannel = this._channelRegistry.getByRemoteId(remoteId);
      var label = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["urlSafeBase64ToUtf8"])(base64Label);
      var protocol = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["urlSafeBase64ToUtf8"])(base64Protocol);
      var namespaceId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["urlSafeBase64ToUtf8"])(base64NamespaceId);
      if (existingChannel) {
        __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, 'got second open with label \'' + label + '\', protocol \'' + protocol + '\'' + (', and namespaceId \'' + namespaceId + '\' for existing channel: ' + existingChannel));
        return;
      }

      var localId = this._channelRegistry.getNextId();
      var channel = new __WEBPACK_IMPORTED_MODULE_14_datamux_channel__["a" /* default */]({
        localId: localId,
        label: label,
        protocol: protocol,
        namespaceId: namespaceId,
        onMessage: this._forwardMuxChannelMessage.bind(this, localId),
        onClose: this._onLocalMuxChannelClosed.bind(this, localId)
      });

      if (this._paused) {
        this._pendingRemoteChannels.set(remoteId, channel);
      } else {
        this._openChannel(remoteId, channel);
      }
    }
  }, {
    key: '_openChannel',
    value: function _openChannel(remoteId, channel) {
      this._channelRegistry.addRemote({ channel: channel, remoteId: remoteId });
      this._sendBuffer.pushMessage(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["i" /* MT_OPEN_ACK */] + channel._localId.toString(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]) + __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["d" /* M_SEP */] + remoteId.toString(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]));
      this._onChannel && this._onChannel(channel);
    }
  }, {
    key: '_handleOpenAckMessage',
    value: function _handleOpenAckMessage(remoteId, data) {
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'received open ack message with remote id ' + remoteId + ', ' + data);
      var localId = parseInt(data, __WEBPACK_IMPORTED_MODULE_19_datamux_constants__["e" /* ID_BASE */]);
      this._channelRegistry.link({ localId: localId, remoteId: remoteId });
    }
  }, {
    key: '_handleCloseMessage',
    value: function _handleCloseMessage(remoteId) {
      var channel = this._channelRegistry.getByRemoteId(remoteId);
      if (channel) {
        if (channel._pairingId) {
          __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].warning(TAG, this, 'got close message for paired channel \'' + this + '\'');
        } else {
          __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'received close message with remote id ' + remoteId);
        }
        this._channelRegistry.remove(channel);
        channel._close();
      } else {
        __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].warning(TAG, this, 'got close message for unknown channel ' + remoteId);
      }
    }
  }, {
    key: '_handleDeclareMessage',
    value: function _handleDeclareMessage(remoteId, data) {
      __WEBPACK_IMPORTED_MODULE_8_common_log__["default"].debug(TAG, this, 'received declare message with remote id ' + remoteId + ', ' + data);

      var _data$split3 = data.split(__WEBPACK_IMPORTED_MODULE_19_datamux_constants__["d" /* M_SEP */]),
          _data$split4 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_slicedToArray___default()(_data$split3, 4),
          base64Label = _data$split4[0],
          base64Protocol = _data$split4[1],
          base64NamespaceId = _data$split4[2],
          base64PairingId = _data$split4[3];

      var label = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["urlSafeBase64ToUtf8"])(base64Label);
      var protocol = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["urlSafeBase64ToUtf8"])(base64Protocol);
      var namespaceId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["urlSafeBase64ToUtf8"])(base64NamespaceId);
      var pairingId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["urlSafeBase64ToUtf8"])(base64PairingId);

      this._channelRegistry.addPairingInfo({
        remoteId: remoteId,
        label: label,
        protocol: protocol,
        namespaceId: namespaceId,
        pairingId: pairingId
      });
    }
  }, {
    key: '_handleClearMessage',
    value: function _handleClearMessage(minimumRemoteId) {
      var _this8 = this;

      this._channelRegistry.setMinimumRemoteId(minimumRemoteId);

      this._pendingRemoteChannels.forEach(function (channel, remoteId) {
        if (remoteId < minimumRemoteId) {
          _this8._pendingRemoteChannels.delete(remoteId);
        }
      });
    }
  }, {
    key: 'up',
    get: function get() {
      return this._activityTracker.active;
    }
  }, {
    key: 'rttMs',
    get: function get() {
      return this._channelController.rttMs;
    }
  }, {
    key: 'connectionState',
    get: function get() {
      return this._connectionState;
    }
  }]);

  return DataChannelMultiplexer;
}();

/* harmony default export */ __webpack_exports__["a"] = (DataChannelMultiplexer);

/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TransferItem; });
/* unused harmony export TransferAssembler */
/* harmony export (immutable) */ __webpack_exports__["c"] = createTransferHeader;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TransferReceiver; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toArray__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_webrtc_errors__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_datamux_constants__ = __webpack_require__(182);


// This module contains classes and utils for transferring
// large chunks of data.
// The data along with it's type is read into a TranferItem,
// which is then read and split into chunks for sending.
// A TransferAssembler is used to reassemble the TransferItem,
// including the original type.














var TI_TYPE_BLOB = 'b';
var TI_TYPE_STRING = 's';
var TI_TYPE_ARRAY_BUFFER = 'a';
var TI_TYPE_BUFFER_VIEW = 't';

var TI_TYPE_SEP = '.';

var TI_VIEW_TYPE_DATA_VIEW = 'dv';
var TI_VIEW_TYPE_INT8 = 'i8';
var TI_VIEW_TYPE_UINT8 = 'u8';
var TI_VIEW_TYPE_UINT8_CLAMPED = 'u8c';
var TI_VIEW_TYPE_INT16 = 'i16';
var TI_VIEW_TYPE_UINT16 = 'u16';
var TI_VIEW_TYPE_INT32 = 'i32';
var TI_VIEW_TYPE_UINT32 = 'u32';
var TI_VIEW_TYPE_FLOAT32 = 'f32';
var TI_VIEW_TYPE_FLOAT64 = 'f64';

var TI_VIEW_TYPES = [[DataView, TI_VIEW_TYPE_DATA_VIEW], [Int8Array, TI_VIEW_TYPE_INT8], [Uint8Array, TI_VIEW_TYPE_UINT8], [Uint8ClampedArray, TI_VIEW_TYPE_UINT8_CLAMPED], [Int16Array, TI_VIEW_TYPE_INT16], [Uint16Array, TI_VIEW_TYPE_UINT16], [Int32Array, TI_VIEW_TYPE_INT32], [Uint32Array, TI_VIEW_TYPE_UINT32], [Float32Array, TI_VIEW_TYPE_FLOAT32], [Float64Array, TI_VIEW_TYPE_FLOAT64]];
var TI_VIEW_TYPE_MAP = TI_VIEW_TYPES.reduce(function (map, _ref) {
  var _ref2 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_ref, 2),
      TypeConstructor = _ref2[0],
      viewType = _ref2[1];

  map[viewType] = TypeConstructor;
  return map;
}, {});

var TAG = 'datamux';

/**
 * An internal class that is used to represent typed data serialized into ArrayBuffers.
 *
 * The bulk of the work is done in {@link TransferItem.createFromData}, which serializes
 * and splits data of any of the supported types and creates a new {@link TransferItem} instance.
 */
var TransferItem = function () {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(TransferItem, null, [{
    key: 'supportsType',
    value: function supportsType(data) {
      if (data instanceof ArrayBuffer) {
        return true;
      } else if (data && data.buffer instanceof ArrayBuffer) {
        var viewType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["find"])(TI_VIEW_TYPES, function (_ref3) {
          var _ref4 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_ref3, 1),
              TypeConstructor = _ref4[0];

          return data instanceof TypeConstructor;
        });
        return !!viewType;
      } else if (typeof data === 'string') {
        return true;
      } else if (!false && data instanceof Blob) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'createFromData',
    value: function createFromData(data) {
      if (data instanceof ArrayBuffer) {
        return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a.resolve(new TransferItem({
          typeDescriptor: TI_TYPE_ARRAY_BUFFER,
          data: data
        }));
      } else if (data && data.buffer instanceof ArrayBuffer) {
        var viewType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["find"])(TI_VIEW_TYPES, function (_ref5) {
          var _ref6 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_ref5, 1),
              TypeConstructor = _ref6[0];

          return data instanceof TypeConstructor;
        });
        if (viewType) {
          viewType = viewType[1]; // unpack the id from the entry
        } else {
          throw new TypeError('Could not serialize unsupported buffer view type: \'' + data + '\'');
        }

        return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a.resolve(new TransferItem({
          typeDescriptor: TI_TYPE_BUFFER_VIEW + TI_TYPE_SEP + viewType,
          data: data
        }));
      } else if (typeof data === 'string') {
        var buffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["unicodeStringToArrayBuffer"])(data);
        return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a.resolve(new TransferItem({
          typeDescriptor: TI_TYPE_STRING,
          data: buffer
        }));
      } else if (!false && data instanceof Blob) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["blobToArrayBuffer"])(data).then(function (buffer) {
          var base64Type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["utf8ToUrlSafeBase64"])(data.type || '');
          var base64Name = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["utf8ToUrlSafeBase64"])(data.name || '');
          return __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_promise___default.a.resolve(new TransferItem({
            typeDescriptor: TI_TYPE_BLOB + TI_TYPE_SEP + base64Type + TI_TYPE_SEP + base64Name,
            data: buffer
          }));
        });
      } else {
        throw new TypeError('Could not serialize unsupported data type: \'' + data + '\'');
      }
    }
  }]);

  function TransferItem(_ref7) {
    var typeDescriptor = _ref7.typeDescriptor,
        data = _ref7.data,
        chunkSize = _ref7.chunkSize;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, TransferItem);

    // Instead of using .subarray() for views, we use the same code for buffers and
    // views, and then create new typed arrays while keeping track of the offset.
    if (ArrayBuffer.isView(data)) {
      this._buffer = data.buffer;
      this._baseOffset = data.byteOffset;
    } else {
      this._buffer = data;
      this._baseOffset = 0;
    }
    this._byteOffset = 0;
    this._byteLength = data.byteLength;

    this._typeDescriptor = typeDescriptor;

    this._deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["defer"])();
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(TransferItem, [{
    key: 'toString',
    value: function toString() {
      return 'transferItem{' + this._byteOffset + '/' + this._byteLength + ',type=' + this._typeDescriptor + '}';
    }

    /**
     * A string that describes the type of the serialized data using
     * custom format. e.g. 's' for string, or 't.u8' for an Uint8Array.
     *
     * @readonly
     * @member {string} TransferItem#typeDescriptor
     */

  }, {
    key: 'read',


    /**
     * Reads a single chunk. This will remove the chunk from the internal store.
     *
     * Throws an error if there are no chunks left to be read.
     *
     * @param {number} size - The maximum number of bytes to read.
     * @returns {Uint8Array?} A serialized chunk of data, or null if there are no chunks left.
     */
    value: function read() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;

      var bytesLeft = this._byteLength - this._byteOffset;
      if (bytesLeft > 0) {
        var offset = this._byteOffset;
        if (size > bytesLeft) {
          size = bytesLeft;
        }
        this._byteOffset += size;

        if (this.empty) {
          this._deferred.resolve();
        }

        return new Uint8Array(this._buffer, this._baseOffset + offset, size);
      } else {
        return null;
      }
    }

    /**
     * Reads a single chunk. This will remove the chunk from the internal store.
     * The result is a base64 encoded. The input size takes the encoding into
     * account, as in the internal read size will be smaller than the given size.
     *
     * Throws an error if there are no chunks left to be read.
     *
     * @param {number} size - The maximum number of bytes to read.
     * @returns {string?} A serialized and base64 encoded chunk of data, or null if there are no chunks left.
     */

  }, {
    key: 'readBase64',
    value: function readBase64() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;

      var decodedSize = Math.ceil(size * 2 / 3);

      var binaryData = this.read(decodedSize);
      if (binaryData) {
        var binaryStr = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["arrayBufferToBinaryString"])(binaryData);
        var binaryBase64Str = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["utf8ToBase64"])(binaryStr);
        return binaryBase64Str;
      } else {
        return null;
      }
    }

    /**
     * Signals that the transfer failed.
     */

  }, {
    key: 'failed',
    value: function failed() {
      this._deferred.reject(new __WEBPACK_IMPORTED_MODULE_8_webrtc_errors__["c" /* TransferInterruptedError */]('failed', this._byteOffset, this._byteLength));
      this._byteOffset = this._byteLength;
      this._buffer = null;
    }

    /**
     * Aborts an ongoing transfer by discarding the rest of the chunks and
     * rejecting the transfer promise.
     */

  }, {
    key: 'abort',
    value: function abort() {
      this._deferred.reject(new __WEBPACK_IMPORTED_MODULE_8_webrtc_errors__["c" /* TransferInterruptedError */]('interrupted', this._byteOffset, this._byteLength));
      this._byteOffset = this._byteLength;
      this._buffer = null;
    }
  }, {
    key: 'typeDescriptor',
    get: function get() {
      return this._typeDescriptor;
    }

    /**
     * The total length of the binary data in bytes.
     *
     * @readonly
     * @member {number} TransferItem#byteLength
     */

  }, {
    key: 'byteLength',
    get: function get() {
      return this._byteLength;
    }

    /**
     * A promise that will be resolved once all chunks have been read.
     *
     * @readonly
     * @member {Promise} TransferItem#promise
     */

  }, {
    key: 'promise',
    get: function get() {
      return this._deferred.promise;
    }

    /**
     * Whether there are any chunks left to read.
     *
     * @readonly
     * @member {boolean} TransferItem#empty
     */

  }, {
    key: 'empty',
    get: function get() {
      return this._byteOffset === this._byteLength;
    }
  }]);

  return TransferItem;
}();

/**
 * Given a byteLength and a typeDescriptor from a {@link TransferItem}, this class
 * reassembles the data from a number of received chunks.
 *
 * Each instance can only assemble a single transfer data item.
 */
var TransferAssembler = function () {
  function TransferAssembler(_ref8) {
    var byteLength = _ref8.byteLength,
        typeDescriptor = _ref8.typeDescriptor;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, TransferAssembler);

    this._byteLength = byteLength;
    this._typeDescriptor = typeDescriptor;

    this._offset = 0;
    this._buffer = new Uint8Array(byteLength);
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(TransferAssembler, [{
    key: 'toString',
    value: function toString() {
      return 'transferAssembler{type=' + this._typeDescriptor + ',size=' + this._byteLength + ',offset=' + this._offset + '}';
    }

    /**
     * Writes a chunk of serialized data.
     *
     * @param {Uint8Array} chunk - The chunk to be written.
     * @returns {boolean} True if all chunks have been written.
     */

  }, {
    key: 'write',
    value: function write(chunk) {
      if (chunk instanceof ArrayBuffer) {
        chunk = new Uint8Array(chunk);
      }
      this._buffer.set(chunk, this._offset);
      var chunkSize = chunk.byteLength || chunk.length;
      this._offset += chunkSize;
      if (isNaN(this._offset)) {
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'transfer assembler write position is NaN');
      }
      return this._byteLength === this._offset;
    }

    /**
     * Should be called once all chunks have been written.
     *
     * Will throw an error if all chunks haven't been written or if called more than once.
     *
     * @returns {*} Data deserialized from the chunks according to the typeDescriptor.
     */

  }, {
    key: 'finalize',
    value: function finalize() {
      if (this._byteLength === undefined) {
        throw new Error('Tried to finalize transfer a second time');
      }
      if (this._offset !== this._byteLength) {
        throw new Error('Tried to assemble transfer with offset != length, (' + this._offset + ' != ' + this._byteLength + ')');
      }

      var buffer = this._buffer;
      delete this._buffer;
      delete this._byteLength;

      var _typeDescriptor$split = this._typeDescriptor.split(TI_TYPE_SEP),
          _typeDescriptor$split2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_toArray___default()(_typeDescriptor$split),
          typeId = _typeDescriptor$split2[0],
          rest = _typeDescriptor$split2.slice(1);

      if (typeId === TI_TYPE_BLOB) {
        var _rest = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(rest, 2),
            base64Type = _rest[0],
            base64Name = _rest[1];

        var type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["urlSafeBase64ToUtf8"])(base64Type);
        var name = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["urlSafeBase64ToUtf8"])(base64Name);
        var blob = new Blob([buffer], { type: type });
        if (name) {
          blob.name = name;
        }
        return blob;
      } else if (typeId === TI_TYPE_STRING) {
        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["arrayBufferToUnicodeString"])(buffer.buffer);
      } else if (typeId === TI_TYPE_ARRAY_BUFFER) {
        return buffer.buffer;
      } else if (typeId === TI_TYPE_BUFFER_VIEW) {
        var _rest2 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(rest, 1),
            viewType = _rest2[0];

        var TypeConstructor = TI_VIEW_TYPE_MAP[viewType];
        if (!TypeConstructor) {
          throw new TypeError('Unknown view type in type descriptor: \'' + this._typeDescriptor + '\'');
        }
        return new TypeConstructor(buffer.buffer);
      } else {
        throw new TypeError('Unknown type id in type descriptor: \'' + this._typeDescriptor + '\'');
      }
    }
  }]);

  return TransferAssembler;
}();

function createTransferHeader(_ref9) {
  var transferId = _ref9.transferId,
      transferItem = _ref9.transferItem;

  return [transferId.toString(__WEBPACK_IMPORTED_MODULE_9_datamux_constants__["e" /* ID_BASE */]), transferItem.typeDescriptor, transferItem.byteLength.toString(__WEBPACK_IMPORTED_MODULE_9_datamux_constants__["e" /* ID_BASE */])].join(__WEBPACK_IMPORTED_MODULE_9_datamux_constants__["d" /* M_SEP */]);
}

var TransferReceiver = function () {
  function TransferReceiver() {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, TransferReceiver);

    this._assembler = null;
    this._currentTransferItem = null;
    this._currentDownloadId = null;
    this._deferredTransferResults = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(TransferReceiver, [{
    key: '_getDeferredResult',
    value: function _getDeferredResult(transferId) {
      var deferred = this._deferredTransferResults.get(transferId);
      if (deferred) {
        this._deferredTransferResults.delete(transferId);
      } else {
        deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["defer"])();
        this._deferredTransferResults.set(transferId, deferred);
      }
      return deferred;
    }
  }, {
    key: 'clear',
    value: function clear() {
      if (this._currentTransferItem) {
        // fine always calling this, since it will be resolved if it's done anyway
        this._currentTransferItem.abort();
        this._currentTransferItem = null;
      }
      this._deferredTransferResults.forEach(function (deferred) {
        deferred.reject(new Error('transfers cancelled due to reset'));
      });
      this._deferredTransferResults.clear();
    }

    // Returns a promise that is resolved when the download is complete

  }, {
    key: 'awaitDownload',
    value: function awaitDownload(transferId) {
      return this._getDeferredResult(transferId).promise;
    }
  }, {
    key: 'setHeader',
    value: function setHeader(headerString) {
      var _headerString$split = headerString.split(__WEBPACK_IMPORTED_MODULE_9_datamux_constants__["d" /* M_SEP */]),
          _headerString$split2 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_headerString$split, 3),
          transferIdStr = _headerString$split2[0],
          typeDescriptor = _headerString$split2[1],
          byteLengthStr = _headerString$split2[2];

      var transferId = parseInt(transferIdStr, __WEBPACK_IMPORTED_MODULE_9_datamux_constants__["e" /* ID_BASE */]);
      var byteLength = parseInt(byteLengthStr, __WEBPACK_IMPORTED_MODULE_9_datamux_constants__["e" /* ID_BASE */]);

      if (this._assembler) {
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'got new transfer header before assembling old transfer for ' + this._assembler);

        this._getDeferredResult(this._currentDownloadId).reject(new Error('ongoing transfer was unexpectedly replaced by a new one'));
      }
      this._assembler = new TransferAssembler({ typeDescriptor: typeDescriptor, byteLength: byteLength });
      this._currentDownloadId = transferId;
    }
  }, {
    key: 'handleBinaryData',
    value: function handleBinaryData(data) {
      var done = this._assembler.write(data);
      if (done) {
        var result = this._assembler.finalize();
        this._getDeferredResult(this._currentDownloadId).resolve(result);
        this._assembler = null;
        this._currentDownloadId = null;
      }
    }
  }]);

  return TransferReceiver;
}();

/***/ }),
/* 229 */,
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Candidate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_log__ = __webpack_require__(3);






var TAG = 'candidates';
var CANDIDATE_BUFFER_TIMEOUT_MS = 5;

var Candidate = function () {
  function Candidate(candidate) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Candidate);

    this.candidate = candidate.candidate;
    this.sdpMLineIndex = candidate.sdpMLineIndex;
    this.sdpMid = candidate.sdpMid;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(Candidate, [{
    key: 'toString',
    value: function toString() {
      return 'candidate{mId=' + this.sdpMid + ',mli=' + this.sdpMLineIndex + ',attr=' + this.candidate + '}';
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        candidate: this.candidate,
        sdpMLineIndex: this.sdpMLineIndex,
        sdpMid: this.sdpMid
      };
    }
  }]);

  return Candidate;
}();

var Candidater = function () {
  function Candidater(_ref) {
    var send = _ref.send;

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Candidater);

    this._send = send;

    this._peerConnection = null;
    this._earlyLocal = [];
    this._earlyRemote = [];
    this._localBuffer = [];
    this._localBufferTimeout = 0;

    this._onLocalCandidate = this._onLocalCandidate.bind(this);
    this._onBufferTimeout = this._onBufferTimeout.bind(this);
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(Candidater, [{
    key: 'setPeerConnection',
    value: function setPeerConnection(peerConnection) {
      this.reset();
      this._peerConnection = peerConnection;
      this._peerConnection.addEventListener('icecandidate', this._onLocalCandidate);
    }
  }, {
    key: 'handleRemoteCandidates',
    value: function handleRemoteCandidates(candidates) {
      var _this = this;

      if (!candidates) {
        return;
      }
      candidates = candidates.map(function (candidate) {
        return new Candidate(candidate);
      });

      if (!this._peerConnection) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].warning(TAG, 'got remote candidates without peer connection: ' + candidates.join(', '));
        return;
      }

      if (this._peerConnection.hasRemoteDescription) {
        candidates.forEach(function (candidate) {
          __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'adding remote candidate: ' + candidate);
          _this._peerConnection.addIceCandidate(candidate).catch(function (error) {
            __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'failed to add remote candidate: ' + error);
          });
        });
      } else {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'buffering early remote candidates: ' + candidates.join(', '));
        this._earlyRemote = this._earlyRemote.concat(candidates);
      }
    }
  }, {
    key: 'addEarlyRemoteCandidates',
    value: function addEarlyRemoteCandidates() {
      var _this2 = this;

      __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'adding early remote candidates: ' + this._earlyRemote.join(', '));

      this._earlyRemote.forEach(function (candidate) {
        _this2._peerConnection.addIceCandidate(candidate).catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'failed to add early remote candidate: ' + error);
        });
      });

      this._earlyRemote = [];
    }
  }, {
    key: 'extractEarlyLocal',
    value: function extractEarlyLocal() {
      if (!this._earlyLocal) {
        return [];
      }
      var earlyLocal = this._earlyLocal;
      this._earlyLocal = null;
      __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'extracted early local candidates: ' + earlyLocal.join(', '));
      return earlyLocal;
    }
  }, {
    key: 'reset',
    value: function reset() {
      if (this._localBufferTimeout) {
        clearTimeout(this._localBufferTimeout);
        this._localBufferTimeout = 0;
      }
      if (this._peerConnection) {
        this._peerConnection.removeEventListener('icecandidate', this._onLocalCandidate);
        this._peerConnection = null;
      }
      this._earlyRemote = [];
      this._earlyLocal = [];
    }
  }, {
    key: '_onLocalCandidate',
    value: function _onLocalCandidate(event) {
      var candidate = event.candidate;

      if (!candidate) {
        return;
      }
      candidate = new Candidate(candidate);
      if (this._earlyLocal) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'buffering candidates emitted before first description: ' + candidate);
        this._earlyLocal.push(candidate);
      } else {
        this._localBuffer.push(candidate);
        if (!this._localBufferTimeout) {
          this._localBufferTimeout = setTimeout(this._onBufferTimeout, CANDIDATE_BUFFER_TIMEOUT_MS);
        }
      }
    }
  }, {
    key: '_onBufferTimeout',
    value: function _onBufferTimeout() {
      this._localBufferTimeout = 0;
      var candidates = this._localBuffer;
      this._localBuffer = [];
      __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'sending candidates via server: ' + candidates.join(', '));
      this._send(candidates);
    }
  }]);

  return Candidater;
}();

/* harmony default export */ __webpack_exports__["a"] = (Candidater);

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JsonChannelBroadcastController; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);






var TAG = 'json-channel-ctrl';

var JsonChannelBroadcastController = function () {
  function JsonChannelBroadcastController(_ref) {
    var onMessageFromPeer = _ref.onMessageFromPeer,
        onPeerChannelOpen = _ref.onPeerChannelOpen,
        onPeerChannelClose = _ref.onPeerChannelClose;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, JsonChannelBroadcastController);

    this._peers = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();

    this._onPeerChannelOpen = onPeerChannelOpen;
    this._onPeerChannelClose = onPeerChannelClose;
    this._onMessageFromPeer = onMessageFromPeer;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(JsonChannelBroadcastController, [{
    key: 'sendMessage',
    value: function sendMessage(message) {
      this._peers.forEach(function (_ref2, peerId) {
        var channel = _ref2.channel;

        if (channel.readyState === 'open') {
          channel.send(message).catch(function (error) {
            __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, 'failed to send broadcast message to peer \'' + peerId + '\', ' + error);
          });
        }
      });
    }
  }, {
    key: 'sendMessageToPeer',
    value: function sendMessageToPeer(peerId, message) {
      var peerInfo = this._peers.get(peerId);
      if (peerInfo) {
        peerInfo.channel.send(message).catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, 'failed to send message to peer \'' + peerId + '\', ' + error);
        });
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: 'addPeer',
    value: function addPeer(peerId, channel) {
      var _this = this;

      var peerInfo = {
        peerId: peerId,
        channel: channel,
        messageListener: function messageListener(message) {
          _this._onMessage(peerInfo, message);
        },
        readyStateListener: function readyStateListener(readyState) {
          _this._onConnectionStateChange(peerInfo, readyState);
        }
      };
      this._peers.set(peerId, peerInfo);
      channel.on('message', peerInfo.messageListener);
      channel.on('readyState', peerInfo.readyStateListener);
    }
  }, {
    key: 'removePeer',
    value: function removePeer(peerId) {
      if (!this._peers) return;
      var peerInfo = this._peers.get(peerId);
      if (peerInfo) {
        this._peers.delete(peerId);

        peerInfo.channel.off('message', peerInfo.messageListener);
        peerInfo.channel.off('readyState', peerInfo.readyStateListener);
        peerInfo.messageListener = null;
        peerInfo.readyStateListener = null;
      }
    }
  }, {
    key: '_onConnectionStateChange',
    value: function _onConnectionStateChange(peerInfo, readyState) {
      if (readyState === 'open') {
        this._onPeerChannelOpen(peerInfo.peerId);
      } else if (readyState === 'close') {
        this._onPeerChannelClose(peerInfo.peerId);
      }
    }
  }, {
    key: '_onMessage',
    value: function _onMessage(peerInfo, message) {
      this._onMessageFromPeer(peerInfo.peerId, message);
    }
  }, {
    key: 'cleanup',
    value: function cleanup() {
      var _this2 = this;

      this._onPeerChannelOpen = null;
      this._onPeerChannelClose = null;
      this._onMessageFromPeer = null;
      this._peers.forEach(function (_, peerId) {
        _this2.removePeer(peerId);
      });
      this._peers.clear();
      this._peers = null;
    }
  }]);

  return JsonChannelBroadcastController;
}();

/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = monitorDataChannels;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_utils__ = __webpack_require__(13);





function dataChannelMessageSize(message) {
  if (window.ArrayBuffer.isView(message)) {
    return message.byteLength || 0;
  }
  if (message instanceof Blob) {
    return message.size || 0;
  }
  if (message instanceof window.ArrayBuffer) {
    return message.byteLength || 0;
  }
  if (typeof message === 'string') {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["getStringByteLength"])(message) || 0;
  }
  return 0;
}

function monitorDataChannel(pcId, channel, statsHandler) {
  var bytesSent = 0;
  var bytesReceived = 0;
  var messagesSent = 0;
  var messagesReceived = 0;
  var timeout = 0;
  var identity = {
    pcId: pcId,
    id: channel.id,
    label: channel.label,
    protocol: channel.protocol,
    ordered: channel.ordered,
    reliable: channel.reliable,
    sourceId: 'channel-' + channel.id
  };

  function maybeStartStatTimer() {
    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = 0;
        var sample = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_common_utils__["assign"])({
          bytesSent: bytesSent,
          bytesReceived: bytesReceived,
          messagesSent: messagesSent,
          messagesReceived: messagesReceived,
          timestamp: Date.now()
        }, identity);
        statsHandler.handleStats([sample]);
      }, monitorDataChannels.MONITOR_INTERVAL);
    }
  }

  if (channel.addEventListener) {
    channel.addEventListener('message', function (event) {
      bytesReceived += dataChannelMessageSize(event.data);
      messagesReceived += 1;
      maybeStartStatTimer();
    });
  } else {
    channel.attachEvent('message', function (event) {
      bytesReceived += dataChannelMessageSize(event.data);
      messagesReceived += 1;
      maybeStartStatTimer();
    });
  }

  var realDataChannelSend = channel.send;
  channel.send = function (message) {
    bytesSent += dataChannelMessageSize(message);
    messagesSent += 1;
    maybeStartStatTimer();
    return realDataChannelSend.call(channel, message);
  };
}

function monitorDataChannels(peerConnection, statsHandler) {
  var tag = 'stats-monitor';

  peerConnection.addEventListener('datachannel', function (event) {
    var channel = event.channel;
    __WEBPACK_IMPORTED_MODULE_0_common_log__["default"].debug(tag, 'Setting up monitoring for remote data channel:', channel);
    monitorDataChannel(peerConnection.id, channel, statsHandler);
  });

  var realCreateDataChannel = peerConnection.createDataChannel;
  peerConnection.createDataChannel = function () {
    var channel = realCreateDataChannel.apply(peerConnection, arguments);
    __WEBPACK_IMPORTED_MODULE_0_common_log__["default"].debug(tag, 'Setting up monitoring for created data channel:', channel);
    monitorDataChannel(peerConnection.id, channel, statsHandler);
    return channel;
  };
}

monitorDataChannels.MONITOR_INTERVAL = 1000;

/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__ = __webpack_require__(290);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_webrtc_errors__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_webrtc_candidater__ = __webpack_require__(230);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_webrtc_renegotiator__ = __webpack_require__(285);














var TAG = 'signaler';

// state of the WebRTC offer/answer signaling
var SIGNALING_STATE_IDLE = 'idle';
var SIGNALING_STATE_OFFERED = 'offered';
var SIGNALING_STATE_STABLE = 'stable';

/*
      .-------------+--------------.
      v             |              |
  signaling -> connecting ---> connected
      ^                          |   ^
      |                          v   |
      `--------------------- reconnecting

*/
// signaling, peer connection is not in stable state
var CONNECTION_STATE_SIGNALING = 'signaling';
// peer connection in stable state, ice not connected
var CONNECTION_STATE_CONNECTING = 'connecting';
// peer connection stable and ice connected
var CONNECTION_STATE_CONNECTED = 'connected';
// ice was connected but has disconnected, might recover
var CONNECTION_STATE_RECONNECTING = 'reconnecting';
// call has been closed
var CONNECTION_STATE_CLOSED = 'closed';

var DATACHANNEL_BANDWIDTH = 2048; // TODO: Too high and stuff will break, figure out the right number.
var DISCONNECT_TIMEOUT_MS = 5000;
var SIGNALING_PROTOCOL_VERSION = 3;

function createTicket(remoteTicket) {
  if (remoteTicket) {
    // we have a remote ticket already, need to
    // make sure our ticket is greater than it.
    return remoteTicket + '.';
  } else {
    return Date.now() + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["randomString"])(8);
  }
}

var Signaler = function () {
  function Signaler(deps) {
    var _this = this;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, Signaler);

    if (deps.receivedOffer) {
      this._ticket = deps.receivedOffer.ticket;
      this._signalingState = null;
    } else {
      this._ticket = null;
      this._signalingState = SIGNALING_STATE_IDLE;
    }
    this._label = deps.label;
    this._isInitiator = null;
    this._peerConnection = null;
    this._receivedOffer = deps.receivedOffer;
    this._disconnectedTicket = null;

    this._errorState = null;
    this._connectionState = CONNECTION_STATE_SIGNALING;
    this._hasDataConnection = false;
    this._connectionFailCount = 0;
    this._disconnectTimeoutId = 0;

    this._closeCall = deps.closeCall;
    this._onMessage = deps.onMessage;
    this._onSignalingError = deps.onSignalingError;
    this._onErrorStateChange = deps.onErrorStateChange;
    this._onConnectionStateChange = deps.onConnectionStateChange;
    this._createPeerConnection = deps.onCreatePeerConnection;

    this._renegotiator = new __WEBPACK_IMPORTED_MODULE_9_webrtc_renegotiator__["a" /* default */]({
      label: this._label,
      onError: deps.onSignalingError,
      channel: deps.renegotiationChannel
    });

    this._candidater = new __WEBPACK_IMPORTED_MODULE_8_webrtc_candidater__["a" /* default */]({
      send: function send(candidates) {
        _this._sendMessage({ candidates: candidates });
      }
    });
    this._onIceStateChange = this._onIceStateChange.bind(this);
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(Signaler, [{
    key: '_sendMessage',
    value: function _sendMessage(message) {
      var ticket = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._ticket;

      return this._onMessage(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_extends___default()({
        ticket: ticket,
        version: SIGNALING_PROTOCOL_VERSION
      }, message));
    }
  }, {
    key: 'handleDataChannelConnect',
    value: function handleDataChannelConnect() {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'signaling channel opened');
      if (this.closed) {
        return __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'signaling channel opened in closed state');
      }
      this._hasDataConnection = true;
      this._renegotiator.start(this._isInitiator);
      this._setConnectionState(CONNECTION_STATE_CONNECTED);
      this._setErrorState(null);
      this._connectionFailCount = 0;
    }

    // 'closed' | 'channelTimeout' | 'connectTimeout'

  }, {
    key: 'handleDataChannelDisconnect',
    value: function handleDataChannelDisconnect(reason) {
      this._hasDataConnection = false;
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'data connection lost because of ' + reason);
      if (this._connectionState === CONNECTION_STATE_CONNECTED) {
        this._connectionHasFailed(new __WEBPACK_IMPORTED_MODULE_6_webrtc_errors__["a" /* ConnectionLostError */]('The data connection was lost'));
      }
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'signaler{"' + this._label + '",state=' + this._signalingState + ',' + ('ticket=' + this._ticket + ',isInitiator=' + this._isInitiator + '}');
    }
  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this._hasDataConnection;
    }
  }, {
    key: 'transitionToClosed',
    value: function transitionToClosed() {
      if (this.closed) {
        return false;
      }
      this._setConnectionState(CONNECTION_STATE_CLOSED);
      return true;
    }
  }, {
    key: '_replacePeerConnection',
    value: function _replacePeerConnection() {
      if (this._peerConnection) {
        this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceStateChange);
      }
      this._peerConnection = this._createPeerConnection();
      this._peerConnection.addEventListener('iceconnectionstatechange', this._onIceStateChange);

      this._candidater.setPeerConnection(this._peerConnection);
      this._renegotiator.setPeerConnection(this._peerConnection);
    }
  }, {
    key: '_sendDescription',
    value: function _sendDescription(description, ticket) {
      var content = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_defineProperty___default()({
        browser: __WEBPACK_IMPORTED_MODULE_7_common_utils__["browser"],
        candidates: this._candidater.extractEarlyLocal()
      }, description.type, {
        type: description.type,
        sdp: description.sdp,
        unifiedPlanSdp: description.unifiedPlanSdp
      });
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'sending description, ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(content));
      this._sendMessage(content, ticket);
    }
  }, {
    key: 'handleMessage',
    value: function handleMessage(message) {
      if (this.closed) {
        return;
      }
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'handling signaling message', message);
      var ticket = message.ticket,
          hangup = message.hangup,
          offer = message.offer,
          answer = message.answer,
          candidates = message.candidates,
          version = message.version;

      if (version < SIGNALING_PROTOCOL_VERSION) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(TAG, this, 'ignoring message with incompatible protocol version: ' + version);
        return;
      }
      if (hangup) {
        if (!(ticket === this._ticket || ticket === this._disconnectedTicket)) {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, this, 'ignored hangup with wrong ticket: ' + ticket + ', old ticket = ' + this._disconnectedTicket);
          return;
        }
        throw new Error('hangup');
      }
      if (offer) {
        this._handleOffer(message);
      } else if (answer) {
        if (ticket !== this._ticket) {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, this, 'ignored answer with wrong ticket: ' + ticket);
          return;
        }
        this._handleAnswer(message);
      }
      if (candidates) {
        if (ticket !== this._ticket) {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'ignored candidates with wrong ticket: ' + ticket);
          return;
        }
        this._candidater.handleRemoteCandidates(candidates);
      }
    }
  }, {
    key: '_setConnectionState',
    value: function _setConnectionState(connectionState) {
      var prevState = this._connectionState;
      this._connectionState = connectionState;
      if (prevState !== connectionState) {
        this._onConnectionStateChange(connectionState, prevState);
      }
    }
  }, {
    key: '_setErrorState',
    value: function _setErrorState(errorState) {
      if (errorState !== this._errorState) {
        this._errorState = errorState;
        this._onErrorStateChange(errorState);
      }
    }
  }, {
    key: '_connectionHasFailed',
    value: function _connectionHasFailed(error) {
      clearTimeout(this._disconnectTimeoutId);
      this._disconnectTimeoutId = 0;
      if (this.closed) {
        return;
      }

      if (this._connectionState === CONNECTION_STATE_SIGNALING) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, this, 'connection failed while signaling');
      }
      this._setConnectionState(CONNECTION_STATE_SIGNALING);
      this._setErrorState(error);
      this._disconnectedTicket = this._ticket;

      if (this.closed) {
        return; // application closed the call in the error handler
      }
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'trying to restart call because connection failed');
      // channel and ice listeners are cleared here, so this method won't be called twice for the same pc
      this._replacePeerConnection();
      this._doOffer();
    }
  }, {
    key: '_onIceStateChange',
    value: function _onIceStateChange() {
      var _this2 = this;

      if (this.closed) {
        return;
      }
      var connState = this._peerConnection.iceConnectionState;
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'changed ice connection state to ' + connState);

      if (connState === 'failed') {
        this._connectionFailCount += 1;
        this._connectionHasFailed(new __WEBPACK_IMPORTED_MODULE_6_webrtc_errors__["b" /* ConnectionFailedError */](this._connectionFailCount));
      } else if (connState === 'disconnected') {
        this._setConnectionState(CONNECTION_STATE_RECONNECTING);
        this._disconnectTimeoutId = setTimeout(function () {
          _this2._connectionHasFailed(new __WEBPACK_IMPORTED_MODULE_6_webrtc_errors__["a" /* ConnectionLostError */]('Timed out in disconnected state'));
        }, DISCONNECT_TIMEOUT_MS);
      } else {
        clearTimeout(this._disconnectTimeoutId);
        this._disconnectTimeoutId = 0;
        if (connState === 'connected' && this.isConnected()) {
          this._setConnectionState(CONNECTION_STATE_CONNECTED);
        }
      }
    }
  }, {
    key: '_doOffer',
    value: function _doOffer(remoteTicket) {
      var _this3 = this;

      if (this.closed) {
        return __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, this, 'trying to do offer in closed state');
      }
      // Need to make sure this ticket is used in the closure below. The _ticket member might
      // get updated because of a conflict, and then we would send the offer with
      // the wrong (new) ticket.
      var ticket = createTicket(remoteTicket);
      this._ticket = ticket;
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'doing offer with ticket ' + this._ticket);
      this._signalingState = SIGNALING_STATE_OFFERED;
      this._isInitiator = true;
      this._peerConnection.performOffer({ bandwidth: DATACHANNEL_BANDWIDTH }).then(function (description) {
        return _this3._sendDescription(description, ticket);
      }).catch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["errorForwarder"])(this._onSignalingError, '_doOffer'));
    }
  }, {
    key: '_doAnswer',
    value: function _doAnswer(offer, ticket) {
      var _this4 = this;

      if (this.closed) {
        return __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, this, 'trying to do answer in closed state');
      }
      this._ticket = ticket;
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'doing answer with ticket ' + this._ticket);
      this._signalingState = SIGNALING_STATE_STABLE;
      this._isInitiator = false;
      this._peerConnection.performAnswer({ offer: offer, bandwidth: DATACHANNEL_BANDWIDTH }).then(function (description) {
        return _this4._sendDescription(description, ticket);
      }).then(function () {
        _this4._candidater.addEarlyRemoteCandidates();
        _this4._signalingState = SIGNALING_STATE_STABLE;
        if (_this4._connectionState !== CONNECTION_STATE_CONNECTED) {
          _this4._setConnectionState(CONNECTION_STATE_CONNECTING);
        }
      }).catch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["errorForwarder"])(this._onSignalingError, '_doAnswer'));
    }
  }, {
    key: '_handleOffer',
    value: function _handleOffer(_ref) {
      var offer = _ref.offer,
          ticket = _ref.ticket,
          remoteBrowser = _ref.browser,
          candidates = _ref.candidates;

      // this.candidater.handleRemoteCandidates(candidates)
      var alwaysOffer = false;
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'got offer in state \'' + this._signalingState + '\' with tickets ' + ticket + ' >= ' + this._ticket);
      var isChromeToOther = __WEBPACK_IMPORTED_MODULE_7_common_utils__["browser"] === 'chrome' && remoteBrowser !== 'chrome';
      var isPluginToFirefox = __WEBPACK_IMPORTED_MODULE_7_common_utils__["browser"] === 'other' && remoteBrowser === 'firefox';
      if (isChromeToOther || isPluginToFirefox) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, 'offer is from ' + remoteBrowser + ' and this is ' + __WEBPACK_IMPORTED_MODULE_7_common_utils__["browser"] + ', forcing offer');
        alwaysOffer = true;
      }
      if (this._signalingState === SIGNALING_STATE_IDLE) {
        this._replacePeerConnection();
        if (alwaysOffer) {
          this._doOffer(ticket);
        } else {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'restarting call and applying offer');
          this._doAnswer(offer, ticket);
        }
      } else if (this._signalingState === SIGNALING_STATE_OFFERED) {
        if (ticket >= this._ticket) {
          // call needs to be aborted
          this._replacePeerConnection();
          if (alwaysOffer) {
            __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'resolving always offer conflict by resetting and offering');
            this._doOffer(ticket);
          } else {
            __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'resolving conflict by aborting dial out and sending answer');
            this._doAnswer(offer, ticket);
          }
        } else {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'resolving conflict by waiting for answer');
        }
      } else if (this._signalingState === SIGNALING_STATE_STABLE) {
        if (alwaysOffer) {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, this, 'resetting call and offering');
          this._replacePeerConnection();
          this._doOffer(ticket);
        } else if (ticket >= this._ticket) {
          // call should be reset
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'resetting call and applying offer');
          this._replacePeerConnection();
          this._doAnswer(offer, ticket);
        } else {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'ignoring offer for old call');
        }
      } else if (this.closed) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, this, 'got offer in closed state, ignoring');
      }
    }
  }, {
    key: '_handleAnswer',
    value: function _handleAnswer(_ref2) {
      var _this5 = this;

      var answer = _ref2.answer,
          ticket = _ref2.ticket;

      if (this._signalingState !== SIGNALING_STATE_OFFERED) {
        return __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(TAG, this, 'got answer in wrong state: ' + this._signalingState);
      }
      this._signalingState = SIGNALING_STATE_STABLE;
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].verbose(TAG, this, 'got answer, initial call setup stabilized');

      this._peerConnection.handleAnswer({ answer: answer }).then(function () {
        _this5._candidater.addEarlyRemoteCandidates();
        if (_this5._connectionState !== CONNECTION_STATE_CONNECTED) {
          _this5._setConnectionState(CONNECTION_STATE_CONNECTING);
        }
      }).catch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_utils__["errorForwarder"])(this._onSignalingError, '_handleAnswer'));
    }
  }, {
    key: 'sendHangup',
    value: function sendHangup() {
      this._sendMessage({ hangup: true });
    }
  }, {
    key: 'start',
    value: function start() {
      var _this6 = this;

      if (this.closed) {
        return false;
      }

      if (this._receivedOffer) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].debug(TAG, this, 'accepting incoming call:', this._receivedOffer);
        this._signalingState = SIGNALING_STATE_IDLE;
        this._handleOffer(this._receivedOffer);
        this._receivedOffer = null;
      } else {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, 'call started or restarted in state \'' + this._signalingState + '\'');
        this._signalingState = SIGNALING_STATE_OFFERED;
        this._replacePeerConnection();
        setTimeout(function () {
          return _this6._doOffer();
        });
      }
      return true;
    }
  }, {
    key: 'reset',
    value: function reset() {
      if (this._peerConnection) {
        this._peerConnection.removeEventListener('iceconnectionstatechange', this._onIceStateChange);
      }
      clearTimeout(this._disconnectTimeoutId);
      this._disconnectTimeoutId = 0;
      this._hasDataConnection = false;
      this._peerConnection = null;
      this._isInitiator = null;
      this._renegotiator.reset();
      this._candidater.reset();
    }
  }, {
    key: 'ticket',
    get: function get() {
      return this._ticket;
    }
  }, {
    key: 'connectionState',
    get: function get() {
      return this._connectionState;
    }
  }, {
    key: 'errorState',
    get: function get() {
      return this._errorState;
    }

    /* true, false, null - tribool wombo-combo ! */

  }, {
    key: 'isInitiator',
    get: function get() {
      return this._isInitiator;
    }
  }, {
    key: 'closed',
    get: function get() {
      return this._connectionState === CONNECTION_STATE_CLOSED;
    }
  }, {
    key: 'stopped',
    get: function get() {
      return !this._signalingState;
    }
  }]);

  return Signaler;
}();

/* harmony default export */ __webpack_exports__["a"] = (Signaler);

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(294), __esModule: true };

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(25)
  , toIObject = __webpack_require__(15)
  , isEnum    = __webpack_require__(43).f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

/***/ }),
/* 236 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Auth;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_request__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_matrix_errors__ = __webpack_require__(196);









/**
 * An object containing the necessary information to connect and authenticate to a server.
 *
 * The serverUrl will be used as base for all requests, and must include protocol
 * and hostname, optionally port, and nothing else. A trailing slash is an error.
 *
 * The home serverName is appended to all ids that are generated, using the
 * following pattern: `<symbol><id>:<serverName>`
 * Where symbol is `@` for user ids, `!` for room ids, and `#` for room aliases.
 *
 * By default the serverName is parsed from the userId, but can also be set explicitly.
 * AuthInfo objects returned by the built-in authentication functions will not set the serverName,
 * so it will have to be set as a middle step before passing the authInfo on to {@link Client#auth}.
 *
 *
 * @typedef {Object} AuthInfo
 * @property {string} serverUrl - The absolute url of the home server.
 * @property {string} [serverName] - An optional server name, will be parsed from the userId if not present.
 * @property {string} [userId] - An optional user id that should match the user id of the access token,
 *   otherwise authentication will fail.
 * @property {string} accessToken - The access token
 */

/**
 * Represents a step in an authentication flow. Currently all authenication
 * flows only use a single step, so this function is used as a namespace
 * for static atuhentication functions.
 *
 * @class Auth
 * @abstract
 */

function Auth(priv) {
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["assertPriv"])('Auth', priv);
}

/**
 * Login a user using username and password.
 * ##### Errors:
 * - {@link AuthenticationError} - The username or password is incorrect.
 *
 * @param {Object} options - Configuration object.
 * @param {string} options.serverUrl - The absolute url of the home server.
 * @param {UserId} options.username - The username.
 * @param {string} options.password - The password.
 * @returns {Promise<AuthInfo, CctError>} - Auth info or an error.
 */
Auth.loginWithPassword = function (options) {
  __WEBPACK_IMPORTED_MODULE_1_common_argCheck__["a" /* default */].options('Auth.loginWithPassword', 'options', options).string('serverUrl').string('username').string('password');

  return Auth._simpleAuthRequest({
    serverUrl: options.serverUrl
  }, 'login', {
    type: 'm.login.password',
    user: options.username,
    password: options.password
  });
};

// eslint-disable-next-line jsdoc/require-description-complete-sentence
/**
 * Register a new user.
 *
 * A registration secret should be used iff the server is configured to only allow
 * registration using a secret token. The secret token is used to compute an HMAC
 * and is not sent to the server.
 * ##### Errors:
 * - {@link ConflictError} - The username is taken.
 * - {@link InvalidUsernameError} - The username contains invalid characters.
 * - {@link AuthenticationError} - The provided secret was incorrect.
 * - {@link NotAllowedError} - No secret was provided but the server requires one.
 *
 * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
 *
 * @param {Object} options - Configuration object.
 * @param {string} options.serverUrl - The absolute url of the home server.
 * @param {UserId} options.username - The username.
 * @param {string} options.password - The password.
 * @param {string} [options.secret] - Shared registration secret.
 * @returns {Promise<AuthInfo, CctError>} - Auth info or an error.
 *
 */
Auth.registerWithPassword = function (options) {
  __WEBPACK_IMPORTED_MODULE_1_common_argCheck__["a" /* default */].options('Auth.registerWithPassword', 'options', options).string('serverUrl').string('username').string('password').optString('secret');

  var body = {
    auth: {
      session: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["randomString"])(20),
      type: 'm.login.dummy'
    },
    username: options.username,
    password: options.password
  };
  var req = Auth._simpleAuthRequest.bind(0, {
    serverUrl: options.serverUrl
  }, 'register');

  if ('secret' in options) {
    return Auth._createHmac(options).then(function (mac) {
      body.auth.type = 'org.matrix.login.shared_secret';
      body.mac = mac;
      return req(body);
    });
  }

  return req(body);
};

/**
 * Set a new password using an existing login session and the old password.
 * ##### Errors:
 * - {@link AuthenticationError} - The provided session is invalid, or the old password is incorrecct.
 *
 * @param {Object} options - Configuration object.
 * @param {AuthInfo} options.authInfo - Auth info object.
 * @param {string} options.oldPassword - Old password.
 * @param {string} options.newPassword - New password.
 * @returns {Promise<AuthInfo, CctError>} - Auth info or an error.
 */
Auth.resetPasswordWithPassword = function (options) {
  __WEBPACK_IMPORTED_MODULE_1_common_argCheck__["a" /* default */].options('Auth.resetPasswordWithPassword', 'options', options).object('authInfo').string('oldPassword').string('newPassword');

  var authInfo = options.authInfo;
  __WEBPACK_IMPORTED_MODULE_1_common_argCheck__["a" /* default */].options('Auth.resetPasswordWithPassword', 'options.authInfo', options.authInfo).string('serverUrl').string('userId').string('accessToken');

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_common_request__["c" /* default */])().errorHandler(__WEBPACK_IMPORTED_MODULE_4_matrix_errors__["a" /* parseSynapseErrorResponse */]).origin(authInfo.serverUrl).path('_matrix', 'client', 'v2_alpha', 'account', 'password').query('access_token', authInfo.accessToken).post({
    auth: {
      type: 'm.login.password',
      user: authInfo.userId,
      password: options.oldPassword
    },
    new_password: options.newPassword
  }).then(function (response) {
    return response.body;
  }, function (response) {
    throw response;
  });
};

/**
 * Register a new account with a generated username.
 * This should primarily be used for testing.
 *
 * A password can optionally be added to the account.
 * ##### Errors:
 * - {@link AuthenticationError} - The provided secret was incorrect.
 * - {@link NotAllowedError} - No secret was provided but the server requires one.
 *
 * @param {Object} options - Configuration object.
 * @param {string} options.serverUrl - The absolute url of the home server.
 * @param {string} [options.password] - The password to use for the account.
 * @param {string} [options.secret] - Shared registration secret.
 * @returns {Promise<AuthInfo, CctError>} - Auth info or an error.
 */
Auth.anonymous = function (options) {
  __WEBPACK_IMPORTED_MODULE_1_common_argCheck__["a" /* default */].options('Auth.anonymous', 'options', options).string('serverUrl').optString('password').optString('secret');

  var body = {
    auth: {
      session: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["randomString"])(20),
      type: 'm.login.dummy'
    },
    password: options.password || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["randomString"])(32)
  };
  var req = Auth._simpleAuthRequest.bind(0, {
    serverUrl: options.serverUrl
  }, 'register');

  if ('secret' in options) {
    body.username = Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
    return Auth._createHmac({ username: body.username, secret: options.secret }).then(function (mac) {
      body.auth.type = 'org.matrix.login.shared_secret';
      body.mac = mac;
      return req(body);
    });
  }

  return req(body);
};

/**
 * Authenticate as a guest user with a generated user id. Guest accounts are limited
 * to a subset of the functionality of full acounts.
 *
 * At the moment guests are only allowed to join rooms where `room.guestAccess` has been
 * set to 'open'. They are not allowed to modify the state of a room, but can send messages
 * and setup calls.
 *
 * Guests are also not able to set their avatar or status, but they can set their display name.
 * ##### Errors:
 * - {@link GuestAccessError} - Guest access is not enabled in the target server.
 *
 * @param {Object} options - Configuration object.
 * @param {string} options.serverUrl - The absolute url of the home server.
 * @returns {Promise<AuthInfo, CctError>} - Auth info or an error.
 */
Auth.guest = function (options) {
  __WEBPACK_IMPORTED_MODULE_1_common_argCheck__["a" /* default */].options('Auth.anonymous', 'options', options).string('serverUrl');

  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_common_request__["c" /* default */])().errorHandler(__WEBPACK_IMPORTED_MODULE_4_matrix_errors__["a" /* parseSynapseErrorResponse */]).origin(options.serverUrl).path('_matrix', 'client', 'r0', 'register').query('kind', 'guest').post({}).then(function (response) {
    var authInfo = {
      serverUrl: options.serverUrl
    };
    authInfo.accessToken = response.body.access_token;
    authInfo.userId = response.body.user_id;
    if (response.body.refresh_token) {
      authInfo.refreshToken = response.body.refresh_token;
    }
    return authInfo;
  }, function (response) {
    throw response;
  });
};

Auth._simpleAuthRequest = function (authInfo, path, body) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_common_request__["c" /* default */])().errorHandler(__WEBPACK_IMPORTED_MODULE_4_matrix_errors__["a" /* parseSynapseErrorResponse */]).origin(authInfo.serverUrl).path('_matrix', 'client', 'r0', path).post(body).then(function (response) {
    authInfo.accessToken = response.body.access_token;
    authInfo.userId = response.body.user_id;
    if (response.body.refresh_token) {
      authInfo.refreshToken = response.body.refresh_token;
    }
    return authInfo;
  }, function (response) {
    throw response;
  });
};

Auth._createHmac = function (_ref) {
  var username = _ref.username,
      secret = _ref.secret;

  if (false) {
    return _Promise.resolve().then(function () {
      var hmac = require('crypto').createHmac('sha1', secret);
      hmac.update(username);
      return hmac.digest('hex');
    });
  } else {
    var rawKey = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["binaryStringToArrayBuffer"])(secret);
    var data = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["binaryStringToArrayBuffer"])(username);
    var crypto = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["noVendor"])(window, 'crypto');
    var subtle = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["noVendor"])(crypto, 'subtle');

    var promise = subtle.importKey('raw', rawKey, {
      name: 'HMAC',
      hash: {
        name: 'SHA-1'
      }
    }, false, ['sign']);
    if (promise.then) {
      return promise.then(function (key) {
        return subtle.sign(key.algorithm, key, data);
      }).then(__WEBPACK_IMPORTED_MODULE_2_common_utils__["bufferToHex"]);
    } else {
      // IE11 webcrypto is not promise based
      // Edge is promise based
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve) {
        promise.oncomplete = function (e) {
          var key = e.target.result;
          subtle.sign(key.algorithm, key, data).oncomplete = function (e) {
            resolve(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["bufferToHex"])(e.target.result));
          };
        };
      });
    }
  }
};

/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Client;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_reporter__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_request__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_errors__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_matrix_accountData__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_matrix_callRegistry__ = __webpack_require__(275);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_matrix_resources__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_matrix_roomQuery__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_matrix_roomRegistry__ = __webpack_require__(276);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_matrix_syncStream__ = __webpack_require__(277);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_matrix_userRegistry__ = __webpack_require__(197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_matrix_errors__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_matrix_ids__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_matrix_powerLevels__ = __webpack_require__(186);























var API_VERSION = 'r0.0.1';

// eslint-disable-next-line
/**
 * Represents a client.
 *
 * @class Client
 * @extends EventEmitter
 * @param {Object} [options] - An object with extra options.
 * @param {IceServer|IceServer[]} [options.iceServers] - One or more helper servers to use as default for all calls.
 * @param {IceCandidateFilter} [options.iceCandidateFilter] - A function used to
 *   filter the ice candidates in all calls and conferences.
 * @param {string} [options.statsUrl] - The stats report URL to which to post, e.g. `https://example.com/path`.
 */
function Client(options) {
  __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].optOptions('Client', 'options', options).optString('statsUrl').optFunc('iceCandidateFilter');

  var self = this;
  options = options || {};
  var authedRequest = null;
  var activeAuthInfo = null;
  var user = null;
  var imageResourceFactory = null;
  var userRegistry = new __WEBPACK_IMPORTED_MODULE_15_matrix_userRegistry__["b" /* default */]();
  var roomRegistry = new __WEBPACK_IMPORTED_MODULE_13_matrix_roomRegistry__["a" /* default */]({
    delegate: this
  });
  var callRegistry = new __WEBPACK_IMPORTED_MODULE_10_matrix_callRegistry__["a" /* default */]({
    userRegistry: userRegistry,
    roomRegistry: roomRegistry,
    delegate: this
  });
  this._syncStream = new __WEBPACK_IMPORTED_MODULE_14_matrix_syncStream__["a" /* default */]({
    userRegistry: userRegistry,
    roomRegistry: roomRegistry,
    delegate: this
  });
  var iceServers = [].concat(options.iceServers || []);
  var iceCandidateFilter = options.iceCandidateFilter || null;
  var roomQueries = [];
  var userRequests = {};
  var reporter = null;

  this._setAccountData = this._setAccountData.bind(this);
  this._accountData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_9_matrix_accountData__["a" /* default */], this._setAccountData);

  if (options.statsUrl) {
    reporter = new __WEBPACK_IMPORTED_MODULE_5_common_reporter__["a" /* default */](options.statsUrl);
  }

  function authed() {
    if (!authedRequest) {
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject(new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('not authenticated'));
    } else {
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve(authedRequest);
    }
  }

  /**
   * Forgets the auth session and resets the client state.
   *
   * @function Client#logout
   */
  function logout() {
    if (!authedRequest) {
      return;
    }
    authedRequest = null;
    activeAuthInfo = null;
    user = null;
    callRegistry.clear();
    roomRegistry.clear();
    roomQueries.forEach(function (query) {
      return query._clear();
    });
    userRequests = {};
    userRegistry.clear();
    imageResourceFactory = null;
    self._syncStream.stop();
    self._accountData._clear();
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["unregisterInstance"])('client', self);
  }

  /**
   * Set the name of the authenticated user.
   *
   * There is no guarantee that `client.user.name` will be up to date if and when
   * the returned promise is resolved. UI updates to reflect the new name should
   * instead be triggered by the 'name' event of the user.
   * ##### Errors:
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   *
   * @function Client#setName
   * @param {string} name - A new name, or `null`.
   * @returns {Promise<string, CctError>} - The name.
   */
  function setName(name) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].optString('client.setName', 'name', name);
    return authed().then(function (authedRequest) {
      return authedRequest.setName.put({ displayname: name }).then(function () {
        return name;
      });
    });
  }

  // eslint-disable-next-line jsdoc/require-description-complete-sentence
  /**
   * Set the avatar of the authenticated user. The avatar can be either a
   * {@link MatrixContentUri}, or an {@link ImageResource}.
   *
   * Typical usage is to first upload an image file using {@link Client#uploadMedia},
   * and then setting it as the avatar.
   *
   * There is no guarantee that `client.user.avatar` will be up to date if and when
   * the returned promise is resolved. UI updates to reflect the new avatar should
   * instead be triggered by the 'avatar' event of the user.
   * ##### Errors:
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   * - {@link GuestAccessError} - Guests are not allowed to set an avatar.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
   *
   * @function Client#setAvatar
   * @param {MatrixContentUri|ImageResource} avatar - A new avatar url or image resource, or null.
   * @returns {Promise<ImageResource, CctError>} - The avatar.
   */
  function setAvatar(avatar) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].count('client.setAvatar', 1, arguments.length);
    if (!activeAuthInfo) {
      var msg = 'client.setAvatar: client needs to be authenticated to set an avatar';
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject(new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */](msg));
    }
    var avatar_url;
    if (avatar) {
      if (!(avatar instanceof __WEBPACK_IMPORTED_MODULE_11_matrix_resources__["a" /* default */])) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('client.setAvatar', 'avatar', avatar);
        avatar = imageResourceFactory(avatar);
      }
      avatar_url = avatar.resourceUri;
    } else {
      avatar_url = null;
      avatar = null;
    }
    return authed().then(function (authedRequest) {
      return authedRequest.setAvatar.put({ avatar_url: avatar_url }).then(function () {
        return avatar;
      });
    });
  }

  // eslint-disable-next-line jsdoc/require-description-complete-sentence
  /**
   * Sets the status of the authenticated user.
   * ##### Errors:
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   * - {@link GuestAccessError} - Guests are not allowed to set their status.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
   *
   * @function Client#setStatus
   * @param {Object} status - An object describing the status of the authenticated user.
   * @param {"online"|"unavailable"|"offline"} [status.presence] - The presence type to set.
   * @param {string} [status.statusMessage] - A status message to display to other users.
   * @returns {Promise<Client, CctError>} - The client.
   */
  function setStatus(status) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].options('client.setStatus', 'status', status).optValues('presence', ['online', 'unavailable', 'offline']).optStringOrEmpty('statusMessage');

    var presence = status.presence || user.presence;
    return authed().then(function (authedRequest) {
      return authedRequest.setStatus.put({
        presence: presence,
        status_msg: status.statusMessage
      }).then(function () {
        return self;
      });
    });
  }

  /**
   * The state of the client.
   * @readonly
   * @member Client#state {ClientConnectionState}
   */
  Object.defineProperty(this, 'state', {
    enumerable: true,
    get: function get() {
      return this._syncStream.state;
    }
  });

  /**
   * Authenticates the client using authentication information that has been obtained
   * in some way, usually using {@link Auth}.
   * ##### Errors:
   * - {@link NotAllowedError} - The provided authentication information is invalid.
   *
   * @function Client#auth
   * @param {AuthInfo} authInfo - An object containing the necessary information
   * to connect and authenticate to a server.
   * @returns {Promise<Client, CctError>} - The client or error.
   */
  function auth(authInfo) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].options('client.auth', 'authInfo', authInfo).string('accessToken').string('serverUrl').optString('userId').optString('serverName');

    return new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a(function (resolve) {
      activeAuthInfo = authInfo;
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["registerInstance"])('client', self);

      // Allow trailing slash in serverUrl, but remove it here
      var serverUrl = authInfo.serverUrl = authInfo.serverUrl.replace(/\/$/, '');

      // Decode the macaroon and read the userId
      var rawMacaroon = void 0;
      try {
        rawMacaroon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["urlSafeBase64ToUtf8"])(authInfo.accessToken);
      } catch (error) {
        throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('Failed to decode access token: ' + error);
      }
      var macaroonMatch = rawMacaroon.match(/^[0-9a-f]{4}cid user_id = (.*)$/m);
      if (!macaroonMatch) {
        throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('Access token is malformed, no user info present');
      }
      var matrixUserId = macaroonMatch[1];

      // authInfo.userId is optional, but if it's present, make sure it matches the macaroon
      if (authInfo.userId && authInfo.userId !== matrixUserId) {
        throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('Invalid auth info, userId does not match the token');
      }

      var serverName = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_matrix_ids__["c" /* parseId */])(matrixUserId)[2];

      if ('serverName' in authInfo) {
        if (serverName !== authInfo.serverName) {
          var msg = 'Invalid auth info, serverName does not match, \'' + serverName + '\' != \'' + auth.serverName + '\'';
          throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */](msg);
        }
      }
      authInfo.serverName = serverName;

      imageResourceFactory = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_matrix_resources__["b" /* createImageResourceFactory */])(serverUrl);
      userRegistry.init({
        serverName: serverName,
        ownMatrixUserId: matrixUserId,
        imageResourceFactory: imageResourceFactory
      });

      var baseRequest = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_request__["c" /* default */])().client(new __WEBPACK_IMPORTED_MODULE_6_common_request__["a" /* SerializedJsonRetryClient */]()).errorHandler(__WEBPACK_IMPORTED_MODULE_16_matrix_errors__["a" /* parseSynapseErrorResponse */]).origin(serverUrl).path('_matrix').query('access_token', authInfo.accessToken).params('userId', matrixUserId);

      authedRequest = baseRequest.path('client', 'r0');
      self._authedRequest = authedRequest;

      var profile = authedRequest.path('profile', '{userId}');

      authedRequest.profile = profile;
      authedRequest.setName = profile.path('displayname');
      authedRequest.setAvatar = profile.path('avatar_url');
      authedRequest.getPublicRooms = authedRequest.path('publicRooms');
      authedRequest.createRoom = authedRequest.path('createRoom');
      authedRequest.directory = authedRequest.path('directory', 'room');
      authedRequest.setAccountData = authedRequest.path('user', '{userId}', 'account_data');
      authedRequest.setStatus = authedRequest.path('presence', '{userId}', 'status');
      // Used to check if a room exists, there might be a better way to do this in the future
      authedRequest.leaveRoom = authedRequest.path('rooms', '{roomId}', 'leave');
      authedRequest.uploadMedia = baseRequest.client(new __WEBPACK_IMPORTED_MODULE_6_common_request__["d" /* FileUploadClient */]()).errorHandler(__WEBPACK_IMPORTED_MODULE_16_matrix_errors__["a" /* parseSynapseErrorResponse */]).path('media', 'v1', 'upload');

      user = userRegistry.getUser(matrixUserId);

      // TODO: remove call-specific dependencies
      roomRegistry.init({
        ownUser: user,
        delegate: self,
        baseRequest: authedRequest,
        serverName: serverName,
        userRegistry: userRegistry,
        callRegistry: callRegistry,
        imageResourceFactory: imageResourceFactory
      });

      callRegistry.init({
        ownUser: user,
        reporter: reporter,
        iceServers: iceServers,
        iceCandidateFilter: iceCandidateFilter,
        baseRequest: authedRequest
      });

      resolve(authedRequest);
    }).then(function (authedRequest) {
      return self._syncStream.start({ authedRequest: authedRequest }).catch(function (error) {
        logout();
        throw error;
      });
    }).then(function () {
      var foundMemberRoom = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["find"])(self.rooms, function (room) {
        return room.membership === 'member';
      });
      if (!foundMemberRoom) {
        return self.fetchUser(self.user.id);
      }
    }).then(function () {
      // This is done in parallel, don't return promise
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_request__["c" /* default */])().origin(authInfo.serverUrl).path('_matrix', 'client', 'versions').get().then(function (res) {
        var versions = res.body && res.body.versions;
        if (!Array.isArray(versions)) {
          __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(self.tag, 'invalid versions response: ' + res.body);
        }
        if (versions.indexOf(API_VERSION) === -1) {
          __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(self.tag, 'invalid server version: ' + versions.join(', '));
        }
      }).catch(function (error) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(self.tag, 'version check request failed: ' + error);
      });
    }).then(function () {
      return self;
    });
  }

  /**
   * Room configuration passed to {@link Client#createRoom}.
   *
   * @typedef {Object} Client.RoomConfiguration
   * @property {UserId|User|UserId[]|User[]} [invite] - A single or list of users
   * to invite when creating the room.
   * @property {string} [name] - The display name of the room.
   * @property {string} [type] - The type that should be assigned to the room.
   * @property {string} [topic] - The topic to display for the room.
   * @property {MatrixContentUri|ImageResource} [avatar] - The avatar for the room.
   * @property {RoomAlias} [alias] - A local alias for the room id.
   * @property {PowerLevelsEdit|PowerLevelsReader} [powerLevels] - The initial
   *  power levels in the room.
   * @property {Room~HistoryVisibility} [historyVisibility='shared'] - The desired
   *  history visibility of the room.
   * @property {Room~JoinRule} [joinRule] - The desired join rule of the room.
   *  By default it will match the visiblity of the room, meaning that a public room
   *  will use the `'open'` join rule while a private room will user `'invite'`.
   * @property {Room~GuestAccessRule} [guestAccessRule='closed'] - The desired guest access rule of the room.
   * @property {JsonTypes} [creationContent] - Values that will be accessible via {@link Room#creationContent}
   *  and can not be changed by anyone.
   * @property {Object[]} [state] - An array of custom initial states of the room.
   * @property {string} state.type - The type of the state.
   * @property {string} [state.stateKey] - An optional state key.
   * @property {*} state.content - The content of the state.
   * @property {Object} [recording] - Recording options object. Will only work if the server has enabled recording.
   * @property {Object} recording.meta - The room-level metadata object that will be stored together with the recording.
   */

  // eslint-disable-next-line jsdoc/require-description-complete-sentence
  /**
   * Creates a new room.
   * ##### Errors:
   * - {@link ConflictError} - The room alias already exists.
   * - {@link InvalidAliasError} - The room alias is invalid
   * - {@link GuestAccessError} - Guests are not allowed to create new rooms.
   * - {@link NotAllowedError} - If creating a room with modified power levels this may happen
   *     when setting the own user's power level too low.
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   *
   * @function Client#createRoom
   * @param {Client.RoomConfiguration} [options] - Room configuration.
   * @returns {Promise<Room, CctError>} - Auth information or error.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
   *
   * @example
   * client.createRoom().then(room => {
   *   console.log('Created room: ' + room)
   * })
   *
   * @example
   * client.createRoom({
   *   type: 'meeting',
   *   name: 'Meeting with Bob',
   *   topic: 'Widget production schedule',
   *   invite: 'bob',
   * }).then(room => {
   *   console.log('Created meeting with bob: ' + room)
   * }).catch(error => {
   *   console.error('Failed to create meeting with bob: ' + error)
   * })
   */
  function createRoom(options) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].optOptions('client.createRoom', 'options', options).optString('alias').optString('name').optString('topic').optString('type').optArray('state').optObject('recording').optObject('powerLevels').optValues('historyVisibility', ['shared', 'invited', 'joined', 'public']).optValues('_visibility', ['private', 'public']).optValues('joinRule', ['open', 'invite']).optValues('guestAccessRule', ['open', 'closed']);

    options = options || {};
    var visibility = options._visibility || 'private';
    var avatar = options.avatar || null;
    var invite;
    var state = [];
    if ('invite' in options) {
      if (Array.isArray(options.invite)) {
        invite = options.invite.map(function (user, index) {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15_matrix_userRegistry__["a" /* toUserId */])('createRoom.invite[' + index + ']', user, activeAuthInfo.serverName);
        });
      } else {
        var matrixId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_15_matrix_userRegistry__["a" /* toUserId */])('createRoom.invite', options.invite, activeAuthInfo.serverName);
        invite = [matrixId];
      }
    }
    if (visibility === 'public' && !options.alias) {
      throw new TypeError('client.createRoom: public rooms require an alias, got "' + options.alias + '"');
    }
    if (options.state) {
      var stateMap = {};
      state = options.state.map(function (stateDesc) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].options('client.createRoom', 'options.state', stateDesc).string('type').optString('stateKey');
        var content = stateDesc.content;
        if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["isObject"])(content)) {
          content = {
            __value__: content
          };
        }
        var ret = {
          type: stateDesc.type,
          content: content
        };
        if (stateDesc.stateKey) {
          ret.state_key = stateDesc.stateKey;
        }
        if (stateMap[ret.type]) {
          if (stateMap[ret.type][ret.state_key || '']) {
            __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'duplicate initial state not allowed');
          } else {
            stateMap[ret.type][ret.state_key || ''] = true;
          }
        } else {
          stateMap[ret.type] = {};
          stateMap[ret.type][ret.state_key || ''] = true;
        }
        return ret;
      });
      if (stateMap['m.room.create']) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'must not contain state: m.room.create');
      } else if (stateMap['m.room.member']) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'must not contain state: m.room.member');
      } else if (stateMap['m.room.name']) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'must not contain state: m.room.name');
      } else if (stateMap['m.room.avatar']) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'must not contain state: m.room.avatar');
      } else if (stateMap['m.room.topic']) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'must not contain state: m.room.topic');
      } else if (stateMap['m.room.join_rules']) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'must not contain state: m.room.join_rules');
      } else if (stateMap['m.room.power_levels']) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'must not contain state: m.room.power_levels');
      } else if (stateMap['com.ericsson.room.type']) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.state', 'must not contain state: com.ericsson.room.type');
      }
    }
    if (avatar) {
      if (!(avatar instanceof __WEBPACK_IMPORTED_MODULE_11_matrix_resources__["a" /* default */])) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('room.createRoom', 'options.avatar', avatar);
        avatar = imageResourceFactory(avatar);
      }
      state.push({
        type: 'm.room.avatar',
        content: {
          url: avatar.resourceUri
        }
      });
    }
    if (options.historyVisibility) {
      state.push({
        type: 'm.room.history_visibility',
        content: {
          history_visibility: options.historyVisibility
        }
      });
    }
    if (options.joinRule) {
      var differentJoinRule = null;
      if (options.joinRule === 'invite' && visibility === 'public') {
        differentJoinRule = 'invite';
      } else if (options.joinRule === 'open' && visibility === 'private') {
        differentJoinRule = 'public';
      }
      if (differentJoinRule) {
        state.push({
          type: 'm.room.join_rules',
          content: {
            join_rule: differentJoinRule
          }
        });
      }
    }
    // Only allow guest access if it is explicitly set to open
    var guestAccessRule = options.guestAccessRule === 'open' ? 'can_join' : 'forbidden';
    state.push({
      type: 'm.room.guest_access',
      content: {
        guest_access: guestAccessRule
      }
    });
    if (options.powerLevels) {
      var isEdit = options.powerLevels instanceof __WEBPACK_IMPORTED_MODULE_18_matrix_powerLevels__["a" /* PowerLevelsEdit */];
      var isReader = options.powerLevels instanceof __WEBPACK_IMPORTED_MODULE_18_matrix_powerLevels__["b" /* PowerLevelsReader */];
      if (!isEdit && !isReader) {
        __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].error('client.createRoom', 'options.powerLevels', 'must be an instance of PowerLevelsEdit or PowerLevelsReader');
      }
      state.push({
        type: 'm.room.power_levels',
        content: options.powerLevels.toRawForServer(activeAuthInfo.serverName)
      });
    }
    var creationContent = {
      c3Content: options.creationContent || null
    };
    if (options.type) {
      creationContent.cctRoomType = options.type;
    }
    var recording = options.recording;
    if (recording) {
      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].options('client.createRoom', 'options.recording', recording).optObject('meta').optObject('mediaServiceId');

      var mediaServiceId = options.mediaServiceId || 'c3-media-service';
      var mediaService = '@' + mediaServiceId + ':' + activeAuthInfo.serverName;
      if (invite) {
        if (invite.indexOf(mediaService) === -1) {
          invite.push(mediaService);
        }
      } else {
        invite = [mediaService];
      }

      creationContent.c3Recording = {
        meta: recording.meta || null
      };
    }
    var lastState;
    // Current order in synapse, might change. listed in synapse/handlers/room.py
    if (options.alias) {
      lastState = { type: 'm.room.aliases' };
    } else if (options.topic) {
      lastState = { type: 'm.room.topic' };
    } else if (options.name) {
      lastState = { type: 'm.room.name' };
    } else if (state.length) {
      lastState = {
        type: state[state.length - 1].type,
        stateKey: state[state.length - 1].state_key
      };
    } else {
      lastState = { type: 'm.room.guest_access' };
    }
    return authed().then(function (authedRequest) {
      return authedRequest.createRoom.post({
        visibility: visibility,
        room_alias_name: options.alias || undefined,
        name: options.name || undefined,
        topic: options.topic || undefined,
        invite: invite,
        initial_state: state,
        creation_content: creationContent
      }).then(function (res) {
        if (!activeAuthInfo) {
          throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('client was no longer authenticated when receiving response');
        }
        return roomRegistry.waitForRoom(res.body.room_id, lastState, invite || []);
      });
    });
  }

  /**
   * Look up and retrieve a room by alias.
   * ##### Errors:
   * - {@link NotFoundError} - The alias does not exist.
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   *
   * @function Client#fetchRoomByAlias
   * @param {RoomAlias} alias - The alias of the room.
   * @returns {Promise<Room, CctError>} - The room.
   */
  function fetchRoomByAlias(alias) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('client.fetchRoomByAlias', 'alias', alias);
    if (!activeAuthInfo) {
      var msg = 'client.fetchRoomByAlias: client needs to be authenticated to get rooms by alias';
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject(new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */](msg));
    }
    var fullAlias = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_matrix_ids__["b" /* toMatrixIdForServer */])('fetchRoomByAlias', alias, activeAuthInfo.serverName, 'alias');
    return authed().then(function (authedRequest) {
      return authedRequest.directory.get(fullAlias).then(function (res) {
        if (!activeAuthInfo) {
          throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('client was no longer authenticated when receiving response');
        }
        return roomRegistry.getOrCreateEmptyRoom(res.body.room_id);
      });
    }).catch(function (error) {
      if (error.name === 'InternalServerError' && alias.indexOf(':') !== -1) {
        var _msg = 'Room alias server not found: \'' + alias.split(':').slice(1).join(':') + '\'';
        throw new __WEBPACK_IMPORTED_MODULE_7_common_errors__["b" /* NotFoundError */](_msg);
      }
      throw error;
    });
  }

  /**
   * Retreive a room by id, and fail if it doesn't exist.
   *
   * If one can be certain that the room id points to a valid room, it is usually
   * better to use {@link Client#getRoom} instead. This method should be used
   * if the room id is received e.g. via user input, and it's required to check
   * if the room exists before trying to join it.
   * ##### Errors:
   * - {@link NotFoundError} - The room does not exist.
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   *
   * @function Client#fetchRoomById
   * @param {RoomId} id - The id of the room.
   * @returns {Promise<Room, CctError>} The room.
   */
  function fetchRoomById(id) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('client.fetchRoomById', 'id', id);
    if (!activeAuthInfo) {
      var msg = 'client.fetchRoomById: client needs to be authenticated to get room by id';
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject(new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */](msg));
    }
    var matrixRoomId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_matrix_ids__["b" /* toMatrixIdForServer */])('fetchRoomById', id, activeAuthInfo.serverName, 'room');
    var room = roomRegistry.getRoom(matrixRoomId);
    if (room) {
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.resolve(room);
    }
    return authedRequest.leaveRoom.params('roomId', matrixRoomId).post().then(function (response) {
      __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(self.tag, 'unexpected successful response when checking if room exists:', response);
      throw new __WEBPACK_IMPORTED_MODULE_7_common_errors__["d" /* UnknownError */]('Failed to check if room exists');
    }, function (error) {
      if (!activeAuthInfo) {
        throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('client was no longer authenticated when receiving response');
      }
      if (error.name === 'NotAllowedError') {
        return roomRegistry.getOrCreateEmptyRoom(matrixRoomId);
      } else {
        throw error;
      }
    });
  }

  /**
   * Get a room by id.
   *
   * This method always returns a room, but the room might be private or
   * nonexistent, in which case any attempt to join the room will fail.
   *
   * @function Client#getRoom
   * @param {RoomId} roomId - The id of the room.
   * @throws {AuthenticationError} If the client is not authenticated.
   * @returns {Room} - The room.
   */
  function getRoom(roomId) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('client.getRoom', 'roomId', roomId);
    if (!activeAuthInfo) {
      throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('client.getRoom: client needs to be authenticated to get rooms by id');
    }
    var matrixRoomId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_matrix_ids__["b" /* toMatrixIdForServer */])('getRoom', roomId, activeAuthInfo.serverName, 'room');
    return roomRegistry.getOrCreateEmptyRoom(matrixRoomId);
  }

  /**
   * Get a user by id. This method will always result in a request to the server,
   * regardless of what information is already available. The request fetches the
   * current name and avatar of the user.
   *
   * If the user does not exist on ther server, the returned promise will be rejected.
   *
   * This method can be used without being authenticated.
   * ##### Errors:
   * - {@link NotFoundError} - The user does not exist.
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   *
   * @function Client#fetchUser
   * @param {UserId} userId - The id of the user to fetch.
   * @returns {Promise.<User>} - The user, or an error if the user doesn't exist.
   */
  function fetchUser(userId) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('client.fetchUser', 'userId', userId);

    if (!activeAuthInfo) {
      var msg = 'client.fetchUser: client needs to be authenticated to fetch user by id';
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject(new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */](msg));
    }

    var matrixUserId = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_17_matrix_ids__["b" /* toMatrixIdForServer */])('fetchUser', userId, activeAuthInfo.serverName, 'user');

    if (userRequests[matrixUserId]) {
      return userRequests[matrixUserId];
    }

    var promise = authed().then(function (authedRequest) {
      return authedRequest.profile.params('userId', matrixUserId).get();
    }).then(function (response) {
      __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].verbose('client', 'fetched user info for ' + matrixUserId + ': ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(response.body));
      if (!activeAuthInfo) {
        throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('client was no longer authenticated when receiving response');
      }

      delete userRequests[matrixUserId];
      var user = userRegistry.getUser(matrixUserId);
      user._update(response.body);
      return user;
    }, function (error) {
      delete userRequests[matrixUserId];
      if (error.name === 'InternalServerError' && userId.indexOf(':') !== -1) {
        var _msg2 = 'userId server not found: \'' + userId.split(':').slice(1).join(':') + '\'';
        throw new __WEBPACK_IMPORTED_MODULE_7_common_errors__["b" /* NotFoundError */](_msg2);
      }
      throw error;
    });
    userRequests[matrixUserId] = promise;
    return promise;
  }

  /**
   * Parses a mxc resource URI. Throws a {@link external:TypeError} if the uri is invalid.
   *
   * @function Client#parseResourceUri
   * @param {MatrixContentUri} uri - The mxc resource URI to parse.
   * @throws {AuthenticationError} If the client is not authenticated.
   * @returns {ImageResource} the parsed resource.
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["prop"])(this, 'parseResourceUri', function (uri) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].string('client.parseResourceUri', 'uri', uri);
    if (!imageResourceFactory) {
      var msg = 'client.parseResourceUri: client needs to be authenticated to parse resource URIs';
      throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */](msg);
    }
    return imageResourceFactory(uri);
  });

  // eslint-disable-next-line jsdoc/require-description-complete-sentence
  /**
   * Uploads media data to the server which can later be references as an {@link ImageResource}.
   *
   * The file argument will be passed directly to the `XMLHttpRequest.send` method, with the
   * exception that if it is a string it will be treated as a data uri and will
   * be parsed and base64 decoded before being uploaded.
   *
   * If a mime type is specified it will always be used. If not, the data uri type or
   * `type` property of the {@link File} or {@link Blob} object will be used, with the last
   * fallback being `'application/octet-stream'`.
   * ##### Errors:
   * - {@link AuthenticationError} - The client must be authenticated to use this method.
   *
   * <i style="color: red;">Privacy warning: Do not pass private user information to this method.</i>
   *
   * @function Client#uploadMedia
   * @param {*} file - The media data that will be uploaded
   * @param {string} [mimeType] - Optional mime type
   * @returns {ImageUpload}
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["prop"])(this, 'uploadMedia', function (file, mimeType) {
    if (typeof file === 'string') {
      var parsed = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["parseDataUri"])(file);
      var buffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["binaryStringToArrayBuffer"])(parsed.binaryString);
      file = new Blob([buffer], {
        type: parsed.mimeType
      });
      mimeType = mimeType || parsed.mimeType;
    }

    if (!mimeType) {
      mimeType = file.type || 'application/octet-stream';
    }

    if (!authedRequest) {
      throw new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */]('not authenticated');
    } else {
      var upload = authedRequest.uploadMedia.header('Content-Type', mimeType).post(file);
      upload.promise = upload.promise.then(function (response) {
        return imageResourceFactory(response.body.content_uri);
      });
      return upload;
    }
  });

  /**
   * All rooms the authenticated user is a member of
   * @readonly
   * @member Client#rooms {Room[]}
   */
  Object.defineProperty(this, 'rooms', {
    enumerable: true,
    get: function get() {
      return roomRegistry.getRooms().slice();
    }
  });

  /**
   * The authentication information for the authenticated user
   * @readonly
   * @member Client#authInfo {AuthInfo}
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["getter"])(this, 'authInfo', function () {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["shallowCopy"])(activeAuthInfo);
  });

  /**
   * The authenticated user, if any
   * @readonly
   * @member Client#user {User}
   */
  Object.defineProperty(this, 'user', {
    enumerable: true,
    get: function get() {
      return user;
    }
  });

  function loadPublicRooms() {
    return authed().then(function (authedRequest) {
      return authedRequest.getPublicRooms.get();
    }).then(function (response) {
      return response.body.chunk.map(function (info) {
        var room = roomRegistry.getOrCreateEmptyRoom(info.room_id);
        room._addPublicInfo(info);
        return room;
      });
    });
  }

  this._handleAccountDataSync = function (events) {
    for (var i in events) {
      var event = events[i];
      __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].verbose('events', 'received account data event:', event);
      this._accountData._set(event.type, event.content);
    }
  };

  this._didChangeSyncStreamState = function (state) {
    __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].verbose('client', 'changed sync stream state: ' + state);
    this._emit('state', state);
  };

  /**
   * Emitted when an {@link Room~Event} is received in any room.
   *
   * @event Client#event
   * @param {Room~Event} event - The event.
   */
  /**
   * Same as {@link Client#event:event}, but listens to a specific {@link EventType}.
   *
   * @event Client#event:&lt;type&gt;
   * @param {Room~Event} event - The event.
   */
  this._onRoomEvent = function (event) {
    this._emit('event:' + event.type, event);
    this._emit('event', event);
  };

  this._onRoomMembership = function (room, membership) {
    this._emit(membership, room, membership);
  };

  this._onRoomCreated = function (room) {
    this._willEmitRoomsEvent = true;
    roomQueries = roomQueries.filter(function (query) {
      return query._handleNewRoom(room);
    });
    setTimeout(function () {
      if (this._willEmitRoomsEvent) {
        this._willEmitRoomsEvent = false;
        this._emit('rooms');
      }
    }.bind(this));
  };

  this._onIncomingCall = function (call) {
    this._emit('call', call);
  };

  this._onIncomingConference = function (conference) {
    this._emit('conference', conference);
  };

  /**
   * Create a room query.
   * @function Client#createRoomQuery
   * @param {Function} mapFunction - The map function of the room query, see {@link RoomQuery}
   * @returns {RoomQuery} - A newly created room query
   */
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["prop"])(this, 'createRoomQuery', function (mapFunction) {
    __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].func('client.createRoomQuery', 'mapFunction', mapFunction);
    var query = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_12_matrix_roomQuery__["a" /* default */], mapFunction);
    roomRegistry.getRooms().forEach(query._handleNewRoom);
    roomQueries.push(query);
    return query;
  });

  this.auth = auth.bind(this);
  this.logout = logout.bind(this);
  this.createRoom = createRoom.bind(this);
  this._loadPublicRooms = loadPublicRooms.bind(this);
  this.getRoom = getRoom.bind(this);
  this.fetchUser = fetchUser.bind(this);
  this.fetchRoomById = fetchRoomById.bind(this);
  this.fetchRoomByAlias = fetchRoomByAlias.bind(this);
  this.setName = setName.bind(this);
  this.setAvatar = setAvatar.bind(this);
  this.setStatus = setStatus.bind(this);
}

Client.prototype = {
  constructor: Client,
  tag: 'client',

  get getUser() {
    throw new Error('client.getUser has been renamed to fetchUser');
  },

  get getRoomByAlias() {
    throw new Error('client.getRoomByAlias has been renamed to fetchRoomByAlias');
  },

  get loadPublicRooms() {
    throw new Error('client.loadPublicRooms has been removed');
  },

  toString: function toString() {
    var userId = this.user ? this.user.id : null;
    return 'client{state=' + this.state + ',user=' + userId + '}';
  },

  /**
   * Account data object that is used to access user scoped account data.
   *
   * @readonly
   * @member Client#accountData {AccountData}
   */
  get accountData() {
    return this._accountData;
  },

  _setAccountData: function _setAccountData(key, value) {
    if (!this._authedRequest) {
      var msg = 'accountData.set: client needs to be authenticated to set account data';
      return __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject(new __WEBPACK_IMPORTED_MODULE_16_matrix_errors__["b" /* AuthenticationError */](msg));
    }
    return this._authedRequest.setAccountData.path(key).put(value);
  }
};

__WEBPACK_IMPORTED_MODULE_4_common_emitter__["a" /* default */].call(Client.prototype);

/**
 * @typedef {string|object} IceServer
 * A STUN or TURN server url, e.g.
 *
 * ```
 * 'stun:stun.example.com'
 * ```
 *
 * or an object with url and credentials, e.g.
 *
 * ```
 * {
 *     urls: 'turn:turn.example.com',
 *     username: 'root',
 *     credential: 'root',
 * }
 * ```
 *
 * @property {string} url - A STUN or TURN server url
 * @property {string} [username] - The username used when accessing the helper server.
 * @property {string} [credential] - The password associated with the username.
 */

/**
 * @typedef {null|'connecting'|'connected'|'disconnected'} ClientConnectionState
 *
 * A string representing the connection state of the client, or null for no active connection.
 */

/**
 * @typedef {string} UserId
 *
 * A string representing a user ID. UserIds may only contain `a-z`, `0-9`, and `_-./`.
 */

/**
 * @typedef {string} RoomId
 *
 * A string representing a room ID.
 */

/**
 * @typedef {string} RoomAlias
 *
 * A string representing a room alias. Aliases may not contain whitespace characters.
 */

/**
 * @typedef {string} EventId
 *
 * A string representing a event ID.
 */

/**
 * @typedef {string} EventType
 *
 * A string representing a specific type of event. e.g. `'cct.call.dynamic.offer'`.
 * Names should follow the Java package naming convention to ensure uniqueness.
 */

/**
 * @callback IceCandidateFilter
 *
 * @param {IceCandidateInfo} info - Information about the ice candidate.
 * @returns {boolean} A truthy value to use the candidate, or false to discard it.
 */

/**
 * Emitted when a new room invite is received.
 * The room will contain additional information, such as {@link Room#invitedBy}.
 * @event Client#invite
 * @param {Room} room - The room that the authenticated user was invited to.
 */

/**
 * Emitted whenever the list of rooms changes
 * @event Client#rooms
 */

/**
 * Emitted when there is an incoming call to any room. Incoming calls are stopped and
 * need to be started with {@link Call#start} before a connection is set up.
 * @event Client#call
 * @param {Call} call - The call object
 */

/**
 * Emitted when the conneciton state of the client is changed
 * @event Client#state
 * @param {ClientConnectionState} newState - The new state of the room
 * @param {ClientConnectionState} oldState - The old state of the room
 */

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_media_webAudioSource__ = __webpack_require__(223);


















/**
 * A class which represents an audio source that is able to playback audio buffers.
 *
 * Audio buffers can be loaded from different sources using the static methods of this class.
 *
 * @class AudioBufferSource
 * @extends WebAudioSource
 * @extends EventEmitter
 * @param {options} options - Options which are passed on to the WebAudioSource constructor.
 */

var AudioBufferSource = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(AudioBufferSource, _EmitterMixin);

  function AudioBufferSource() {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, AudioBufferSource);

    return __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AudioBufferSource.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(AudioBufferSource)).apply(this, arguments));
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(AudioBufferSource, [{
    key: 'play',

    /**
     * Starts playback of a audio buffer. Audio buffers can be loaded using the static
     * methods of {@link AudioBufferSource}.
     *
     * @param {Object} options - An option object.
     * @param {AudioBuffer} options.buffer - The audio buffer to play.
     * @param {number} [options.delay=0] - Delay in seconds before the audio buffer should start playing.
     * @param {number} [options.offset=0] - Offset in seconds at which point the playback should begin.
     * @param {number} [options.duration] - The duration of the playback in seconds.
     *   Defaults to the duration of the entire buffer.
     * @param {boolean} [options.loop=false] - Whether or not the audio buffer should be looped.
     */
    value: function play(options) {
      var _this2 = this;

      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].options('AudioBufferSource.play', 'options', options).instance('buffer', window.AudioBuffer).optNumber('delay').optNumber('offset').optNumber('duration').optBoolean('loop');

      // Stop current playback
      this.halt();

      this._audioSource = this.context.createBufferSource();
      this._audioSource.onended = function () {
        _this2._emit('ended');
      };
      this._audioSource.connect(this.audioDestination);

      var buffer = options.buffer,
          _options$delay = options.delay,
          delay = _options$delay === undefined ? 0 : _options$delay,
          _options$offset = options.offset,
          offset = _options$offset === undefined ? 0 : _options$offset;
      var _options$duration = options.duration,
          duration = _options$duration === undefined ? buffer.duration - offset : _options$duration;


      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug('audio-buffer-source', 'starting ' + (options.loop ? 'looping ' : '') + 'playback ' + ('of ' + buffer.duration + 's clip, at offset ' + offset + 's and duration ' + duration + 's'));
      this._audioSource.buffer = buffer;
      if (options.loop) {
        // this._audioSource.playbackRate.value = 0.5
        this._audioSource.loop = true;
        this._audioSource.loopStart = offset;
        this._audioSource.loopEnd = offset + duration;
        this._audioSource.start(this._audioContext.currentTime + delay, offset);
      } else {
        this._audioSource.start(this._audioContext.currentTime + delay, offset, duration);
      }
      this._startTime = this._audioContext + delay;
    }

    /**
     * Stops the playback of the current buffer. Play can be called again after this method has been called.
     *
     * If no audio has been played yet, calling this method will have no effect.
     */

  }, {
    key: 'halt',
    value: function halt() {
      if (this._audioSource) {
        this._audioSource.onended = null;
        this._audioSource.stop();
        this._audioSource.disconnect();
        this._audioSource = null;
      }
    }

    // Docs in super

  }, {
    key: 'stop',
    value: function stop() {
      this.halt();
      __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_get___default()(AudioBufferSource.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(AudioBufferSource.prototype), 'stop', this).call(this);
    }

    /**
     * Decodes an array buffer of audio data into an audio buffer that can be
     * played back in an {@link AudioBufferSource}.
     *
     * @param  {ArrayBuffer} arrayBuffer - An array buffer filled with encoded audio data.
     * @param  {AudioContext} [context] - An optional audio context to be used for the decoding. Of no
     *   context is specified one will be created if needed.
     * @returns {Promise<AudioBuffer>} A promise for an audio buffer.
     */

  }], [{
    key: 'decodeArrayBuffer',
    value: function decodeArrayBuffer(arrayBuffer, context) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].instance('AudioBufferSource.decodeArrayBuffer', 'arrayBuffer', arrayBuffer, window.ArrayBuffer);
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].optInstance('AudioBufferSource.decodeArrayBuffer', 'context', context, __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["AudioContext"]);
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        var shouldReleaseContext = false;
        if (!context) {
          shouldReleaseContext = true;
          context = __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["audioContextUtil"].get();
        }
        context.decodeAudioData(arrayBuffer, function (buffer) {
          if (shouldReleaseContext) {
            __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["audioContextUtil"].release();
          }
          resolve(buffer);
        }, function (error) {
          if (shouldReleaseContext) {
            __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["audioContextUtil"].release();
          }
          reject(error);
        });
      });
    }

    /**
     * Decodes a blob of audio data into an audio buffer that can be
     * played back in an {@link AudioBufferSource}.
     *
     * @param  {Blob|File} blob - A blob filled with encoded audio data.
     * @param  {AudioContext} [context] - An optional audio context to be used for the decoding. Of no
     *   context is specified one will be created if needed.
     * @returns {Promise<AudioBuffer>} A promise for an audio buffer.
     */

  }, {
    key: 'decodeBlob',
    value: function decodeBlob(blob, context) {
      var _this3 = this;

      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].optInstance('AudioBufferSource.decodeBlob', 'blob', blob, Blob);
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].optInstance('AudioBufferSource.decodeBlob', 'context', context, __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["AudioContext"]);
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["blobToArrayBuffer"])(blob).then(function (data) {
        return _this3.decodeArrayBuffer(data, context);
      });
    }

    /**
     * Decodes a binary string of audio data into an audio buffer that can be
     * played back in an {@link AudioBufferSource}.
     *
     * @param  {string} binaryString - A binary string filled with encoded audio data.
     * @param  {AudioContext} [context] - An optional audio context to be used for the decoding. Of no
     *   context is specified one will be created if needed.
     * @returns {Promise<AudioBuffer>} A promise for an audio buffer.
     */

  }, {
    key: 'decodeBinaryString',
    value: function decodeBinaryString(binaryString, context) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].string('AudioBufferSource.decodeBinaryString', 'binaryString', binaryString);
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].optInstance('AudioBufferSource.decodeBinaryString', 'context', context, __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["AudioContext"]);
      var arrayBuffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["binaryStringToArrayBuffer"])(binaryString);
      return this.decodeArrayBuffer(arrayBuffer, context);
    }

    /**
     * Decodes a data uri of audio data into an audio buffer that can be
     * played back in an {@link AudioBufferSource}.
     *
     * @param  {string} dataUri - A data uri filled with encoded audio data.
     * @param  {AudioContext} [context] - An optional audio context to be used for the decoding. Of no
     *   context is specified one will be created if needed.
     * @returns {Promise<AudioBuffer>} A promise for an audio buffer.
     */

  }, {
    key: 'decodeDataUri',
    value: function decodeDataUri(dataUri, context) {
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].string('AudioBufferSource.decodeDataUri', 'dataUri', dataUri);
      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].optInstance('AudioBufferSource.decodeDataUri', 'context', context, __WEBPACK_IMPORTED_MODULE_11_webrtc_utils__["AudioContext"]);
      try {
        var parsed = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["parseDataUri"])(dataUri);
        return this.decodeBinaryString(parsed.binaryString, context);
      } catch (error) {
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject(new Error('Data uri decoding failed, ' + error.message));
      }
    }
  }]);

  return AudioBufferSource;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_12_media_webAudioSource__["a" /* default */]));

/* harmony default export */ __webpack_exports__["a"] = (AudioBufferSource);

/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_webAudioFilter__ = __webpack_require__(222);











/**
 * A utility for measuring the audio level of a MediaSource.
 *
 * @example <caption>Example of using the AudioMeter.</caption>
 * var microphone = new cct.DeviceSource({audio:true})
 * var meter = new cct.AudioMeter()
 *
 * microphone.connect(meter)
 * meter.on('filtered', function (filtered) {
 *    //NOTE: This event will be emitted VERY frequently!
 *    //Consider reading meter.filtered or meter.raw instead.
 * })
 *
 * @class AudioMeter
 * @extends WebAudioFilter
 * @extends EventEmitter
 */

var AudioMeter = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(AudioMeter, _EmitterMixin);

  function AudioMeter(options) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, AudioMeter);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AudioMeter.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(AudioMeter)).call(this, options));

    _this._raw = 0.0;
    _this._filtered = 0.0;
    _this._processAudio = _this._processAudio.bind(_this);
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(AudioMeter, [{
    key: 'onAudioSource',
    value: function onAudioSource(source, destination) {
      if (source) {
        this._processor = this.context.createScriptProcessor(2048, 1, 1);
        this._processor.onaudioprocess = this._processAudio;
        this._processor.connect(destination); // Should not be needed, but it is.
        source.connect(this._processor);
        source.connect(destination); // Otherwise we pass on silence
      }

      this._raw = 0.0;
      this._filtered = 0.0;
      this._emit('filtered', this._filtered);
      this._emit('raw', this._raw);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'audio-meter{raw=' + this.raw + ',filtered=' + this.filtered + '}';
    }

    /**
     * Emitted when the raw audio level has changed.
     * @event AudioMeter#raw
     * @param {number} raw - The raw audio level.
     */

    /**
     * The raw audio level.
     *
     * @readonly
     * @member AudioMeter#raw {number}
     */

  }, {
    key: '_processAudio',
    value: function _processAudio(event) {
      var buffer = event.inputBuffer.getChannelData(0);
      var rms = AudioMeter._rms(buffer);

      this._raw = rms;
      this._filtered = AudioMeter._filter(this._filtered, rms);

      this._emit('filtered', this._filtered);
      this._emit('raw', this._raw);
    }

    // Root of mean of squares

  }, {
    key: 'raw',
    get: function get() {
      return this._raw;
    }

    /**
     * Emitted when the filtered audio level has changed.
     * @event AudioMeter#filtered
     * @param {number} filtered - The filtered audio level.
     */

    /**
     * The filtered audio level. This represents the "average"
     * audio level over a period of time, filtering out
     * sudden changes and spikes.
     *
     * @readonly
     * @member AudioMeter#filtered {number}
     */

  }, {
    key: 'filtered',
    get: function get() {
      return this._filtered;
    }
  }], [{
    key: '_rms',
    value: function _rms(buffer) {
      var count = buffer.length;
      var sumOfSquares = 0;
      buffer.forEach(function (val) {
        sumOfSquares += val * val;
      });
      var meanOfSquares = sumOfSquares / count;
      var rootMeanSquare = Math.sqrt(meanOfSquares);
      return rootMeanSquare;
    }

    // Low pass filter

  }, {
    key: '_filter',
    value: function _filter(current, next) {
      return 0.95 * current + 0.05 * next;
    }
  }]);

  return AudioMeter;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_6_media_webAudioFilter__["a" /* default */]));

/* harmony default export */ __webpack_exports__["a"] = (AudioMeter);

/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaSource__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_webrtc_utils__ = __webpack_require__(66);













var TAG = 'audiomixer';

/**
 * A media node that mixes the audio tracks of all input streams and ouputs a single audio stream.
 *
 * @class AudioMixer
 * @extends MediaSource
 */

var AudioMixer = function (_MediaSource) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(AudioMixer, _MediaSource);

  function AudioMixer() {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, AudioMixer);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (AudioMixer.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(AudioMixer)).call(this));

    _this._inputs = new __WEBPACK_IMPORTED_MODULE_8_media_mediaNode__["b" /* InputMap */]({
      parent: _this,
      onStream: _this._onStream.bind(_this)
    });
    _this._streamSources = {};
    return _this;
  }

  /**
   * An input map for all inputs to the node.
   *
   * @member {InputMap} AudioMixer#inputs
   */


  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(AudioMixer, [{
    key: '_hasInputStreams',
    value: function _hasInputStreams() {
      return [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(this.inputs.values())).some(function (input) {
        return input.stream;
      });
    }
  }, {
    key: '_onStream',
    value: function _onStream(key, stream, oldStream) {
      if (oldStream) {
        this._streamSources[key].disconnect();
        delete this._streamSources[key];
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].info(TAG, 'Stream removed:', key);
        if (this._dest && !this._hasInputStreams()) {
          this.setStream(null);
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].info(TAG, 'Destroying output');
          this._stereoPanner.disconnect();
          this._stereoPanner = null;
          this._dest = null;
          __WEBPACK_IMPORTED_MODULE_9_webrtc_utils__["audioContextUtil"].release();
          this._audioContext = null;
        }
      }

      if (stream) {
        if (!this._dest) {
          __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].info(TAG, 'Creating output');
          this._audioContext = __WEBPACK_IMPORTED_MODULE_9_webrtc_utils__["audioContextUtil"].get();
          this._dest = this._audioContext.createMediaStreamDestination();
          this._stereoPanner = this._audioContext.createStereoPanner();
          this._stereoPanner.connect(this._dest);
          this.setStream(this._dest.stream);
        }
        var streamSource = this._audioContext.createMediaStreamSource(stream);
        streamSource.connect(this._stereoPanner);
        this._streamSources[key] = streamSource;
        __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].info(TAG, 'Stream added:', key);
      }
    }
  }, {
    key: 'inputs',
    get: function get() {
      return this._inputs;
    }
  }]);

  return AudioMixer;
}(__WEBPACK_IMPORTED_MODULE_7_media_mediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (AudioMixer);

/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DeviceInfo */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_media_muteFilter__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_media_passthrough__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_media_userMediaSource__ = __webpack_require__(221);

















var TAG = 'device-source';

/**
 * Contains information about a media device, returned from {@link DeviceSource.enumerateDevices}.
 *
 * Instances can be passed as `device` media constaints to {@link DeviceSource} in order
 * to request a stream from a specific device.
 *
 * @class DeviceInfo
 * @abstract
 */
var DeviceInfo = function () {
  function DeviceInfo(priv, info) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, DeviceInfo);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["assertPriv"])('DeviceInfo', priv);
    this.deviceId = info.deviceId || info._deviceId || null;
    this.groupId = info.groupId || info._groupId || null;
    this.kind = info.kind || info._kind || null;
    this.label = info.label || info._label || null;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(DeviceInfo, [{
    key: 'toString',
    value: function toString() {
      var deviceId = this.deviceId;
      if (deviceId && deviceId.length > 8) {
        deviceId = deviceId.slice(0, 8) + '...';
      }
      var groupId = this.groupId;
      if (groupId && groupId.length > 8) {
        groupId = groupId.slice(0, 8) + '...';
      }
      return 'deviceInfo{kind=' + this.kind + ',deviceId=' + deviceId + ',groupId=' + groupId + ',label="' + this.label + '"}';
    }

    /**
     * An id that uniquely identifies the device.
     *
     * @member {string} DeviceInfo#deviceId
     */

    /**
     * An id that uniquely identifies a group of devices.
     *
     * Even though there might be only one piece hardware, e.g. a webcam, each of the the different
     * capabilities of the hardware will be represented as one device, e.g. audio input and video input.
     * Using the `groupId` it is then possible to known which devices originate from the same physical device.
     *
     * @member {string} DeviceInfo#groupId
     */

    /**
     * The device type of media that the device can deliver.
     *
     * @member {'videoinput'|'audioinput'} DeviceInfo#kind
     */

    /**
     * A human-readable description of the device, e.g. "External USB Webcam".
     *
     * Some browsers will hide the label by returning an empty string until the user has allowed
     * a user media request on the page. Currently Firefox is the only browser that does this.
     * A workaround for this is to first create a {@link DeviceSource}, wait until the user
     * media request has been accepted, and then enumerate device and stop the source. When creating
     * a second {@link DeviceSource} for a specific device, the user media request should be skipped.
     *
     * @member {'string'} DeviceInfo#label
     */

  }]);

  return DeviceInfo;
}();

function convertDeviceConstraints(mediaConstraints) {
  if (mediaConstraints && mediaConstraints.device && !mediaConstraints.deviceId) {
    var device = mediaConstraints.device;

    var info = null;
    if (device.ideal) {
      info = device.ideal;
      mediaConstraints.deviceId = { ideal: info.deviceId };
    } else if (device.exact) {
      info = device.exact;
      mediaConstraints.deviceId = { exact: info.deviceId };
    } else {
      info = device;
      mediaConstraints.deviceId = info.deviceId;
    }
    delete mediaConstraints.device;
    __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].instance('DeviceSource constructor', 'device', info, DeviceInfo);
  }
}

/**
 * A media source that streams from user media devices.
 *
 * @class DeviceSource
 * @extends ConnectMixin
 * @extends EventEmitter
 *
 * @param {Object} [constraints={ audio:true, video:true }] - Constraints passed to getUserMedia as defined by
 *  {@link http://w3c.github.io/mediacapture-main/getusermedia.html#methods-4 getUserMedia}.
 *  If the paramater is omitted a default configuration with both audio and video will be used.
 *
 * @param {boolean|Object} [constraints.audio=true] - Set to `true` if audio is desired, or a
 *  {@link http://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints MediaTrackConstraints}
 *  object if more detailed constraints is required.
 *
 * @param {boolean|Object} [constraints.video=true] - Set to `true` if video is desired, or a
 *  {@link http://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaTrackConstraints MediaTrackConstraints}
 *  object if more detailed configuration is required.
 *
 * @see {@link http://w3c.github.io/mediacapture-main/getusermedia.html#h-capabilities video configuration}
 */

var DeviceSource = function (_MediaNode$connectMix) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(DeviceSource, _MediaNode$connectMix);

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(DeviceSource, null, [{
    key: 'enumerateDevices',


    /**
     * Returns a list of media devices that can be passed on to {@link DeviceSource} media constraints.
     *
     * This method will throw an error if the browser if not capable of enumerating media devices. Browser
     * support should be tested using {@link DeviceSource.canEnumerateDevices}.
     *
     * Currently only `'videoinput'` and `'audioinput'` devices are included in the list. Chrome
     * does supports using `'audiooutput'` devices to select the playback device for HTML media elements,
     * but this is not yet exposed in this library. This will most likely be added in the future.
     *
     * @example <caption>Listing all available devices</caption>
     * cct.DeviceSource.enumerateDevices().then(deviceList => {
     *   console.log(`Available devices:\n${deviceList.join('\n')}`)
     * }).catch(error => {
     *   console.error(`Failed to enumerate devices, ${error}`)
     * })
     *
     * @example <caption>Requesting a specific device</caption>
     * let selectedVideoDevice = deviceList[selectedIndex]
     * let videoSource = new cct.DeviceSource({
     *   video: {
     *     device: selectedVideoDevice,
     *   },
     * })
     *
     * @returns {Promise<Array<DeviceInfo>>} Promise for a list of device desciptions.
     */
    value: function enumerateDevices() {
      if (!this.canEnumerateDevices) {
        throw new Error('Device enumeration is not supported. Check .canEnumerateDevices before calling');
      }
      return navigator.mediaDevices.enumerateDevices().then(function (list) {
        return list.map(function (info) {
          return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["priv"])(DeviceInfo, info);
        }).filter(function (info) {
          return info.kind !== 'audiooutput';
        });
      });
    }
  }, {
    key: 'canEnumerateDevices',

    /**
     * Whether the current browser supports device enumeration with {@link DeviceSource.enumerateDevices}.
     *
     * @example
     * if (cct.DeviceSource.canEnumerateDevices) {
     *   cct.DeviceSource.enumerateDevices().then(...)
     * } else {
     *   // Device enumeration is not supported
     * }
     *
     * @member {boolean} DeviceSource.canEnumerateDevices
     */
    get: function get() {
      return !!navigator.mediaDevices && !!navigator.mediaDevices.enumerateDevices;
    }
  }]);

  function DeviceSource() {
    var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { audio: true, video: true };

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, DeviceSource);

    var _this = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (DeviceSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(DeviceSource)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["registerInstance"])('deviceSource', _this);

    constraints = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["shallowCopy"])(constraints);
    constraints.video = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["shallowCopy"])(constraints.video) || undefined;
    constraints.audio = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["shallowCopy"])(constraints.audio) || undefined;

    convertDeviceConstraints(constraints.audio);
    convertDeviceConstraints(constraints.video);

    _this._source = new __WEBPACK_IMPORTED_MODULE_12_media_userMediaSource__["a" /* default */]({ constraints: constraints });
    _this._source.promise.then(function (stream) {
      _this._emit('stream', stream);
      _this._clearListeners();
    }, function (error) {
      _this._emit('error', error);
      _this._clearListeners();
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(TAG, 'unexpected error in DeviceSource: ' + error);
    });

    _this._muteFilter = new __WEBPACK_IMPORTED_MODULE_10_media_muteFilter__["a" /* default */]();
    _this._output = new __WEBPACK_IMPORTED_MODULE_11_media_passthrough__["a" /* default */]();
    _this._muteFilter.connect(_this._output);
    _this._source.connect(_this._muteFilter);
    return _this;
  }

  /**
   * Emitted when the stream has been acquired.
   *
   * The node will only ever emit one of the `stream` and `error` events, and only once.
   *
   * @event DeviceSource#stream
   * @param {MediaStream} stream - The media stream, will never be null.
   */

  /**
   * Emitted if a stream could not be acquired.
   *
   * The node will only ever emit one of the `stream` and `error` events, and only once.
   *
   * For a list of possible errors, see {@link DeviceSource#error}.
   *
   * @event DeviceSource#error
   * @param {CctError} error - The error.
   */

  /**
   * Output which will forward a stream with a single video track.
   *
   * @readonly
   * @member {MediaNodeOutput} DeviceSource#output
   */


  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(DeviceSource, [{
    key: 'stop',


    /**
     * Stops the source and cleans up all resources. This has to be called once the source
     * is no longer used in order to clean up resources.
     *
     * If an error happened there is no need to call this function, although calling it will have no effect.
     */
    value: function stop() {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["unregisterInstance"])('deviceSource', this);
      return this._source.stop();
    }
  }, {
    key: 'output',
    get: function get() {
      return this._output;
    }

    /**
     * A promise that is either resolved to a media stream or rejected with an error.
     *
     * For a list of possible errors, see {@link DeviceSource#error}.
     *
     * @readonly
     * @member {Promise<MediaStream,CctError>} DeviceSource#promise
     */

  }, {
    key: 'promise',
    get: function get() {
      return this._source.promise;
    }

    /**
     * An error explaining why the stream could not be acquired, if that was the case.
     *
     * All error types will have an additional `reason` property which is the error from
     * the underlying WebRTC implementation.
     *
     * Errors:
     *  - {@link NotAllowedError} - The user denied the request to access media devices.
     *  - {@link OverconstrainedError} - The media constraints set could not be satisfied.
     *  - {@link NotFoundError} - Devices of the requested type are not present.
     *
     * @readonly
     * @member {?CctError} DeviceSource#error
     */

  }, {
    key: 'error',
    get: function get() {
      return this._source.error;
    }

    /**
     * The current output stream.
     *
     * @readonly
     * @member {?MediaStream} DeviceSource#stream
     */

  }, {
    key: 'stream',
    get: function get() {
      return this._source.stream;
    }

    /**
     * Mute property as documented in {@link MuteFilter#mute}.
     *
     * @member {Object} DeviceSource#mute
     */

  }, {
    key: 'mute',
    get: function get() {
      return this._muteFilter.mute;
    },
    set: function set(value) {
      this._muteFilter.mute = value;
    }
  }, {
    key: 'sink',
    set: function set(sink) {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(TAG, 'deviceSource.sink is removed, just connect directly to the sink instead');
    }
  }]);

  return DeviceSource;
}(__WEBPACK_IMPORTED_MODULE_9_media_mediaNode__["a" /* default */].connectMixin());

/* harmony default export */ __webpack_exports__["a"] = (DeviceSource);


__WEBPACK_IMPORTED_MODULE_7_common_emitter__["a" /* default */].call(DeviceSource.prototype);

/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_mediaSink__ = __webpack_require__(153);













var TAG = 'recorder';
var MILLISECONDS_PER_CHUNK = 100;

var InternalMediaRecorder = function () {
  function InternalMediaRecorder(options) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, InternalMediaRecorder);

    this._mediaRecorder = new window.MediaRecorder(options.stream, options.mediaRecorderOptions);
    this._stopped = false;

    this._onData = options.onData;

    this._onDataAvailable = this._onDataAvailable.bind(this);
    this._onStopped = this._onStopped.bind(this);
    this._onWarning = this._onWarning.bind(this);
    this._onError = this._onError.bind(this);
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(InternalMediaRecorder, [{
    key: '_onDataAvailable',
    value: function _onDataAvailable(_ref) {
      var data = _ref.data;

      if (data && data.size > 0) {
        this._chunks.push(data);
      }
    }
  }, {
    key: '_onStopped',
    value: function _onStopped(event) {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, 'Recording stopped');

      this._onData(new Blob(this._chunks, this._mimeType));

      this._mediaRecorder.removeEventListener('dataavailable', this._onDataAvailable);
      this._mediaRecorder.removeEventListener('stop', this._onStopped);
      this._mediaRecorder.removeEventListener('warning', this._onWarning);
      this._mediaRecorder.removeEventListener('error', this._onError);

      delete this._chunks;
      delete this._mediaRecorder;
    }
  }, {
    key: '_onWarning',
    value: function _onWarning(error) {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(TAG, 'MediaRecorder error:', error);
    }
  }, {
    key: '_onError',
    value: function _onError(error) {
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(TAG, 'MediaRecorder warning:', error);
    }
  }, {
    key: 'start',
    value: function start() {
      if (this.stopped) {
        throw new Error('Only allowed to use InternalMediaRecorder once');
      }
      this._mediaRecorder.addEventListener('dataavailable', this._onDataAvailable);
      this._mediaRecorder.addEventListener('stop', this._onStopped);
      this._mediaRecorder.addEventListener('warning', this._onWarning);
      this._mediaRecorder.addEventListener('error', this._onError);

      this._chunks = [];

      this._mediaRecorder.start(MILLISECONDS_PER_CHUNK);
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (this.stopped) {
        throw new Error('Only allowed to use InternalMediaRecorder once');
      }
      this.stopped = true;
      this._mediaRecorder.stop();
    }
  }]);

  return InternalMediaRecorder;
}();

/**
 * A recorder media sink that uses the built-in browser recoring API:s to produce media files.
 *
 * The recorder simply needs to be connected to by a media node, and will produce a new recording any time
 * the stream changes.
 *
 * @class Recorder
 * @extends MediaSink
 * @extends EventEmitter
 * @param {Object} [options] - Optional options object.
 * @param {number} [options.audioBitsPerSecond] - Audio recording bitrate, defaults to the browser default.
 * @param {number} [options.videoBitsPerSecond] - Video recording bitrate, defaults to the browser default.
 * @param {string} [options.mimeType='video/webm'] - The desired mime type of the recording. The type needs
 *   to be supported by the browser.
 */


var Recorder = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(Recorder, _EmitterMixin);

  function Recorder(options) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, Recorder);

    var _this = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (Recorder.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(Recorder)).call(this));

    if (options) {
      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].options('Recorder constructor', 'options', options).optNumber('audioBitsPerSecond').optNumber('videoBitsPerSecond').optString('mimeType');
      if (options.audioBitsPerSecond <= 0) {
        __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].error('Recorder constructor', 'options.audioBitsPerSecond', 'be greater than 0');
      }
      if (options.videoBitsPerSecond <= 0) {
        __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].error('Recorder constructor', 'options.videoBitsPerSecond', 'be greater than 0');
      }
      _this._mediaRecorderOptions = {
        mimeType: options.mimeType || 'video/webm',
        audioBitsPerSecond: options.audioBitsPerSecond,
        videoBitsPerSecond: options.videoBitsPerSecond
      };
    }
    return _this;
  }

  /**
   * Emitted whenever a recording has been completed.
   *
   * @event Recorder#blob
   * @param {external:Blob} blob - The resulting file.
   */

  // eslint-disable-next-line
  /**
   * @private
   */


  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(Recorder, [{
    key: 'onStream',
    value: function onStream(stream) {
      var _this2 = this;

      if (this._mediaRecorder) {
        this._mediaRecorder.stop();
        this._mediaRecorder = null;
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, 'Stop recording');
      }

      if (!stream) {
        return;
      }

      this._mediaRecorder = new InternalMediaRecorder({
        onData: function onData(blob) {
          return _this2._emit('blob', blob);
        },
        stream: stream,
        mediaRecorderOptions: this._mediaRecorderOptions
      });
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, 'Start recording');
      this._mediaRecorder.start();
    }
  }]);

  return Recorder;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_8_media_mediaSink__["a" /* default */]));

/* harmony default export */ __webpack_exports__["a"] = (Recorder);

/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_media_chromeScreenSource__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_media_firefoxScreenSource__ = __webpack_require__(219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_media_temasysScreenSource__ = __webpack_require__(283);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_media_muteFilter__ = __webpack_require__(180);














var WebRTCPlugin = __WEBPACK_IMPORTED_MODULE_10_webrtc_utils__["AdapterJS"].WebRTCPlugin;








var TAG = 'screen-source';
var C3_EXTENSTION_ID = 'epajpkbdigdpepgncdpmilaoamkjgoah';

var availableImplementations = ['chrome', 'firefox', 'temasys', null];

// Non-null if implementaion is set by the application, otherwise default is calculated below
var screenSharingImplementation = null;

function getScreenSharingImplementation() {
  if (!screenSharingImplementation) {
    if (__WEBPACK_IMPORTED_MODULE_9_common_utils__["isChrome"]) {
      return 'chrome';
    } else if (__WEBPACK_IMPORTED_MODULE_9_common_utils__["isFirefox"]) {
      return 'firefox';
    } else if (WebRTCPlugin && WebRTCPlugin.plugin && WebRTCPlugin.plugin.HasScreensharingFeature) {
      return 'temasys';
    }
  }
  return null;
}

function getScreenSharingConstructor() {
  var implementation = getScreenSharingImplementation();
  if (implementation === 'chrome') {
    return __WEBPACK_IMPORTED_MODULE_11_media_chromeScreenSource__["a" /* default */];
  } else if (implementation === 'firefox') {
    return __WEBPACK_IMPORTED_MODULE_12_media_firefoxScreenSource__["a" /* default */];
  } else if (implementation === 'temasys') {
    return __WEBPACK_IMPORTED_MODULE_13_media_temasysScreenSource__["a" /* default */];
  } else {
    throw new Error('Screen sharing is not supported');
  }
}

/**
 * @typedef {'screen'|'window'|'application'} ScreenSharingType
 *
 * A string representing a screen sharing type, where `'screen'` is the sharing of an entire physical
 * screen, and `'window'` and `'application'` are sharing specific application windows.
 *
 * The `'application'` type is so far only available in Firefox. The difference between window and
 * application is that application will show all application windows at once, while window only shows
 * a single window. e.g. only a single Firefox window or all open Firefox windows.
 */

/**
 * A media source that streams a screen or an application window.
 *
 * In Chrome a browser extension is required for the screen sharing to work. Currently a custom
 * signaling protocol is used, and a specific extension is required. Ask `patrik.oldsberg@ericsson.com`
 * for more info.
 *
 * In Firefox it's enough for the page origin to be whitelisted. This can be done either by contacting
 * Mozilla, or using an extension.
 *
 * @class ScreenSource
 * @extends ConnectMixin
 * @extends EventEmitter
 *
 * @param {Object} options - Options object.
 * @param {string} options.chromeExtensionId - The id of the chrome extension to use.
 * @param {ScreenSharingType} [options.type='window'] - The screen sharing type to use. In Chrome this will
 * default to both screen and window, letting the user select either one.
 * @param {Object} [options.video] - Constraints for the video, defaults to max resolution and no
 *   framerate limit.
 */

var ScreenSource = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(ScreenSource, _EmitterMixin);

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(ScreenSource, null, [{
    key: 'enumerateSources',


    /**
     * Returns a list of possible screen sharing sources that can be passed to {@link ScreenSource} media constraints.
     *
     * This method will throw an error if the browser if not capable of enumerating sources. Browser
     * support should be tested using {@link ScreenSource.canEnumerateSources}.
     *
     * Currently the only browsers that support source enumeration are Internet Explorer and Safari with
     * the screen sharing Temasys plugin.
     *
     * @example <caption>Listing all available sources</caption>
     * cct.ScreenSource.enumerateSources().then(sourceList => {
     *   console.log(`Available sources:\n${sourceList.join('\n')}`)
     * }).catch(error => {
     *   console.error(`Failed to enumerate sources, ${error}`)
     * })
     *
     * @example <caption>Requesting a specific source</caption>
     * let selectedSource = sourceList[selectedIndex]
     * let videoSource = new cct.ScreenSource({
     *   video: {
     *     source: selectedSource,
     *   },
     * })
     *
     * @returns {Promise<Array<ScreenSourceInfo>>} Promise for a list of source desciptions.
     */
    value: function enumerateSources() {
      if (!this.canEnumerateSources) {
        throw new Error('Source enumeration is not supported. Check .canEnumerateSources before calling');
      }
      var Constructor = getScreenSharingConstructor();
      return Constructor.enumerateSources();
    }
  }, {
    key: 'implementation',

    /**
     *
     * @param {'chrome'|'firefox'|'temasys'|null} implementation - The implementation to use.
     */
    set: function set(implementation) {
      __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].values('ScreenSource.implementation', 'implementation', implementation, availableImplementations);
      screenSharingImplementation = implementation;
    }

    /**
     * The screen sharing implementation that is currently in use. Defaults to the current browser based
     * on user agent detection.
     *
     * The application may change the implementation if needed, but only {@link ScreenSource}s and related
     * calls that are made after the implementation is updated will be affected.
     *
     * If this is accessed close to the page load the application should first wait for {@link cct.webRtcReady}.
     *
     * @member {'chrome'|'firefox'|'temasys'|null} ScreenSource.implementation
     */
    ,
    get: function get() {
      return getScreenSharingImplementation();
    }

    /**
     * Whether screen sharing is available. This is identical to checking if the screen sharing implementation
     * is null, but makes the application code a bit more readable.
     *
     * If this is accessed close to the page load the application should first wait for {@link cct.webRtcReady}.
     *
     * @member {boolean} ScreenSource.isAvailable
     */

  }, {
    key: 'isAvailable',
    get: function get() {
      return !!screenSharingImplementation;
    }

    /**
     * Whether the current browser supports source enumeration with {@link ScreenSource.enumerateSources}.
     *
     * If this is accessed close to the page load the application should first wait for {@link cct.webRtcReady}.
     *
     * @example
     * if (cct.ScreenSource.canEnumerateSources) {
     *   cct.ScreenSource.enumerateSources().then(...)
     * } else {
     *   // Source enumeration is not supported
     * }
     *
     * @member {boolean} ScreenSource.canEnumerateSources
     */

  }, {
    key: 'canEnumerateSources',
    get: function get() {
      var Constructor = getScreenSharingConstructor();
      return !!Constructor.canEnumerateSources;
    }
  }]);

  function ScreenSource() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, ScreenSource);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ScreenSource.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ScreenSource)).call(this));

    __WEBPACK_IMPORTED_MODULE_7_common_argCheck__["a" /* default */].optOptions('ScreenSource constructor', 'options', options).optString('chromeExtensionId').optString('type');

    options = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["shallowCopy"])(options);

    options.chromeExtensionId = options.chromeExtensionId ? options.chromeExtensionId : C3_EXTENSTION_ID;
    options.video = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["shallowCopy"])(options.video) || undefined;
    options.audio = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["shallowCopy"])(options.audio) || undefined;

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["registerInstance"])('screenSource', _this);

    var ScreenSharingImplementationConstructor = getScreenSharingConstructor();
    _this._screenSource = new ScreenSharingImplementationConstructor(options);
    _this._muteFilter = new __WEBPACK_IMPORTED_MODULE_15_media_muteFilter__["a" /* default */]();

    _this._screenSource.connect(_this._muteFilter);

    _this._promise = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.all([_this._screenSource.promise, _this._audioSource && _this._audioSource.promise]);
    _this._promise.then(function (stream) {
      _this._emit('stream', stream);
      _this._clearListeners('error');
      _this._clearListeners('stream');
    }, function (error) {
      _this.stop();
      _this._emit('error', error);
      _this._clearListeners('error');
      _this._clearListeners('stream');
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'unexpected error in ScreenSource: ' + error);
    });
    return _this;
  }

  /**
   * Emitted when the stream has been acquired.
   *
   * The node will only ever emit one of the `stream` and `error` events, and only once.
   *
   * @event ScreenSource#stream
   * @param {MediaStream} stream - The media stream, will never be null.
   */

  /**
   * Emitted if a stream could not be acquired.
   *
   * The node will only ever emit one of the `stream` and `error` events, and only once.
   *
   * For a list of possible errors, see {@link ScreenSource#error}.
   *
   * @event ScreenSource#error
   * @param {CctError} error - The error.
   */

  /**
   * Output which will forward a stream with a single video track.
   *
   * @readonly
   * @member {MediaNodeOutput} ScreenSource#output
   */


  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(ScreenSource, [{
    key: 'stop',


    /**
     * Stops the source and cleans up all resources. This has to be called once the source
     * is no longer used in order to clean up resources.
     *
     * If an error happened there is no need to call this function, although calling it will have no effect.
     */
    value: function stop() {
      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["unregisterInstance"])('screenSource', this);
      return this._screenSource.stop();
    }
  }, {
    key: 'output',
    get: function get() {
      return this._muteFilter.output;
    }

    /**
     * A promise that is resolved to the stream as soon as it is available, or rejected
     * with an error.
     *
     * For a list of possible errors, see {@link ScreenSource#error}.
     *
     * @readonly
     * @member ScreenSource#promise {Promise<MediaStream,CctError>} ScreenSource#promise
     */

  }, {
    key: 'promise',
    get: function get() {
      return this._promise;
    }

    /**
     * An error explaining why the stream could not be acquired, if that was the case.
     *
     * All error types will have an additional `reason` property which is the error from
     * the underlying WebRTC implementation.
     *
     * Errors:
     *  - {@link NotAllowedError} - The user denied the request to share the screen.
     *  - {@link OverconstrainedError} - The media constraints set could not be satisfied.
     *  - {@link NotFoundError} - No screen sharing implementation could be found. The reason
     *  depends on which browser is used.
      *    - Chrome - A compatible extension that provides screen sharing must be installed.
     *    - Firefox - Screen sharing is not allowed on the current origin.
     *    - Internet Explorer - A plugin with screen sharing capabilities must to be installed.
     *    - Safari - A plugin with screen sharing capabilities must to be installed.
     *
     *
     * The Firefox behaviour might seem odd, as one would expect a {@link NotAllowedError} instead.
     * The reason for using a {@link NotFoundError} is to stay consistent with other browsers,
     * since the usual method for allowing screen sharing on an origin is by installing an extension.
     *
     * @readonly
     * @member {?CctError} ScreenSource#error
     */

  }, {
    key: 'error',
    get: function get() {
      if (this._audioSource) {
        return this._screenSource.error || this._audioSource && this._audioSource.error;
      } else {
        return this._screenSource.error;
      }
    }

    /**
     * The current output stream.
     *
     * @readonly
     * @member {?MediaStream} ScreenSource#stream
     */

  }, {
    key: 'stream',
    get: function get() {
      return this.output.stream;
    }

    /**
     * Mute property as documented in {@link MuteFilter#mute}.
     *
     * @member {Object} ScreenSource#mute
     */

  }, {
    key: 'mute',
    get: function get() {
      return this._muteFilter.mute;
    },
    set: function set(value) {
      this._muteFilter.mute = value;
    }
  }, {
    key: 'sink',
    set: function set(sink) {
      __WEBPACK_IMPORTED_MODULE_6_common_log__["default"].error(TAG, 'screenSource.sink is removed, just connect directly to the sink instead');
    }
  }]);

  return ScreenSource;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_14_media_mediaNode__["a" /* default */].connectMixin()));

/* harmony default export */ __webpack_exports__["a"] = (ScreenSource);

/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_mediaSource__ = __webpack_require__(144);













/**
 * A media node which merges the audio and video tracks from two different streams into one stream.
 *
 * @class StreamMerger
 * @extends MediaSource
 */

var StreamMerger = function (_MediaSource) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(StreamMerger, _MediaSource);

  function StreamMerger() {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, StreamMerger);

    // Make sure we handle synchronous updates of both inputs as one update
    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StreamMerger.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(StreamMerger)).call(this));

    var microtask = null;
    var onStream = function onStream() {
      if (!microtask) {
        microtask = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve().then(function () {
          microtask = null;
          _this.onStream();
        });
      }
    };
    _this._audioInput = new __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__["a" /* default */]({
      name: 'default',
      parent: _this,
      onStream: onStream
    });
    _this._videoInput = new __WEBPACK_IMPORTED_MODULE_7_media_mediaNodeInput__["a" /* default */]({
      name: 'default',
      parent: _this,
      onStream: onStream
    });
    return _this;
  }

  /**
   * The input that the audio track should be extracted from.
   *
   * @member {MediaNodeInput} StreamMerger#audioInput
   */


  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(StreamMerger, [{
    key: 'onStream',


    /**
     * @private
     */
    value: function onStream() {
      if (!this._audioInput.stream && !this._videoInput.stream) {
        this.setStream(null);
        return;
      }
      var stream = new __WEBPACK_IMPORTED_MODULE_6_webrtc_utils__["MediaStream"]();
      if (this._audioInput.stream) {
        this._audioInput.stream.getAudioTracks().forEach(function (track) {
          stream.addTrack(track);
        });
      }
      if (this._videoInput.stream) {
        this._videoInput.stream.getVideoTracks().forEach(function (track) {
          stream.addTrack(track);
        });
      }
      this.setStream(stream);
    }
  }, {
    key: 'audioInput',
    get: function get() {
      return this._audioInput;
    }

    /**
     * The input that the video track should be extracted from.
     *
     * @member {MediaNodeInput} StreamMerger#videoInput
     */

  }, {
    key: 'videoInput',
    get: function get() {
      return this._videoInput;
    }
  }]);

  return StreamMerger;
}(__WEBPACK_IMPORTED_MODULE_8_media_mediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (StreamMerger);

/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_media_common__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_media_htmlSink__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_streamSplitter__ = __webpack_require__(191);











/**
 * A sink that can be used to take snapshots of a video stream that are
 * exported as either blobs or a data URIs.
 *
 * @class VideoFrameCapture
 */

var VideoFrameCapture = function () {
  function VideoFrameCapture() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, VideoFrameCapture);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_media_common__["e" /* doesntSupportPlugin */])(this);
    this._video = document.createElement('video');
    this._canvas = document.createElement('canvas');
    this._splitter = new __WEBPACK_IMPORTED_MODULE_6_media_streamSplitter__["a" /* default */]();
    this._htmlSink = new __WEBPACK_IMPORTED_MODULE_5_media_htmlSink__["default"]({ target: this._video });
    this._splitter.videoOutput.connect(this._htmlSink);
  }

  /**
   * The input from which the video will be captured.
   *
   * @member {MediaNodeInput} VideoFrameCapture#input
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(VideoFrameCapture, [{
    key: 'toDataUri',


    /**
     * Saves the current video frame as a data URI.
     *
     * @param {Object} [options] - Optional options object.
     * @param {number} [options.scale=1] - The scale used when capturing the video frame.
     * @param {string} [options.mimeType='image/png'] - The file format to export the image as.
     * @param {number} [options.imageQuality=0.92] - The image quality factory used by `'image/jpeg'` and `'image/webp'`.
     * @returns {string} A data uri with the image data.
     */
    value: function toDataUri() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].optOptions('VideoFrameCapture.toDataUri', 'options', options).optNumber('scale').optString('mimeType').optNumber('imageQuality');

      var _options$scale = options.scale,
          scale = _options$scale === undefined ? 1 : _options$scale,
          _options$mimeType = options.mimeType,
          mimeType = _options$mimeType === undefined ? null : _options$mimeType,
          _options$imageQuality = options.imageQuality,
          imageQuality = _options$imageQuality === undefined ? 0.92 : _options$imageQuality;

      var canvas = this._prepareCanvas(scale);
      return canvas.toDataURL(mimeType, imageQuality);
    }

    /**
     * Saves the current video frame as a blob.
     *
     * @param {Object} [options] - Optional options object.
     * @param {number} [options.scale=1] - The scale used when capturing the video frame.
     * @param {string} [options.mimeType='image/png'] - The file format to export the image as.
     * @param {number} [options.imageQuality=0.92] - The image quality factory used by `'image/jpeg'` and `'image/webp'`.
     * @returns {Promise<Blob>} A promise that will be resolved to a blob with the image data.
     */

  }, {
    key: 'toBlob',
    value: function toBlob() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      __WEBPACK_IMPORTED_MODULE_3_common_argCheck__["a" /* default */].optOptions('VideoFrameCapture.toBlob', 'options', options).optNumber('scale').optString('mimeType').optNumber('imageQuality');

      var _options$scale2 = options.scale,
          scale = _options$scale2 === undefined ? 1 : _options$scale2,
          _options$mimeType2 = options.mimeType,
          mimeType = _options$mimeType2 === undefined ? null : _options$mimeType2,
          _options$imageQuality2 = options.imageQuality,
          imageQuality = _options$imageQuality2 === undefined ? 0.92 : _options$imageQuality2;

      var canvas = this._prepareCanvas(scale);
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve) {
        canvas.toBlob(resolve, mimeType, imageQuality);
      });
    }
  }, {
    key: '_prepareCanvas',
    value: function _prepareCanvas(scale) {
      var context = this._canvas.getContext('2d');
      var _video = this._video,
          videoWidth = _video.videoWidth,
          videoHeight = _video.videoHeight;

      var width = videoWidth * scale;
      var height = videoHeight * scale;
      this._canvas.width = width;
      this._canvas.height = height;
      context.clearRect(0, 0, width, height);
      context.drawImage(this._video, 0, 0, width, height);
      return this._canvas;
    }
  }, {
    key: 'input',
    get: function get() {
      return this._splitter;
    }
  }]);

  return VideoFrameCapture;
}();

/* harmony default export */ __webpack_exports__["a"] = (VideoFrameCapture);

/***/ }),
/* 251 */,
/* 252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export StreamConnection */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StreamPublisher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return StreamSubscriber; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_matrix_room__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_webrtc_rtcComponent__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_webrtc_peerConnectionProxy__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_media_streamSink__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_media_streamSource__ = __webpack_require__(190);






















var SERVICE_LOCAL_ID = 'c3-media-service';

var CON_TAG = 'stream-connection';
var PUB_TAG = 'stream-publisher';
var SUB_TAG = 'stream-subscriber';

var CONNECTION_DISCONNECT_TIMEOUT_MS = 5000;
var ERROR_TIMEOUT_MULTIPLIER_MS = 1000;

// signaling, peer connection is not in stable state
var CONNECTION_STATE_SIGNALING = 'signaling';
// peer connection in stable state, ice not connected
var CONNECTION_STATE_CONNECTING = 'connecting';
// peer connection stable and ice connected
var CONNECTION_STATE_CONNECTED = 'connected';
// ice was connected but has disconnected, might recover
var CONNECTION_STATE_RECONNECTING = 'reconnecting';
// call has been closed
var CONNECTION_STATE_CLOSED = 'closed';

var StreamConnection = function () {
  function StreamConnection(deps) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, StreamConnection);

    this._stream = deps.stream;
    this._configPromise = deps.configPromise;
    this._onOffer = deps.onOffer;
    this._onStream = deps.onStream;
    this._emitterTarget = deps.emitterTarget;
    this._peerConnection = null;
    this._errorState = null;
    this._connectionState = CONNECTION_STATE_SIGNALING;
    this._connectionFailCount = 0;
    this._disconnectTimeoutId = 0;
    this._errorTimeoutId = 0;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(StreamConnection, [{
    key: '_setConnectionState',
    value: function _setConnectionState(connectionState) {
      var prevState = this._connectionState;
      this._connectionState = connectionState;
      if (prevState !== connectionState) {
        this._emitterTarget._emit('connectionState', connectionState);
      }
    }
  }, {
    key: '_setErrorState',
    value: function _setErrorState(errorState) {
      if (errorState !== this._errorState) {
        this._errorState = errorState;
        this._emitterTarget._emit('errorState', errorState);
      }
    }
  }, {
    key: '_connectionHasFailed',
    value: function _connectionHasFailed(error) {
      clearTimeout(this._disconnectTimeoutId);
      this._disconnectTimeoutId = 0;
      if (this._connectionState === CONNECTION_STATE_CLOSED) {
        return;
      }

      if (this._connectionState === CONNECTION_STATE_SIGNALING) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].warning(CON_TAG, this + ' connection failed while signaling');
      }
      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(CON_TAG, this + ' restarting failed connection, ' + error);
      this._setErrorState(error);
      this._restart();
    }
  }, {
    key: '_restart',
    value: function _restart() {
      var _this = this;

      this._errorTimeoutId = setTimeout(function () {
        if (_this._connectionState !== CONNECTION_STATE_CLOSED) {
          _this.start();
        }
      }, (this._connectionFailCount - 1) * ERROR_TIMEOUT_MULTIPLIER_MS);
    }
  }, {
    key: 'start',
    value: function start() {
      var _this2 = this;

      this._setConnectionState(CONNECTION_STATE_SIGNALING);
      return this._configPromise.then(function (config) {
        _this2._peerConnection = __WEBPACK_IMPORTED_MODULE_11_webrtc_peerConnectionProxy__["a" /* default */].create({
          iceServers: config.iceServers,
          iceCandidateFilter: function iceCandidateFilter(info) {
            return info.type === 'relay';
          }
        });

        var onSignalingStateChange = function onSignalingStateChange() {
          if (!_this2._peerConnection) {
            return;
          }
          var signalingState = _this2._peerConnection.signalingState;

          if (signalingState === 'closed') {
            _this2._peerConnection.removeEventListener('addstream', onAddStream);
            _this2._peerConnection.removeEventListener('removestream', onRemoveStream);
            _this2._peerConnection.removeEventListener('signalingstatechange', onSignalingStateChange);
            _this2._peerConnection.removeEventListener('iceconnectionstatechange', onIceConnectionStateChange);
            _this2._peerConnection = null;
            _this2._onStream && _this2._onStream(null);
          }
        };
        var onIceConnectionStateChange = function onIceConnectionStateChange() {
          if (!_this2._peerConnection) {
            return;
          }
          var iceConnectionState = _this2._peerConnection.iceConnectionState;

          if (iceConnectionState === 'failed') {
            _this2._connectionFailCount += 1;
            _this2._connectionHasFailed(new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["b" /* ConnectionFailedError */](_this2._connectionFailCount));
          } else if (iceConnectionState === 'disconnected') {
            _this2._setConnectionState(CONNECTION_STATE_RECONNECTING);
            _this2._disconnectTimeoutId = setTimeout(function () {
              _this2._connectionHasFailed(new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["a" /* ConnectionLostError */]('Timed out in disconnected state'));
            }, CONNECTION_DISCONNECT_TIMEOUT_MS);
          } else {
            clearTimeout(_this2._disconnectTimeoutId);
            _this2._disconnectTimeoutId = 0;
            if (iceConnectionState === 'connected') {
              _this2._connectionFailCount = 0;
              _this2._setErrorState(null);
              _this2._setConnectionState(CONNECTION_STATE_CONNECTED);
            }
          }
        };
        var onAddStream = function onAddStream(event) {
          _this2._onStream && _this2._onStream(event.stream);
        };
        var onRemoveStream = function onRemoveStream() {
          _this2._onStream && _this2._onStream(null);
        };

        if (_this2._stream) {
          _this2._peerConnection.addStream(_this2._stream);
        }
        _this2._peerConnection.addEventListener('addstream', onAddStream);
        _this2._peerConnection.addEventListener('removestream', onRemoveStream);
        _this2._peerConnection.addEventListener('signalingstatechange', onSignalingStateChange);
        _this2._peerConnection.addEventListener('iceconnectionstatechange', onIceConnectionStateChange);

        var constraints = __WEBPACK_IMPORTED_MODULE_8_common_utils__["isChrome"] ? {
          mandatory: {
            OfferToReceiveAudio: true,
            OfferToReceiveVideo: true
          }
        } : {
          offerToReceiveVideo: 1,
          offerToReceiveAudio: 1
        };
        _this2._peerConnection.performOffer({ constraints: constraints, waitForIce: true }).then(function (offer) {
          return _this2._onOffer(offer);
        }).then(function (answer) {
          return _this2._peerConnection.handleAnswer({ answer: answer });
        }).then(function () {
          return _this2._setConnectionState(CONNECTION_STATE_CONNECTING);
        }).catch(function (error) {
          var signalingError = new __WEBPACK_IMPORTED_MODULE_12_webrtc_errors__["e" /* ConnectionSignalingError */](error);
          _this2._connectionFailCount += 1;
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(CON_TAG, 'failed to connect to stream, ' + signalingError);
          _this2._emitterTarget._emit({
            eventType: 'signalingError',
            defaultHandler: function defaultHandler() {
              __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(CON_TAG, 'unhandled connection signaling error', signalingError);
            }
          }, signalingError);
          _this2._restart();
        });
      });
    }
  }, {
    key: 'close',
    value: function close() {
      this._setErrorState(null);
      this._setConnectionState(CONNECTION_STATE_CLOSED);
      if (this._peerConnection) {
        if (this._peerConnection.signalingState !== 'closing') {
          this._peerConnection.close();
        }
      }
    }
  }, {
    key: 'errorState',
    get: function get() {
      return this._errorState;
    }
  }, {
    key: 'connectionState',
    get: function get() {
      return this._connectionState;
    }
  }]);

  return StreamConnection;
}();

/**
 * @typedef {Object} StreamPublisher.PublishRequest
 *
 * @property {external:RTCSessionDescription} offer - A session description with type `'offer'`.
 */

/**
 * @typedef {Object} StreamPublisher.PublishReply
 *
 * @property {string} streamId - The id if the stream that was published.
 * @property {external:RTCSessionDescription} answer - A session description with type `'answer'`.
 */

/**
 * @callback StreamPublisher.PublishCallback
 *
 * @param {StreamPublisher.PublishRequest} request - The publish request.
 * @returns {Promise<StreamPublisher.PublishReply>} A promise that should be resolved to
 *   a publish reply object, or rejected if there was an error.
 */

/**
 * An {@link RtcComponent} that will automatically publish a stream and have the peers in
 * a call subscribe to it. The peer must have a {@link StreamSubscriber} attached
 * at the matching attachment point.
 *
 * The purpose of this component is to provide a simple way to use stream relay and recording
 * features within the context of a call. The call data channel is used to negotiate subscriptions
 * automatically, so it is enough to simply attach publish and subscribe components to each end of
 * a call.
 *
 * Instances should be constructed using {@link StreamPublisher.inRoom}, although the
 * constructor can be used for testing purposes.
 *
 * @class StreamPublisher
 * @implements RtcComponent
 * @extends EventEmitter
 * @param {Options} options - An options object.
 * @param {Promise<external:RTCConfiguration>} options.configPromise - A promise that resolves
 *   to a peer connection configuration.
 * @param {StreamPublisher.PublishCallback} options.publish - A callback that is called whenever
 *   a new stream needs to be published.
 *
 * @example
 * let publisher = StreamPublisher.inRoom(room)
 * mediaSource.connect(publisher)
 *
 * let call = room.startCall(peer)
 * call.attach('stream', publisher)
 */
var StreamPublisher = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(StreamPublisher, _EmitterMixin);

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(StreamPublisher, null, [{
    key: 'inRoom',

    /**
     * Emitted when the connection state of the publisher changes.
     *
     * @event StreamPublisher#connectionState
     * @param {PeerConnectionState} connectionState - The new connection state.
     */

    /**
     * Emitted when the error state is changed.
     *
     * @event StreamPublisher#errorState
     * @param {(ConnectionFailedError|ConnectionLostError)?} errorState - The new error state.
     */

    /**
     * Emitted when there is a signaling error. The connection will be restarted when this happens.
     *
     * @event StreamPublisher#signalingError
     * @param {ConnectionSignalingError} signalingError - A signaling error.
     */

    value: function inRoom(options) {
      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].options('StreamPublisher.inRoom', 'options', options).object('meta').instance('room', __WEBPACK_IMPORTED_MODULE_9_matrix_room__["a" /* default */]);

      var room = options.room,
          meta = options.meta;


      return new StreamPublisher({
        configPromise: room._serviceRequest(SERVICE_LOCAL_ID, 'c3.stream.get-config'),
        publish: function publish(_ref) {
          var offer = _ref.offer;

          return room._serviceRequest(SERVICE_LOCAL_ID, 'c3.stream.publish', { offer: offer, meta: meta });
        }
      });
    }
  }]);

  function StreamPublisher(_ref2) {
    var publish = _ref2.publish,
        configPromise = _ref2.configPromise;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, StreamPublisher);

    var _this3 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StreamPublisher.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(StreamPublisher)).call(this, { label: 'c3.stream.publisher', remoteLabel: 'c3.stream.subscriber' }));

    _this3._sink = new __WEBPACK_IMPORTED_MODULE_14_media_streamSink__["a" /* default */]({ onStream: _this3._onStream.bind(_this3) });
    _this3._conneciton = null;
    _this3._streamId = null;
    _this3._publish = publish;
    _this3._configPromise = configPromise;
    _this3._setStreamId = _this3._setStreamId.bind(_this3);
    return _this3;
  }

  /**
   * The input for the media that will be published.
   *
   * @readonly
   * @member {MediaNodeInput} StreamPublisher#input
   */


  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(StreamPublisher, [{
    key: '_onStream',
    value: function _onStream(stream) {
      var _this4 = this;

      if (this._connection) {
        this._setStreamId(null);
        this._connection.close();
        this._connection = null;
      }
      if (stream) {
        this._connection = new StreamConnection({
          stream: stream,
          configPromise: this._configPromise,
          onOffer: function onOffer(offer) {
            __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(PUB_TAG, 'publishing stream');
            return _this4._publish({ offer: offer }).then(function (content) {
              var streamId = content.streamId,
                  answer = content.answer;

              __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(PUB_TAG, 'got stream id \'' + streamId + '\' and answer ' + answer);
              _this4._setStreamId(streamId);
              return answer;
            });
          },
          emitterTarget: this
        });
        this._connection.start().catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(PUB_TAG, 'failed to get stream config, ' + error);
        });
      }
    }
  }, {
    key: '_setStreamId',
    value: function _setStreamId(streamId) {
      this._streamId = streamId;
      if (this.attached) {
        this.attachPoint.data.setWithOwnership('streamId', streamId, 'streamer');
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentWillAttach',
    value: function rtcComponentWillAttach(attachPoint) {
      if (attachPoint.type !== 'call') {
        throw new TypeError('StreamPublisher may only be attached to calls.');
      }
      attachPoint.data.setWithOwnership('streamId', this._streamId, 'streamer');
    }
  }, {
    key: 'input',
    get: function get() {
      return this._sink;
    }

    /**
     * An error describing why the connection is failing, or null if there is no error.
     * Will always be null if {@link StreamPublisher#connectionState} is `'connected'` or `'closed'`.
     *
     * @readonly
     * @member {(ConnectionFailedError|ConnectionLostError)?} StreamPublisher#errorState
     */

  }, {
    key: 'errorState',
    get: function get() {
      if (this._connection) {
        return this._connection.errorState;
      } else {
        return null;
      }
    }

    /**
     * The connection state of the sublisher.
     *
     * @readonly
     * @member {PeerConnectionState} StreamPublisher#connectionState
     */

  }, {
    key: 'connectionState',
    get: function get() {
      if (this._connection) {
        return this._connection.connectionState;
      } else {
        return null;
      }
    }
  }]);

  return StreamPublisher;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_10_webrtc_rtcComponent__["a" /* default */]));

/**
 * @typedef {Object} StreamSubscriber.SubscriptionRequest
 *
 * @property {string} streamId - The id if the stream that is being subscribed to.
 * @property {external:RTCSessionDescription} offer - A session description with type `'offer'`.
 */

/**
 * @typedef {Object} StreamSubscriber.SubscriptionReply
 *
 * @property {external:RTCSessionDescription} answer - A session description with type `'answer'`.
 */

/**
 * @callback StreamSubscriber.SubscribeCallback
 *
 * @param {StreamSubscriber.SubscriptionRequest} request - The subscription request.
 * @returns {Promise<StreamSubscriber.SubscriptionReply>} A promise that should be resolved to
 *   a subscription reply object, or rejected if there was an error.
 */

/**
 * An {@link RtcComponent} that will automatically subscribe to a stream that is being
 * published by the peer in a call. The peer must have a {@link StreamPublisher} attached
 * at the matching attachment point.
 *
 * The purpose of this component is to provide a simple way to use stream relay and recording
 * features within the context of a call. The call data channel is used to negotiate subscriptions
 * automatically, so it is enough to simply attach publish and subscribe components to each end of
 * a call.
 *
 * Instances should be constructed using {@link StreamSubscriber.inRoom}, although the
 * constructor can be used for testing purposes.
 *
 * @class StreamSubscriber
 * @implements RtcComponent
 * @extends EventEmitter
 * @extends ConnectMixin
 * @param {Options} options - An options object.
 * @param {Promise<external:RTCConfiguration>} options.configPromise - A promise that resolves
 *   to a peer connection configuration.
 * @param {StreamSubscriber.SubscribeCallback} options.subscribe - A callback that is called whenever
 *   a new subscription is being made.
 *
 * @example
 * let subscriber = StreamSubscriber.inRoom(room)
 * subscriber.connect(removeView)
 *
 * let call = room.startCall(peer)
 * call.attach('stream', subscriber)
 */
var StreamSubscriber = function (_MediaNode$connectMix) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(StreamSubscriber, _MediaNode$connectMix);

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(StreamSubscriber, null, [{
    key: 'inRoom',

    /**
     * Emitted when the connection state of the subscriber changes.
     *
     * @event StreamSubscriber#connectionState
     * @param {PeerConnectionState} connectionState - The new connection state.
     */

    /**
     * Emitted when the error state is changed.
     *
     * @event StreamSubscriber#errorState
     * @param {(ConnectionFailedError|ConnectionLostError)?} errorState - The new error state.
     */

    /**
     * Emitted when there is a signaling error. The connection will be restarted when this happens.
     *
     * @event StreamSubscriber#signalingError
     * @param {ConnectionSignalingError} signalingError - A signaling error.
     */

    /**
     * Creates a new {@link StreamSubscriber} withing the context of a room. The room must have been
     * created with `recording` options set in {@link Client.RoomConfiguration}, and the server must
     * have recording enabled.
     *
     * @param {Object} options - Options object.
     * @param {Room} options.room - The room.
     * @returns {StreamSubscriber} A newly created {@link StreamSubscriber} instance.
     */
    value: function inRoom(options) {
      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].options('StreamPublisher.inRoom', 'options', options).instance('room', __WEBPACK_IMPORTED_MODULE_9_matrix_room__["a" /* default */]);

      var room = options.room;

      return new StreamSubscriber({
        configPromise: room._serviceRequest(SERVICE_LOCAL_ID, 'c3.stream.get-config'),
        subscribe: function subscribe(subscription) {
          return room._serviceRequest(SERVICE_LOCAL_ID, 'c3.stream.subscribe', subscription);
        }
      });
    }
  }]);

  function StreamSubscriber(_ref3) {
    var configPromise = _ref3.configPromise,
        subscribe = _ref3.subscribe;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, StreamSubscriber);

    var _this5 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (StreamSubscriber.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(StreamSubscriber)).call(this, { label: 'c3.stream.subscriber', remoteLabel: 'c3.stream.publisher' }));

    _this5._source = new __WEBPACK_IMPORTED_MODULE_15_media_streamSource__["a" /* default */]();
    _this5._subscribe = subscribe;
    _this5._streamId = null;
    _this5._configPromise = configPromise;
    return _this5;
  }

  /**
   * Output for the received media.
   *
   * @member {MediaNodeOutput} StreamSubscriber#output
   */


  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(StreamSubscriber, [{
    key: '_subscribeToStreamId',
    value: function _subscribeToStreamId(streamId) {
      var _this6 = this;

      if (this._streamId === streamId) {
        return;
      }
      this._streamId = streamId;

      if (this._connection) {
        this._connection.close();
        this._connection = null;
      }

      if (!streamId) {
        return;
      }

      this._connection = new StreamConnection({
        configPromise: this._configPromise,
        onOffer: function onOffer(offer) {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(SUB_TAG, 'subscribing to stream: \'' + streamId + '\'');
          return _this6._subscribe({ offer: offer, streamId: streamId }).then(function (content) {
            var answer = content.answer;

            __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(SUB_TAG, 'got answer ' + answer);
            return answer;
          });
        },
        onStream: function onStream(stream) {
          _this6._source.setStream(stream);
        },
        emitterTarget: this
      });

      this._connection.start().catch(function (error) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(PUB_TAG, 'failed to get stream config, ' + error);
      });
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentUpdatedData',
    value: function rtcComponentUpdatedData(_ref4) {
      var key = _ref4.key,
          value = _ref4.value,
          oldValue = _ref4.oldValue,
          ownerId = _ref4.ownerId;

      if (key === 'streamId') {
        this._subscribeToStreamId(value);
      }
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentWillAttach',
    value: function rtcComponentWillAttach(attachPoint) {
      if (attachPoint.type !== 'call') {
        throw new TypeError('StreamSubscriber may only be attached to calls.');
      }
      this._subscribeToStreamId(attachPoint.data.get('streamId'));
    }

    /**
     * @private
     */

  }, {
    key: 'rtcComponentWillDetach',
    value: function rtcComponentWillDetach() {
      this._subscribeToStreamId(null);
    }
  }, {
    key: 'output',
    get: function get() {
      return this._source;
    }

    /**
     * An error describing why the connection is failing, or null if there is no error.
     * Will always be null if {@link StreamSubscriber#connectionState} is `'connected'` or `'closed'`.
     *
     * @readonly
     * @member {(ConnectionFailedError|ConnectionLostError)?} StreamSubscriber#errorState
     */

  }, {
    key: 'errorState',
    get: function get() {
      if (this._connection) {
        return this._connection.errorState;
      } else {
        return null;
      }
    }

    /**
     * The connection state of the subscriber.
     *
     * @readonly
     * @member {PeerConnectionState} StreamSubscriber#connectionState
     */

  }, {
    key: 'connectionState',
    get: function get() {
      if (this._connection) {
        return this._connection.connectionState;
      } else {
        return null;
      }
    }
  }]);

  return StreamSubscriber;
}(__WEBPACK_IMPORTED_MODULE_13_media_mediaNode__["a" /* default */].connectMixin(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_10_webrtc_rtcComponent__["a" /* default */])));

/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_media_scaledCanvasFilter__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_media_temasysCanvasFilter__ = __webpack_require__(282);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_webrtc_rtcComponent__ = __webpack_require__(160);

















var TAG = 'thumbnail-broadcaster';

/**
 * The element renderer.
 * @abstract
 * @extends EventEmitter
 * @class ThumbnailBroadcaster.SinkRenderer
 */

var SinkRenderer = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(SinkRenderer, _EmitterMixin);

  /**
   * Emitted when elements are added.
   *
   * @event ThumbnailBroadcaster.SinkRenderer#added
   * @param {Array<HTMLElement>} added - An array of elements that were added.
   */

  /**
   * Emitted when elements are removed.
   *
   * @event ThumbnailBroadcaster.SinkRenderer#removed
   * @param {Array<HTMLElement>} removed - An array of elements that were removed.
   */

  /**
   * Emitted when elements are updated.
   *
   * @event ThumbnailBroadcaster.SinkRenderer#elements
   * @param {Array<HTMLElement>} elements - The current list of elements.
   */

  function SinkRenderer(options) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, SinkRenderer);

    var _this = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default()(this, (SinkRenderer.__proto__ || __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default()(SinkRenderer)).call(this));

    var _ref = options || {},
        _ref$elementClass = _ref.elementClass,
        elementClass = _ref$elementClass === undefined ? '' : _ref$elementClass;

    _this._elementClassName = elementClass;
    _this._htmlElements = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    _this._elements = [];
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(SinkRenderer, [{
    key: '__processImage',
    value: function __processImage(peerId, dataUrl) {
      if (!this._htmlElements.has(peerId)) {
        this._addImageElementForPeer(peerId, dataUrl);
      } else {
        var el = this._htmlElements.get(peerId);
        if (el.nodeName === 'IMG') {
          el.src = dataUrl;
        }
      }
    }
  }, {
    key: '__processRemoteSource',
    value: function __processRemoteSource(peerId, source) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'processRemoteSource ' + peerId);
      if (!this._htmlElements.has(peerId) || this._htmlElements.get(peerId).nodeName === 'IMG') {
        /* we don't have an element for this peer or it is an img */
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'adding video element for peer');
        this._addVideoElementForPeer(peerId, source);
      } else if (this._htmlElements.get(peerId).nodeName === 'VIDEO') {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'connecting new source to old video element for ' + peerId);

        source.connect(this._htmlElements.get(peerId));
      }
    }
  }, {
    key: '__removePeer',
    value: function __removePeer(peerId) {
      if (this._htmlElements.has(peerId)) {
        var elementToRemove = this._htmlElements.get(peerId);
        this._removeElement(peerId, elementToRemove);
      }
    }
  }, {
    key: '_removeElement',
    value: function _removeElement(peerId, element) {
      this._htmlElements.delete(peerId);
      this._emit('removed', [element]);
      this._elements = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(this._htmlElements.values()));
      this._emit('elements', this._elements);
    }

    /**
     * The current set of elements.
     *
     * Returned HTML elements will have a property peerId indicating the peer.
     *
     * @readonly
     * @member {Array<HTMLElement>} ThumbnailBroadcaster.SinkRenderer#elements
     */

  }, {
    key: '_addElement',
    value: function _addElement(peerId, element) {
      element.peerId = peerId;
      if (this._htmlElements.has(peerId)) {
        var removedElement = this._htmlElements.get(peerId);
        this._removeElement(peerId, removedElement);
      }
      this._htmlElements.set(peerId, element);
      this._emit('added', [element]);
      this._elements = [].concat(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_toConsumableArray___default()(this._htmlElements.values()));
      this._emit('elements', this._elements);
    }
  }, {
    key: '_addImageElementForPeer',
    value: function _addImageElementForPeer(peerId, dataUrl) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'adding image element for ' + peerId);
      var imgEl = document.createElement('img');
      imgEl.src = dataUrl;
      imgEl.className = this._elementClassName;
      this._addElement(peerId, imgEl);
    }
  }, {
    key: '_addVideoElementForPeer',
    value: function _addVideoElementForPeer(peerId, source) {
      var _this2 = this;

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'adding video element for ' + peerId);
      var videoEl = document.createElement('video');
      videoEl.autoplay = true;
      videoEl.className = this._elementClassName;

      videoEl.addEventListener('loadeddata', function () {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'video element loadeddata: readyState = ' + videoEl.readyState);
        _this2._addElement(peerId, videoEl);
      });

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'connecting new source to new video element (' + peerId + ')');
      source.connect(videoEl);
    }
  }, {
    key: 'elements',
    get: function get() {
      return this._elements;
    }
  }]);

  return SinkRenderer;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_emitter__["a" /* default */])(null));

/**
 * The projection configuration for ThumbnailBroadcaster.
 * @typedef {Object} ThumbnailBroadcaster.ProjectionConfiguration
 * @property {number} [width] - The width of the generated thumbnails (in pixels).
 * @property {number} [aspectRatio] - The aspect ratio of the thumbnail (width/height).
 * @property {'aspectFill'|'scaleToFill'} [contentMode='aspectFill'] - How to fill the thumbnail.
 */

/**
 * An {@link RtcComponent} that will automatically publish a stream and have the peers in
 * a call subscribe to it. The peer must have a ThumbnailBroadcaster attached
 * at the matching attachment point.
 *
 * The purpose of this component is to provide a simple way to send miniature streams and
 * thumbnail images within the context of a call.
 *
 * @class ThumbnailBroadcaster
 * @implements RtcComponent
 * @param {Object} options - An options object.
 * @param {ThumbnailBroadcaster.ProjectionConfiguration} options.projectionConfiguration - An options object.
 *
 * @example
 * thumbnailBroadcaster = new cct.ThumbnailBroadcaster({
 *   projectionConfiguration: {
 *     width: 100,
 *     aspectRatio: 16/9,
 *     contentMode: 'aspectFill',
 *   },
 *   videoFrameRate: 10,
 *   imageFrameRate: 0.5,
 * })
 *
 * videoSource.connect(thumbnailBroadcaster)
 *
 * let renderer = thumbnailBroadcaster.createRenderer({elementClass: 'c3-example-thumbnail'})
 *
 * renderer.on('elements', function (elements) {
 *   addElementsToDom(elements)
 * })
 */


var ThumbnailBroadcaster = function (_RtcComponent) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(ThumbnailBroadcaster, _RtcComponent);

  function ThumbnailBroadcaster(options) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, ThumbnailBroadcaster);

    var _this3 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ThumbnailBroadcaster.__proto__ || __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default()(ThumbnailBroadcaster)).call(this, { label: 'cct.media.thumbnailbroadcaster' }));

    __WEBPACK_IMPORTED_MODULE_9_common_argCheck__["a" /* default */].optOptions('ThumbnailBroadcaster constructor', 'options', options).optObject('projectionConfiguration').optNumber('videoFrameRate');

    var _ref2 = options || {},
        _ref2$projectionConfi = _ref2.projectionConfiguration,
        projectionConfiguration = _ref2$projectionConfi === undefined ? {} : _ref2$projectionConfi,
        _ref2$videoFrameRate = _ref2.videoFrameRate,
        videoFrameRate = _ref2$videoFrameRate === undefined ? 15 : _ref2$videoFrameRate,
        _ref2$imageFrameRate = _ref2.imageFrameRate,
        imageFrameRate = _ref2$imageFrameRate === undefined ? 0 : _ref2$imageFrameRate;

    options.projectionConfiguration = projectionConfiguration;
    options.videoFrameRate = videoFrameRate;
    options.imageFrameRate = imageFrameRate;
    _this3._shouldConnectCanvasFilter = false;
    _this3._handleStillPicture = _this3._handleStillPicture.bind(_this3);
    _this3.createRenderer = _this3.createRenderer.bind(_this3);

    try {
      _this3._canvasFilter = new __WEBPACK_IMPORTED_MODULE_11_media_scaledCanvasFilter__["a" /* default */](options);

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'scaled canvas filter initialized');
      // we have a working canvas filter miniature, so we should connect it to remote peers
      _this3._shouldConnectCanvasFilter = true;
    } catch (error) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'canvas filter not supported, falling back to still pictures');
      _this3._canvasFilter = new __WEBPACK_IMPORTED_MODULE_12_media_temasysCanvasFilter__["a" /* default */](options);
    }

    _this3._outgoingThumbChannels = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_map___default.a();
    return _this3;
  }

  /**
   * Create a renderer that will emit elements.
   *
   * @function ThumbnailBroadcaster#createRenderer
   * @param {Object} [options] - Optional options object.
   * @returns {ThumbnailBroadcaster.SinkRenderer} - The renderer object that will emit events.
   */


  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(ThumbnailBroadcaster, [{
    key: 'createRenderer',
    value: function createRenderer(options) {
      this._sinkRenderer = new SinkRenderer(options);
      return this._sinkRenderer;
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentWillAttach',
    value: function rtcComponentWillAttach(attachPoint) {
      this._attachPoint = attachPoint;

      if (this._shouldConnectCanvasFilter) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'using local source as video element');
        // we have a valid local stream, so add this to the elements

        if (this._sinkRenderer) {
          this._sinkRenderer.__processRemoteSource(attachPoint.ownId, this._canvasFilter.output);
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'using local source as image element');
      }

      this._canvasFilter.on('stillPictureCaptured', this._handleStillPicture);
    }
  }, {
    key: '_handleStillPicture',
    value: function _handleStillPicture(dataUrl) {
      this._sinkRenderer.__processImage(this._attachPoint.ownId, dataUrl);
      this._transferImageToPeers(dataUrl);
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentWillDetach',
    value: function rtcComponentWillDetach(attachPoint) {
      this._canvasFilter.off('stillPictureCaptured', this._handleStillPicture);
    }
  }, {
    key: '_transferImageToPeers',
    value: function _transferImageToPeers(dataUrl) {
      var blobToTransfer = this._dataURItoBlob(dataUrl);

      this._outgoingThumbChannels.forEach(function (channel, peerId) {
        var isChannelOpen = channel.readyState === 'open';
        var isChannelNotBusy = typeof channel._isBusy === 'undefined' || channel._isBusy === false;
        if (isChannelOpen && isChannelNotBusy) {
          channel._isBusy = true;
          channel.send({ image: blobToTransfer }).then(function () {
            __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'transfer of still picture to ' + peerId + ' completed');
            channel._isBusy = false;
          }).catch(function (error) {
            __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, 'channel send error', error);
          });
        } else {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'not sending on ' + channel + ' (isBusy = ' + channel._isBusy + ')');
        }
      });
    }
  }, {
    key: '_dataURItoBlob',
    value: function _dataURItoBlob(dataURI) {
      var _parseDataUri = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["parseDataUri"])(dataURI),
          mimeType = _parseDataUri.mimeType,
          binaryString = _parseDataUri.binaryString;

      var ab = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["binaryStringToArrayBuffer"])(binaryString);
      return new Blob([ab], { type: mimeType });
    }
  }, {
    key: '_blobToDataURI',
    value: function _blobToDataURI(blob, callback) {
      var a = new FileReader();
      a.onload = function (e) {
        callback(e.target.result);
      };
      a.readAsDataURL(blob);
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidReceivePeer',
    value: function rtcComponentDidReceivePeer(peer) {
      var _this4 = this;

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'received peer: ' + peer.id);

      if (this._shouldConnectCanvasFilter) {
        this._canvasFilter.connect(peer);
      }

      if (this._sinkRenderer) {
        this._sinkRenderer.__processRemoteSource(peer.id, peer);
      }

      var dataChannel = peer.createChannel({
        label: 'cct.thumbnail',
        protocol: 'cct.thumbnail.v0',
        pairingId: 'default'
      });

      this._outgoingThumbChannels.set(peer.id, dataChannel);

      dataChannel.on('message', function (_ref3) {
        var image = _ref3.image;

        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'received thumbnail image (size=' + image.size + ') from peer ' + peer.id + ' (channel: ' + dataChannel + ')');

        _this4._blobToDataURI(image, function (dataURL) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'thumbnail image successfully received (channel: ' + dataChannel + ')');

          if (_this4._sinkRenderer) {
            _this4._sinkRenderer.__processImage(peer.id, dataURL);
          }
        });
      });
    }

    // eslint-disable-next-line
    /**
     * @private
     */

  }, {
    key: 'rtcComponentDidLosePeer',
    value: function rtcComponentDidLosePeer(peer) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, 'lost peer: ' + peer.id);
      if (this._sinkRenderer) {
        this._sinkRenderer.__removePeer(peer.id);
      }

      this._outgoingThumbChannels.delete(peer.id);
    }

    /**
     * The input for the media that will be broadcasted to all peers.
     *
     * @readonly
     * @member {MediaNodeInput} ThumbnailBroadcaster#input
     */

  }, {
    key: 'input',
    get: function get() {
      return this._canvasFilter;
    }
  }]);

  return ThumbnailBroadcaster;
}(__WEBPACK_IMPORTED_MODULE_13_webrtc_rtcComponent__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (ThumbnailBroadcaster);

/***/ }),
/* 254 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_common_argCheck__ = __webpack_require__(12);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_argCheck", function() { return __WEBPACK_IMPORTED_MODULE_0_common_argCheck__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_emitter__ = __webpack_require__(38);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_EmitterMixin", function() { return __WEBPACK_IMPORTED_MODULE_1_common_emitter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_queue__ = __webpack_require__(159);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_AsyncQueue", function() { return __WEBPACK_IMPORTED_MODULE_2_common_queue__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_AsyncPipe", function() { return __WEBPACK_IMPORTED_MODULE_2_common_queue__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_utils__ = __webpack_require__(13);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "_utils", function() { return __WEBPACK_IMPORTED_MODULE_3_common_utils__; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_log__ = __webpack_require__(3);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return __WEBPACK_IMPORTED_MODULE_4_common_log__["default"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_webrtc_utils__ = __webpack_require__(66);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "webRtcReady", function() { return __WEBPACK_IMPORTED_MODULE_5_webrtc_utils__["webRtcReady"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_AdapterJS", function() { return __WEBPACK_IMPORTED_MODULE_5_webrtc_utils__["AdapterJS"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_matrix_accountData__ = __webpack_require__(185);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AccountData", function() { return __WEBPACK_IMPORTED_MODULE_6_matrix_accountData__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_matrix_auth__ = __webpack_require__(241);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Auth", function() { return __WEBPACK_IMPORTED_MODULE_7_matrix_auth__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_matrix_client__ = __webpack_require__(242);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Client", function() { return __WEBPACK_IMPORTED_MODULE_8_matrix_client__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_matrix_resources__ = __webpack_require__(165);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ImageResource", function() { return __WEBPACK_IMPORTED_MODULE_9_matrix_resources__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUpload", function() { return __WEBPACK_IMPORTED_MODULE_9_matrix_resources__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_matrix_powerLevels__ = __webpack_require__(186);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PowerLevelsEdit", function() { return __WEBPACK_IMPORTED_MODULE_10_matrix_powerLevels__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PowerLevelsReader", function() { return __WEBPACK_IMPORTED_MODULE_10_matrix_powerLevels__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_matrix_room__ = __webpack_require__(187);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Room", function() { return __WEBPACK_IMPORTED_MODULE_11_matrix_room__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_matrix_roomQuery__ = __webpack_require__(216);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RoomQuery", function() { return __WEBPACK_IMPORTED_MODULE_12_matrix_roomQuery__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_matrix_roomState__ = __webpack_require__(217);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RoomState", function() { return __WEBPACK_IMPORTED_MODULE_13_matrix_roomState__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_matrix_user__ = __webpack_require__(188);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "User", function() { return __WEBPACK_IMPORTED_MODULE_14_matrix_user__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_webrtc_call__ = __webpack_require__(224);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Call", function() { return __WEBPACK_IMPORTED_MODULE_15_webrtc_call__["default"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16_webrtc_fileRef__ = __webpack_require__(226);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "FileRef", function() { return __WEBPACK_IMPORTED_MODULE_16_webrtc_fileRef__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "FileTransfer", function() { return __WEBPACK_IMPORTED_MODULE_16_webrtc_fileRef__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "FileDownload", function() { return __WEBPACK_IMPORTED_MODULE_16_webrtc_fileRef__["c"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17_webrtc_dataHub__ = __webpack_require__(193);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AttachData", function() { return __WEBPACK_IMPORTED_MODULE_17_webrtc_dataHub__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18_webrtc_rtcComponent__ = __webpack_require__(160);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RtcComponent", function() { return __WEBPACK_IMPORTED_MODULE_18_webrtc_rtcComponent__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19_webrtc_attachmentManager__ = __webpack_require__(192);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "RtcPeer", function() { return __WEBPACK_IMPORTED_MODULE_19_webrtc_attachmentManager__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20_webrtc_components__ = __webpack_require__(225);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MediaBroadcaster", function() { return __WEBPACK_IMPORTED_MODULE_20_webrtc_components__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "DataShare", function() { return __WEBPACK_IMPORTED_MODULE_20_webrtc_components__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "FileShare", function() { return __WEBPACK_IMPORTED_MODULE_20_webrtc_components__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "PeerMediaPipe", function() { return __WEBPACK_IMPORTED_MODULE_20_webrtc_components__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ProxySink", function() { return __WEBPACK_IMPORTED_MODULE_20_webrtc_components__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ProxySource", function() { return __WEBPACK_IMPORTED_MODULE_20_webrtc_components__["f"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21_webrtc_thumbnailBroadcaster__ = __webpack_require__(253);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ThumbnailBroadcaster", function() { return __WEBPACK_IMPORTED_MODULE_21_webrtc_thumbnailBroadcaster__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22_webrtc_streamPubSub__ = __webpack_require__(252);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StreamPublisher", function() { return __WEBPACK_IMPORTED_MODULE_22_webrtc_streamPubSub__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StreamSubscriber", function() { return __WEBPACK_IMPORTED_MODULE_22_webrtc_streamPubSub__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23_media_audioBufferSource__ = __webpack_require__(243);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AudioBufferSource", function() { return __WEBPACK_IMPORTED_MODULE_23_media_audioBufferSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24_media_audioMeter__ = __webpack_require__(244);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AudioMeter", function() { return __WEBPACK_IMPORTED_MODULE_24_media_audioMeter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25_media_audioMixer__ = __webpack_require__(245);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "AudioMixer", function() { return __WEBPACK_IMPORTED_MODULE_25_media_audioMixer__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26_media_chromeScreenSource__ = __webpack_require__(218);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ChromeScreenSource", function() { return __WEBPACK_IMPORTED_MODULE_26_media_chromeScreenSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27_media_common__ = __webpack_require__(92);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "isMediaNode", function() { return __WEBPACK_IMPORTED_MODULE_27_media_common__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mediaInputs", function() { return __WEBPACK_IMPORTED_MODULE_27_media_common__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mediaOuputs", function() { return __WEBPACK_IMPORTED_MODULE_27_media_common__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28_media_concreteMediaSource__ = __webpack_require__(164);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ConcreteMediaSource", function() { return __WEBPACK_IMPORTED_MODULE_28_media_concreteMediaSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29_media_deviceSource__ = __webpack_require__(246);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "DeviceSource", function() { return __WEBPACK_IMPORTED_MODULE_29_media_deviceSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30_media_dummySource__ = __webpack_require__(178);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "DummySource", function() { return __WEBPACK_IMPORTED_MODULE_30_media_dummySource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31_media_firefoxScreenSource__ = __webpack_require__(219);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "FirefoxScreenSource", function() { return __WEBPACK_IMPORTED_MODULE_31_media_firefoxScreenSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32_media_htmlSink__ = __webpack_require__(146);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "HtmlSink", function() { return __WEBPACK_IMPORTED_MODULE_32_media_htmlSink__["default"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33_media_mediaFilter__ = __webpack_require__(179);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MediaFilter", function() { return __WEBPACK_IMPORTED_MODULE_33_media_mediaFilter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34_media_mediaNode__ = __webpack_require__(86);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MediaNode", function() { return __WEBPACK_IMPORTED_MODULE_34_media_mediaNode__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35_media_mediaNodeInput__ = __webpack_require__(131);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MediaNodeInput", function() { return __WEBPACK_IMPORTED_MODULE_35_media_mediaNodeInput__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36_media_mediaNodeOutput__ = __webpack_require__(149);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MediaNodeOutput", function() { return __WEBPACK_IMPORTED_MODULE_36_media_mediaNodeOutput__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37_media_mediaSink__ = __webpack_require__(153);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MediaSink", function() { return __WEBPACK_IMPORTED_MODULE_37_media_mediaSink__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38_media_mediaSource__ = __webpack_require__(144);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MediaSource", function() { return __WEBPACK_IMPORTED_MODULE_38_media_mediaSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39_media_mediaTee__ = __webpack_require__(220);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MediaTee", function() { return __WEBPACK_IMPORTED_MODULE_39_media_mediaTee__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40_media_muteFilter__ = __webpack_require__(180);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MuteFilter", function() { return __WEBPACK_IMPORTED_MODULE_40_media_muteFilter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41_media_passthrough__ = __webpack_require__(181);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Passthrough", function() { return __WEBPACK_IMPORTED_MODULE_41_media_passthrough__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42_media_recorder__ = __webpack_require__(247);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Recorder", function() { return __WEBPACK_IMPORTED_MODULE_42_media_recorder__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43_media_screenSource__ = __webpack_require__(248);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "ScreenSource", function() { return __WEBPACK_IMPORTED_MODULE_43_media_screenSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44_media_streamMerger__ = __webpack_require__(249);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StreamMerger", function() { return __WEBPACK_IMPORTED_MODULE_44_media_streamMerger__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45_media_streamSink__ = __webpack_require__(189);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StreamSink", function() { return __WEBPACK_IMPORTED_MODULE_45_media_streamSink__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46_media_streamSource__ = __webpack_require__(190);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StreamSource", function() { return __WEBPACK_IMPORTED_MODULE_46_media_streamSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47_media_streamSplitter__ = __webpack_require__(191);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StreamSplitter", function() { return __WEBPACK_IMPORTED_MODULE_47_media_streamSplitter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48_media_userMediaSource__ = __webpack_require__(221);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "UserMediaSource", function() { return __WEBPACK_IMPORTED_MODULE_48_media_userMediaSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49_media_videoFrameCapture__ = __webpack_require__(250);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "VideoFrameCapture", function() { return __WEBPACK_IMPORTED_MODULE_49_media_videoFrameCapture__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50_media_webAudioFilter__ = __webpack_require__(222);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebAudioFilter", function() { return __WEBPACK_IMPORTED_MODULE_50_media_webAudioFilter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51_media_webAudioSource__ = __webpack_require__(223);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "WebAudioSource", function() { return __WEBPACK_IMPORTED_MODULE_51_media_webAudioSource__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52_conference_conference__ = __webpack_require__(212);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Conference", function() { return __WEBPACK_IMPORTED_MODULE_52_conference_conference__["default"]; });

/**
 * The top level C3 Web SDK namespace.
 *
 * Classes marked with **protected** do not provide a public constructor, they either use static
 * factory methods or are only exported to provide access to the prototype and using `instanceof`.
 *
 * Base API classes:
 * - {@link AccountData} **protected** - Provides access to both room specific and global persistent account data.
 * - {@link Auth} **protected** - Provides static methods for authentication.
 * - {@link Call} **protected** - A two-way WebRTC Call.
 * - {@link Client} - Main client object, the entrypoint for server connections.
 * - {@link Conference} **protected** - A WebRTC conference with multiple participants.
 * - {@link FileRef} **protected** - Reference to a local or remote file.
 *     Has static factory methods for loading from different sources.
 * - {@link FileTransfer} **protected** - Represents a file transfer to a remote peer.
 * - {@link FileDownload} **protected** - Represents a file download from a remote peer.
 * - {@link ImageResource} **protected** - Provides access to a server-side image resource.
 * - {@link PowerLevelsEdit} **protected** - Provides a fluent API for editing the power levels in a room.
 * - {@link PowerLevelsReader} **protected** - Used to inspect the power levels in a room,
 *     as well as read a raw power levels object.
 * - {@link Room} **protected** - A representation of a room that users join in order to communicate.
 * - {@link RoomQuery} **protected** - A live query that filters the rooms known to the client.
 * - {@link RoomState} **protected** - Represents persistent state of a specific type in a room.
 * - {@link User} **protected** - Represents a user.
 *
 * RtcComponent building blocks:
 * - {@link AttachPoint} **protected** - Provides an API for RtcComponents once they have been attached to something.
 * - {@link RtcComponent} - Base class for RtcComponents that are attached to calls and conferences.
 * - {@link RtcPeer} **protected** - Provides and API for interacting with remote peers in an RtcComponent.
 *
 * Built-in {@link RtcComponent}s:
 * - {@link DataShare} - Synchronize data between all participants in a conference or call.
 * - {@link DocumentReader} - Streams an entire web page or iframe to a remote peer.
 * - {@link DocumentRenderer} - Renders a page recieved from a {@link DocumentReader}, and forwards input events.
 * - {@link FileShare} - Share files between all participants in a conference or call.
 * - {@link MediaBroadcaster} - Broadcast media to other users in a conference.
 * - {@link PeerMediaPipe} - Send and receive media from the peer in a call.
 * - {@link StreamPublisher} - Publish a stream to a stream relay with recording (requires recording service).
 * - {@link StreamSubscriber} - Subscribe to a relayed stream (requires recording service).
 *
 * Media API building blocks:
 * - {@link MediaNode} - Base class for all media nodes, which also contains some static utility methods.
 * - {@link MediaNodeInput} - An input port that receives streams for it's parent media node.
 * - {@link MediaNodeOutput} - An output port that forwards streams frmo it's parent media node.
 * - {@link MediaFilter} - Base class for nodes that receives and forwards a stream.
 * - {@link MediaSink} - Base class for nodes at the end of the chain that receive and renders a stream.
 * - {@link MediaSource} - Base class for source nodes that generate a stream.
 * - {@link ConcreteMediaSource} - Base class for a source that is backed by a single tangible stream.
 * - {@link WebAudioFilter} - Base class for WebAudio-based filter nodes.
 * - {@link WebAudioSource} - Base class for WebAudio-based source nodes.
 *
 * Build-in {@link MediaNode}s:
 * - {@link AudioBufferSource} - Plays audio buffers.
 *     Also provides utilities for decoding and loading audio buffers from files.
 * - {@link AudioMeter} - Analyses the volume of incoming audio and provides a raw, and low-pass values.
 * - {@link AudioMixer} - Mixes together audio from multiple streams into one output stream.
 * - {@link ChromeScreenSource} - Screen sharing in Chrome, you usually want to use {@link ScreenSource} instead.
 * - {@link DeviceSource} - Captures media from user microphones and cameras.
 * - {@link FirefoxScreenSource} - Screen sharing in Firefox, you usually want to use {@link ScreenSource} instead.
 * - {@link HtmlSink} - Renders the incoming audio and video to an HTMLMediaElement, i.e. `<audio>` or `<video>`.
 * - {@link MediaTee} - A container node that bundles together some common functionalities.
 *     Usually used as source node for remote streams.
 * - {@link MuteFilter} - Makes it possible to mute a media stream.
 * - {@link Passthrough} - Identity node that forwards streams, with optional logging.
 *     Used for inspection and smoothing out API surfaces.
 * - {@link Recorder} - Used for client-side recording of media streams.
 * - {@link ScreenSource} - Enables screen capture.
 * - {@link StreamMerger} - Merges the audio and video components from two incoming streams together into one stream.
 * - {@link StreamSink} - Quick access to a received MediaStream, used for testing and bridging APIs.
 * - {@link StreamSource} - Forwards a given MediaStream, used for testing and bridging APIs.
 * - {@link StreamSplitter} - Splits a stream into it's audio and video components.
 * - {@link UserMediaSource} - A low level node that requests user media, usually you
 *     want {@link DeviceSource} or {@link ScreenSource} instead.
 *
 * Error types:
 * - {@link AuthenticationError} - Authentication failed, or it is required to perform the requested action.
 * - {@link ChannelClosedError} - The operation failed because the channel was closed.
 * - {@link ChannelFailedError} - The channel failed due to a low-level error.
 * - {@link ChannelTimeoutError} - The channel operation timed out.
 * - {@link ConflictError} - The requested action would result in a conflict.
 * - {@link ConnectionFailedError} - Connection setup failed after signaling was completed.
 * - {@link ConnectionLostError} - A connection which was connected has now failed.
 * - {@link ConnectionSignalingError} - Error when trying to set up a connection.
 * - {@link FileTransferError} - Failure because of data corruption or a protocol error.
 * - {@link GuestAccessError} - Guests are not allowed to perform the requested action.
 * - {@link InternalServerError} - The server encountered an unexpected error.
 * - {@link InvalidAliasError} - The requested room alias is invalid.
 * - {@link InvalidUsernameError} - The requested username is invalid.
 * - {@link NotAllowedError} - The requested action is not allowed.
 * - {@link NotFoundError} - The requested resource could not be found.
 * - {@link TooLargeError} - The request body was too large.
 * - {@link TransferInterruptedError} - Failure because the connection was interrupted.
 *
 * @namespace cct
 */

if (window.cordova && window.cordova.plugins && window.cordova.plugins.iosrtc) {
  window.cordova.plugins.iosrtc.registerGlobals();
}








/**
 * The log singleton, see {@link Log}.
 * @readOnly
 * @member {Log} cct#log
 */


/**
 * @member {Object} cct#version
 * @readOnly
 * @property {string} number - Package version number.
 * @property {string} commit - Commit hash.
 * @property {string} synapseMinVersion - Minimum required synapse version.
 * @property {string} synapseTargetVersion - Target synapse version, versions past this
 *   could break backwards compatability.
 */
var version = {"commit":"955aa13fe5ff4786d71cc49c1bd8873f1aaa9140\n","number":"0.19.8","synapseMinVersion":"0.14.0","synapseTargetVersion":"0.14.0"};























































/***/ }),
/* 255 */,
/* 256 */,
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = Reporter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_request__ = __webpack_require__(166);






var REPORTER_SEND_INTERVAL = 5000;

function Reporter(url) {
  this.sendIntervalms = REPORTER_SEND_INTERVAL;
  this.waiting = false;
  this.pending = [];
  this.statsEndpoint = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_request__["c" /* default */])().origin(url);
  this.seenError = false;
  this.tag = 'stats-reporter';
}

Reporter.prototype.handleStats = function (payload) {
  var self = this;
  self.pending.push(payload);
  if (!self.waiting) {
    self.waiting = true;
    setTimeout(function () {
      self.waiting = false;
      var reports = self.processReports(self.pending);
      __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].verbose(self.tag, 'Posting reports [' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(reports).length + ' bytes]', reports);
      self.statsEndpoint.post(reports).then(function () {
        if (self.seenError) {
          self.seenError = false;
        }
      }).catch(function (error) {
        if (self.seenError) {
          __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].warning(self.tag, 'Post failed:', error);
        } else {
          self.seenError = true;
          __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].error(self.tag, 'Post failed:', error);
        }
      });
      self.pending = [];
    }, self.sendIntervalms);
  }
};

Reporter.prototype.processReports = function (reports) {
  var pcStats = {};

  for (var i in reports) {
    var stats = reports[i];
    for (var j in stats) {
      var stat = stats[j];
      if (stat.pcId) {
        if (!pcStats[stat.pcId]) {
          pcStats[stat.pcId] = [stat];
        } else {
          pcStats[stat.pcId].push(stat);
        }
      }
    }
  }

  for (var pcId in pcStats) {
    pcStats[pcId] = this.processPcStats(pcStats[pcId]);
  }

  return {
    pcStats: pcStats
  };
};

Reporter.prototype.processPcStats = function (stats) {
  var sources = this.invertTimeSeries(stats);
  this.flattenTimeSeries(sources);
  return sources;
};

Reporter.prototype.invertTimeSeries = function (stats) {
  var sources = {}; // Each source has a unique source key, e.g. ssrc
  var i;
  var key;
  var stat;
  var source;

  // First populate sources keys
  for (i in stats) {
    stat = stats[i];
    if (!sources[stat.sourceId]) {
      source = sources[stat.sourceId] = {};
    } else {
      source = sources[stat.sourceId];
    }

    for (key in stat) {
      if (!source[key]) {
        source[key] = [];
      }
    }
  }

  // Then add data
  for (i in stats) {
    stat = stats[i];
    source = sources[stat.sourceId];
    for (key in source) {
      var value = stat[key];
      if (value !== undefined) {
        source[key].push(value);
      } else {
        source[key].push('');
      }
    }
  }
  return sources;
};

// Flattens an array of source values into a single value, if all values are identical
Reporter.prototype.flattenTimeSeries = function (sources) {
  for (var sourceId in sources) {
    var source = sources[sourceId];
    for (var key in source) {
      var samples = source[key];
      if (!samples.length) {
        continue;
      }
      var firstValue = samples[0];
      var seenDifferent = false;
      for (var i in samples) {
        if (samples[i] !== firstValue) {
          seenDifferent = true;
          break;
        }
      }
      if (!seenDifferent) {
        source[key] = firstValue;
      }
    }
  }
};

/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_webrtc_peerConnectionProxy__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_webrtc_dataChannelMonitor__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_webrtc_signaler__ = __webpack_require__(233);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_datamux_datamux__ = __webpack_require__(227);














var TAG = 'conference-conn';

var RTT_DIFF_THRESHOLD = 25;
var RTT_FACTOR_THRESHOLD = 1.5;

/**
 * Internal class the represents the connection to a peer in the conference.
 */

var ConferenceConnection = function () {
  function ConferenceConnection(deps) {
    var _this = this;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ConferenceConnection);

    this._ownId = deps.ownId;
    this._peerId = deps.peerId;
    this._peerLinkInfo = deps.peerLinkInfo;
    this._attachmentManager = deps.attachmentManager;
    this._statsFormatter = deps.statsFormatter;
    this._peerConnectionConfiguration = {
      iceServers: deps.iceServers,
      iceCandidateFilter: deps.iceCandidateFilter,
      statsFormatter: deps.statsFormatter
    };
    this._conferencePeer = null;
    this._connectedAt = null;
    this._lastReportedRtt = null;

    this._onAddRemoteStream = this._onRemoteStreamChange.bind(this, 'got');
    this._onRemoveRemoteStream = this._onRemoteStreamChange.bind(this, 'lost');

    this._datamux = new __WEBPACK_IMPORTED_MODULE_8_datamux_datamux__["a" /* default */]({
      onChannel: function onChannel(channel) {
        return _this._attachmentManager.handlePeerChannel(_this._peerId, channel);
      },
      onConnect: function onConnect() {
        return _this._signaler.handleDataChannelConnect();
      },
      onDisconnect: function onDisconnect(reason) {
        return _this._signaler.handleDataChannelDisconnect(reason);
      },
      onRttChange: this._onRttChange.bind(this),
      onUpStateChange: this._onUpStateChange.bind(this)
    });
    this._peerLinkInfo.update(this._datamux);

    // All builtin channels should be created here
    var renegotiationChannel = this._datamux.createChannel({
      builtin: true,
      label: 'cct.call',
      protocol: 'cct.call.v0'
    });
    this._attachmentChannels = {
      negotiationChannel: this._datamux.createChannel({
        builtin: true,
        label: 'cct.call.attach-map',
        protocol: 'cct.call.attach-map.v0'
      }),
      dataHubChannel: this._datamux.createChannel({
        builtin: true,
        label: 'cct.attach.data',
        protocol: 'cct.attach.data.v0'
      }),
      messagingChannel: this._datamux.createChannel({
        builtin: true,
        label: 'cct.attach.messaging',
        protocol: 'cct.attach.messaging.v0'
      })
    };
    this._raftChannel = this._datamux.createChannel({
      builtin: true,
      label: 'cct.conference.raft',
      protocol: 'cct.conference.raft.v0'
    });

    this._signaler = new __WEBPACK_IMPORTED_MODULE_7_webrtc_signaler__["a" /* default */]({
      label: this._ownId + '->' + this._peerId,
      receivedOffer: deps.offer,
      renegotiationChannel: renegotiationChannel,
      close: this.close.bind(this),
      onMessage: deps.onSignalingMessage,
      onSignalingError: this._onSignalingError.bind(this),
      onErrorStateChange: this._onErrorStateChange.bind(this),
      onConnectionStateChange: this._onConnectionStateChange.bind(this),
      onCreatePeerConnection: this._createPeerConnection.bind(this)
    });
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(ConferenceConnection, [{
    key: 'start',
    value: function start() {
      this._signaler.start();
    }
  }, {
    key: 'toString',
    value: function toString() {
      return 'conferenceConnection{peerId=' + this._peerId + ',' + this._peerConnection + '}';
    }
  }, {
    key: '_onRttChange',
    value: function _onRttChange(rttMs) {
      var shouldUpdate = false;
      if (this._lastReportedRtt === null) {
        shouldUpdate = true;
      }

      var rttDiff = Math.abs(this._lastReportedRtt - rttMs);
      var rttFactor = rttMs <= 0 ? Infinity : this._lastReportedRtt / rttMs;
      if (rttFactor < 1) {
        rttFactor = 1 / rttFactor;
      }
      if (rttFactor > RTT_FACTOR_THRESHOLD && rttDiff > RTT_DIFF_THRESHOLD) {
        shouldUpdate = true;
      }

      if (this._peerLinkInfo && shouldUpdate) {
        this._peerLinkInfo.update(this._datamux);
        this._lastReportedRtt = rttMs;
      }
    }
  }, {
    key: '_onUpStateChange',
    value: function _onUpStateChange(up) {
      this._peerLinkInfo.update(this._datamux);
    }
  }, {
    key: '_createPeerConnection',
    value: function _createPeerConnection() {
      if (this._peerConnection) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].verbose(TAG, this, 'replacing peer connection');
        this.reset();
      }
      this._peerConnection = __WEBPACK_IMPORTED_MODULE_5_webrtc_peerConnectionProxy__["a" /* default */].create(this._peerConnectionConfiguration);
      if (this._statsFormatter) {
        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_webrtc_dataChannelMonitor__["a" /* default */])(this._peerConnection, this._statsFormatter);
      }
      var dataChannelFactory = this._peerConnection.createDataChannel.bind(this._peerConnection);
      this._datamux.createDataChannels(dataChannelFactory);
      this._attachmentManager.setDatamuxForPeer(this._peerId, this._datamux, this._attachmentChannels);
      this._lastReportedRtt = null;
      this._peerConnection.addEventListener('addstream', this._onAddRemoteStream);
      this._peerConnection.addEventListener('removestream', this._onRemoveRemoteStream);

      return this._peerConnection;
    }
  }, {
    key: '_updateLocalStreams',
    value: function _updateLocalStreams(streams) {
      var _this2 = this;

      if (!this._peerConnection) {
        return;
      }
      var currentStreams = this._peerConnection.getLocalStreams();

      var _streamDiff = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_webrtc_utils__["streamDiff"])(currentStreams, streams),
          _streamDiff2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_streamDiff, 2),
          added = _streamDiff2[0],
          removed = _streamDiff2[1];

      added.forEach(function (stream) {
        return _this2._peerConnection.addStream(stream);
      });
      removed.forEach(function (stream) {
        return _this2._peerConnection.removeStream(stream);
      });
    }
  }, {
    key: '_setConferencePeer',
    value: function _setConferencePeer(conferencePeer) {
      this._conferencePeer = conferencePeer;
      if (conferencePeer) {
        conferencePeer._setErrorState(this._signaler.errorState);
        conferencePeer._setConnectionState(this._signaler.connectionState);
      }
    }
  }, {
    key: '_onSignalingError',
    value: function _onSignalingError(error) {
      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].warning(TAG, this, 'restarting connection because of signaling error, ' + error);
      this._signaler.reset();
      this._signaler.start();
    }
  }, {
    key: '_onErrorStateChange',
    value: function _onErrorStateChange(error) {
      if (this._conferencePeer) {
        this._conferencePeer._setErrorState(error);
      }
    }
  }, {
    key: '_onConnectionStateChange',
    value: function _onConnectionStateChange(newState, oldState) {
      if (newState === 'connected') {
        this._connectedAt = Date.now();
      } else {
        this._connectedAt = null;
      }
      if (this._conferencePeer) {
        this._conferencePeer._setConnectionState(newState, oldState);
      }
    }
  }, {
    key: '_onRemoteStreamChange',
    value: function _onRemoteStreamChange(op, event) {
      var stream = event.stream;

      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, op + ' remote stream \'' + stream.id + ':\'', stream);
      var streams = this._peerConnection.getRemoteStreams();
      this._attachmentManager.setRemoteStreamsForPeer(this._peerId, streams);
    }
  }, {
    key: '_handleSignalingMessage',
    value: function _handleSignalingMessage(message) {
      try {
        this._signaler.handleMessage(message);
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, this, 'error when handling signaling message: ' + error);
      }
    }
  }, {
    key: 'setPausedState',
    value: function setPausedState(isPaused) {
      this._datamux.setPausedState(isPaused);
    }
  }, {
    key: 'close',
    value: function close() {
      if (this._signaler.transitionToClosed()) {
        this.reset();
        this._datamux.cleanup();
        this._raftChannel._clearListeners('message'); // TODO: proper implementation
        this._attachmentManager = null;
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].info(TAG, 'closed connection: ' + this);
      }
    }
  }, {
    key: 'reset',
    value: function reset() {
      if (this._peerConnection) {
        this._peerConnection.removeEventListener('addstream', this._onAddRemoteStream);
        this._peerConnection.removeEventListener('removestream', this._onRemoveRemoteStream);
      }
      this._datamux.reset();
      this._attachmentManager.cleanupPeer(this._peerId);
      this._signaler.reset();
      try {
        if (this._peerConnection && this._peerConnection.signalingState !== 'closed') {
          this._peerConnection.close();
        }
      } catch (e) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'failed to close peer connection: ', e);
      }
      this._peerConnection = null;
    }
  }, {
    key: 'raftChannel',
    get: function get() {
      return this._raftChannel;
    }
  }, {
    key: 'up',
    get: function get() {
      return this._datamux.up;
    }
  }, {
    key: 'connected',
    get: function get() {
      return this._signaler.connectionState === 'connected';
    }
  }, {
    key: 'connectedAt',
    get: function get() {
      return this._connectedAt;
    }
  }]);

  return ConferenceConnection;
}();

/* harmony default export */ __webpack_exports__["a"] = (ConferenceConnection);

/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_utils__ = __webpack_require__(13);













var TAG = 'connection-pool';

// It's not too expensive to keep connections alive, so use a pretty lengthy ttl.
// A single peerId we will also only have a single connection, so people spamming
// refresh etc. is not a problem.
var CONNECTION_TTL_MS = 30 * 1000;
var TICK_INTERVAL_MS = 1500;
// We keep this quite low, triggering disconnects is cheap since we don't tear
// down connections.
var DISCONNECTED_TICK_LIMIT = 4; // 6s with ticks every 1.5s

// This thing should keep track of setting up connections, expiring old connections
// that aren't needed, doing raft communication, making sure the local mesh links
// are updated and pingers are active, and set up specific connections that are
// needed to connect to a cluster.

var ConferenceConnectionPool = function () {
  function ConferenceConnectionPool(_ref) {
    var ownId = _ref.ownId,
        connectionFactory = _ref.connectionFactory,
        meshTopology = _ref.meshTopology,
        onRaftMessage = _ref.onRaftMessage,
        onDisconnected = _ref.onDisconnected,
        onInvite = _ref.onInvite,
        onBestConnection = _ref.onBestConnection;

    __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_classCallCheck___default()(this, ConferenceConnectionPool);

    __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].string(this, 'options.ownId', ownId);
    this._tick = this._tick.bind(this);
    this.handleRaftMessage = this.handleRaftMessage.bind(this);

    this._connectionFactory = connectionFactory;
    this._meshTopology = meshTopology;
    this._onRaftMessage = onRaftMessage;
    this._onDisconnected = onDisconnected;
    this._onInvite = onInvite;
    this._onBestConnection = onBestConnection;

    this._ownId = ownId;
    this._intervalId = null;
    this._connections = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a(); // peerId: conferenceConnection

    // Connections that aren't expected will expire after some time. The reason we don't close them
    // straight away is that it is quite common that connections are no longer needed due to signaling
    // conflicts, but once the conflicts are resolved and we've joined the cluster, the connection
    // will be needed again.
    this._expiry = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a(); // peerId: expiryTimeMs

    // Similar to expiry, but keeps track of immaterial connections
    // that can be realized using .materializeGhostConnections()
    this._ghostConnections = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_map___default.a(); // peerId: expiryTimeMs

    // These are the expected connections, they're synchronized with the raft membership configuration
    this._expected = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default.a(); // peerId

    // When connecting to a cluster, this will make sure that we are only accepting messages from the
    // cluster leader
    this._clusterLeader = null;

    this._disconnectedTicks = 0;

    // Used to keep track of the best connection, currently selected by uptime
    this._bestConnection = null;
    this._bestConnectionTime = Infinity;
  }

  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_createClass___default()(ConferenceConnectionPool, [{
    key: 'toString',
    value: function toString() {
      var active = this.active.size;
      var expected = this._expected.size;
      var total = this._connections.size;
      return 'connectionPool{ownId=' + this._ownId + ',active=' + active + ',expected=' + expected + ',total=' + total + '}';
    }
  }, {
    key: 'start',
    value: function start() {
      if (!this._intervalId) {
        this._intervalId = setInterval(this._tick, TICK_INTERVAL_MS);
      } else {
        throw new Error('Called connectionPool.start() when already started for ' + this);
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _this = this;

      if (this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
      this._disconnectedTicks = 0;
      this._clusterLeader = null;
      this._expected.clear();
      this._connections.forEach(function (connection, peerId) {
        return _this._removeConnection(peerId);
      });
      this._connections.clear();
      this._expiry.clear();
    }

    // Adds an entry for a possible connection that might be realized at a later stage.
    // The ghost connection will stick around for ttlMs milliseconds, and then be removed.

  }, {
    key: 'addGhostConnection',
    value: function addGhostConnection(peerId) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$ttlMs = _ref2.ttlMs,
          ttlMs = _ref2$ttlMs === undefined ? CONNECTION_TTL_MS : _ref2$ttlMs;

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'adding ghost connection to ' + peerId + ' with ttl ' + ttlMs + 'ms');
      this._ghostConnections.set(peerId, Date.now() + ttlMs);
    }

    // Materialize all active ghost connections to real connections.

  }, {
    key: 'materializeGhostConnections',
    value: function materializeGhostConnections() {
      var _this2 = this;

      var now = Date.now();
      this._ghostConnections.forEach(function (expiry, peerId) {
        if (expiry > now) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, _this2, 'materializing ghost connection, ' + peerId);
          _this2._onInvite(peerId);
        }
      });
      this._ghostConnections.clear();
    }

    // Temporary connections are used when setting up connections to peers that are not yet
    // members of the raft cluster. There connections will expire, but the TTL should be more than
    // enough to have time to set up a connection and do raft signaling until the peer or oneself
    // has become a true member of the cluster.

  }, {
    key: 'ensureTemporaryConnection',
    value: function ensureTemporaryConnection(peerId) {
      if (peerId === this._ownId) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, this, 'tried to ensure connection to self, ' + peerId);
        return;
      }
      this._addConnection(peerId);
    }

    // This is a special case of the above method, where we will only be accepting raft message from the
    // cluster leader until we've received the cluster configuration.

  }, {
    key: 'connectToClusterLeader',
    value: function connectToClusterLeader(peerId) {
      this._clusterLeader = peerId;
      this.ensureTemporaryConnection(peerId);
    }

    // This should be called when the raft members are updated. We unset the cluster leader here, since
    // if we get a membership update we've successfully joined the cluster.
    // This is safe because the only messages that are sent to non-members are snapshot requests, which
    // are always ignored once we've joined the cluster. This means that a stray cluster leader won't break
    // our local raft state for the cluster.

  }, {
    key: 'setExpectedConnections',
    value: function setExpectedConnections(peerIds) {
      this._expected = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default.a(peerIds);
      if (this._expected.has(this._ownId)) {
        this._clusterLeader = null;
        this._expected.delete(this._ownId);
      }
      this._tick();
    }

    // Sets the observer callback that will be called once synchronously, and then whenever
    // the 'best' connection changes. Which connection is the best one is currently determined
    // only by how long it has been connected.

  }, {
    key: 'setBestConnectionObserver',
    value: function setBestConnectionObserver(callback) {
      this._onBestConnection = callback;
      if (callback) {
        callback(this._bestConnection);
      }
    }

    // This simply forwards WebRTC signaling messages to the correct connection

  }, {
    key: 'handleConnectionMessage',
    value: function handleConnectionMessage(peerId, message) {
      if (message.recipient !== this._ownId) {
        return; // ignore messages that aren't meant for us
      }
      var content = message.content;

      if (!content) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].warning(TAG, this, 'got signaling message without content from ' + peerId + ', ' + __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(message));
        return;
      }

      var connection = this._connections.get(peerId);
      if (!connection) {
        var keys = '[' + __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_keys___default()(content).join(', ') + ']';
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'got signaling message for missing connection to ' + peerId + ' containing ' + keys + ', creating');
        connection = this._addConnection(peerId);
      }

      connection._handleSignalingMessage(content);
    }

    // This handles outbound raft messages that are generated by a Raft instance

  }, {
    key: 'handleRaftMessage',
    value: function handleRaftMessage(peerId, message) {
      var connection = this._connections.get(peerId);
      if (connection && connection.raftChannel) {
        if (connection.raftChannel.readyState === 'open') {
          connection.raftChannel.send(message);
        } else {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].verbose(TAG, 'raft message to \'' + peerId + '\' was not sent: ' + __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(message));
        }
      }
    }
  }, {
    key: '_tick',
    value: function _tick() {
      var _this3 = this;

      var _diff = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["diff"])(this._connections.keys(), this._expected),
          _diff2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_diff, 2),
          added = _diff2[0],
          removed = _diff2[1];

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].verbose(TAG, this, 'ticked, adding [' + added.join(', ') + '], maybe removing [' + removed.join(', ') + ']');
      added.forEach(function (peerId) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, _this3, 'adding expected connection to ' + peerId);
        _this3._addConnection(peerId);
      });

      var now = Date.now();
      removed.forEach(function (peerId) {
        var expiry = _this3._expiry.get(peerId);
        if (!expiry || expiry < now) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, _this3, 'removing expired connection to ' + peerId);
          _this3._removeConnection(peerId);
        }
      });

      var newExpiryMs = now + CONNECTION_TTL_MS;
      this.active.forEach(function (peerId) {
        _this3._expiry.set(peerId, newExpiryMs);
      });

      this._ghostConnections.forEach(function (expiry, peerId) {
        if (expiry < now) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].verbose(TAG, _this3, 'expired ghost connection to ' + peerId);
          _this3._ghostConnections.delete(peerId);
        }
      });

      // Find the connection that has been connected the longest
      var stillTheBest = this._bestConnection && this._bestConnection.connectedAt === this._bestConnectionTime;
      if (!stillTheBest) {
        var hadConnection = !!this._bestConnection;
        this._bestConnection = null;
        this._bestConnectionTime = Infinity;
        this._connections.forEach(function (connection) {
          if (connection.connectedAt && connection.connectedAt < _this3._bestConnectionTime) {
            _this3._bestConnection = connection;
            _this3._bestConnectionTime = connection.connectedAt;
          }
        });
        if (this._onBestConnection && (this._bestConnection || hadConnection)) {
          this._onBestConnection(this._bestConnection);
        }
      }

      var haveConnection = false;
      var isConnected = false;
      var disconnectFactor = 1;

      // Check if we're currently connected
      if (this._clusterLeader) {
        var leaderConnection = this._connections.get(this._clusterLeader);
        if (leaderConnection) {
          haveConnection = true;
          isConnected = leaderConnection.up;
        }
        disconnectFactor = 3;
      } else {
        if (!this._expected.size) {
          this._disconnectedTicks = 0;
          return;
        }
        this._expected.forEach(function (peerId) {
          if (isConnected) {
            return;
          }
          var connection = _this3._connections.get(peerId);
          if (connection) {
            haveConnection = true;
            isConnected = connection.up;
          }
        });
      }
      if (!haveConnection) {
        this._disconnectedTicks += disconnectFactor;
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'has not connection, incremented disconnection ticks to ' + this._disconnectedTicks);
      } else if (!isConnected) {
        this._disconnectedTicks += disconnectFactor;
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'is not connected, incremented disconnection ticks to ' + this._disconnectedTicks);
      } else {
        this._disconnectedTicks = 0;
      }
      if (this._disconnectedTicks > DISCONNECTED_TICK_LIMIT) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'reached disconnection tick limit, signaling disconnect');
        this._clusterLeader = null;
        this._disconnectedTicks = 0;
        this._expected.clear();
        this._expiry.clear();
        this._onDisconnected();
      }
    }
  }, {
    key: '_addConnection',
    value: function _addConnection(peerId) {
      var _this4 = this;

      this._expiry.set(peerId, Date.now() + CONNECTION_TTL_MS);

      if (this._connections.has(peerId)) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'already has a connection to ' + peerId + ', no need to add');
        return;
      }

      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'is adding a connection to ' + peerId);

      var peerLinkInfo = this._meshTopology.localTopologyInfo.addPeer(peerId);
      var connection = this._connectionFactory({ peerId: peerId, peerLinkInfo: peerLinkInfo });
      this._connections.set(peerId, connection);

      // Handling of inbound raft messages, we ignore messages that aren't from the leader when we're joining a cluster.
      connection.raftChannel.on('message', function (message) {
        if (_this4._clusterLeader && peerId !== _this4._clusterLeader) {
          __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].verbose(TAG, 'ignored raft message from ' + peerId + ', only accepting message from cluster leader, ' + (_this4._clusterLeader + ', message: ' + __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_json_stringify___default()(message)));
        }
        _this4._onRaftMessage(peerId, message);
      });

      connection.start();
      return connection;
    }
  }, {
    key: '_removeConnection',
    value: function _removeConnection(peerId) {
      var connection = this._connections.get(peerId);
      if (!connection) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, this, 'could not find removed connection ' + peerId);
        return;
      }
      if (this._expected.has(peerId)) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, this, 'is removing an expected connection, check you logics ' + peerId);
      }
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'will remove connection to ' + peerId);

      this._connections.delete(peerId);
      this._expiry.delete(peerId);
      this._meshTopology.localTopologyInfo.removePeer(peerId);

      connection.close();
    }
  }, {
    key: 'connections',
    get: function get() {
      return this._connections;
    }
  }, {
    key: 'expected',
    get: function get() {
      return this._expected;
    }
  }, {
    key: 'active',
    get: function get() {
      var _this5 = this;

      var active = new __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_set___default.a();
      this._expected.forEach(function (peerId) {
        if (_this5._connections.has(peerId)) {
          active.add(peerId);
        }
      });
      return active;
    }
  }]);

  return ConferenceConnectionPool;
}();

/* harmony default export */ __webpack_exports__["a"] = (ConferenceConnectionPool);

/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ConferencePeer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_get__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_get___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_get__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_utils__ = __webpack_require__(13);













// Copying these instead of importing for better minification
var CONNECTION_STATE_CONNECTED = 'connected';

/**
 * A class representing the state of a single conference peer.
 *
 * @abstract
 * @class ConferencePeer
 * @extends EventEmitter
 */
var ConferencePeer = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default()(ConferencePeer, _EmitterMixin);

  function ConferencePeer(id, onUpdate) {
    __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, ConferencePeer);

    var _this = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConferencePeer.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(ConferencePeer)).call(this));

    _this._id = id;
    _this._errorState = null;
    _this._connectionState = null;
    _this._onUpdate = onUpdate;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(ConferencePeer, [{
    key: 'toString',
    value: function toString() {
      return 'conferencePeer{id=' + this._id + ',state=' + this._connectionState + ',error=' + this._errorState + '}';
    }

    /**
     * The id of the peer.
     *
     * @readonly
     * @member {UserId} ConferencePeer#id
     */

  }, {
    key: '_setErrorState',
    value: function _setErrorState(errorState) {
      if (this._errorState !== errorState) {
        this._errorState = errorState;
        this._emit('errorState', errorState);
        this._onUpdate();
      }
    }
  }, {
    key: '_setConnectionState',
    value: function _setConnectionState(newState, oldState) {
      if (this._connectionState !== newState) {
        this._connectionState = newState;
        this._emit('connectionState', newState, oldState);
        this._onUpdate();
      }
    }
  }, {
    key: '_clear',
    value: function _clear() {
      this._setErrorState(null);
      this._setConnectionState(null, this._connectionState);
      this._clearListeners();
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }

    /**
     * Emitted when the error state of the connection to the peer is changed.
     *
     * @event ConferencePeer#errorState
     * @param {(ConnectionFailedError|ConnectionLostError)?} error - A new error, or null.
     */

    /**
     * The error state of the peer. This will be null if there is no current problem with the call.
     *
     * @readonly
     * @member {(ConnectionFailedError|ConnectionLostError)?} ConferencePeer#errorState
     */

  }, {
    key: 'errorState',
    get: function get() {
      return this._errorState;
    }

    /**
     * Emitted when the state of the connection to the peer is changed.
     *
     * @event ConferencePeer#connectionState
     * @param {PeerConnectionState} connectionState - The new connection state.
     * @param {PeerConnectionState} oldConnectionState - The old connection state.
     */

    /**
     * The connection state of the peer.
     *
     * @readonly
     * @member {PeerConnectionState} ConferencePeer#connectionState
     */

  }, {
    key: 'connectionState',
    get: function get() {
      return this._connectionState;
    }
  }]);

  return ConferencePeer;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_emitter__["a" /* default */])(null));

/**
 * I collection representing all peers in a confernece.
 *
 * Each value in the map is a {@link ConferencePeer} instance, and the key is the {@link UserId} of that peer.
 *
 * @abstract
 * @class ConferencePeers
 * @extends EventEmitter
 * @extends ReadOnlyMap
 */

var ConferencePeers = function (_EmitterMixin2) {
  __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_inherits___default()(ConferencePeers, _EmitterMixin2);

  function ConferencePeers(_ref) {
    var ownId = _ref.ownId,
        onUpdate = _ref.onUpdate;

    __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_classCallCheck___default()(this, ConferencePeers);

    var _this2 = __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConferencePeers.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(ConferencePeers)).call(this));

    _this2._onPeerUpdate = _this2._onPeerUpdate.bind(_this2);

    _this2._ownId = ownId;
    _this2._onUpdate = onUpdate;
    return _this2;
  }

  /**
   * Provited a way to iterate though all the peer IDs in this map.
   *
   * @function ConferencePeers#keys
   * @returns {Iterator<UserId>} - An iterator of all peer IDs in this map.
   */

  /**
   * Provited a way to iterate though all the peers in this map.
   *
   * @function ConferencePeers#values
   * @returns {Iterator<ConferencePeer>} - An iterator of all peers in this map.
   */

  /**
   * Returns the peer for the given userId.
   *
   * @function ConferencePeers#get
   * @param {UserId} peerId - The id of the peer to retreive.
   * @returns {ConferencePeer} The peer, if it exists, `undefined` otherwise
   */

  /**
   * Returns true if the map has an entry for the given peerId.
   *
   * @function ConferencePeers#has
   * @param {UserId} peerId - The peerId to look for.
   */

  /**
   * Synchronously calls an interator function once for each entry in the map.
   *
   * Errors thrown inside the iterator function will cancel the iteration
   *
   * @function ConferencePeers#forEach
   * @param {ConferencePeersForEachCallback} func - The iterator function.
   * @param {*} [thisArg] - The value to use as `this` inside the iterator function.
   */

  /**
   * The iterator function passed to {@link ConferencePeers#forEach}.
   *
   * @callback ConferencePeersForEachCallback
   * @param {UserId} peerId - The peerId of the current entry.
   * @param {ConferencePeer} peer - The value of the current entry.
   * @param {ConferencePeers} peers - The peer map itself.
   */

  /**
   * Emitted when peers are added or removed.
   *
   * @event ConferencePeers#update
   * @param {ConferencePeers} peers - The peer collection itself.
   */

  /**
   * Emitted when peers are added or removed, or when any of the peers change state.
   *
   * @event ConferencePeers#deepUpdate
   * @param {ConferencePeers} peers - The peer collection itself.
   */

  /**
   * Emitted when a peer is added to the conference.
   *
   * @event ConferencePeers#added
   * @param {UserId} peerId - The id of the peer that was added.
   * @param {ConferencePeer} peer - The peer that was added
   */

  /**
   * Emitted when a peer is removed from the conference.
   *
   * @event ConferencePeers#removed
   * @param {UserId} peerId - The id of the peer that was removed.
   */

  // Connecitons need to be known here so that we can update peers before add events are
  // emitted, while keeping the add and remove events consistent with the state of the map.


  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_createClass___default()(ConferencePeers, [{
    key: '_setPeers',
    value: function _setPeers(peerIds, connections) {
      var _this3 = this;

      peerIds = new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_set___default.a(peerIds);
      peerIds.delete(this._ownId);

      var _diff = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_utils__["diff"])(this.keys(), peerIds),
          _diff2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_diff, 2),
          added = _diff2[0],
          removed = _diff2[1];

      removed.forEach(function (peerId) {
        var peer = _this3.get(peerId);
        peer._clear();
        var connection = connections.get(peerId);
        if (connection) {
          connection._setConferencePeer(null);
        }
        _this3._delete(peerId);
        _this3._emit('removed', peerId);
      });
      added.forEach(function (peerId) {
        var peer = new ConferencePeer(peerId, _this3._onPeerUpdate);
        var connection = connections.get(peerId);
        if (connection) {
          connection._setConferencePeer(peer);
        }
        _this3._set(peerId, peer);
        _this3._emit('added', peerId, peer);
      });

      if (added.length || removed.length) {
        this._emit('update', this);
        this._onUpdate();
        this._emit('deepUpdate', this);
      }
    }
  }, {
    key: '_onPeerUpdate',
    value: function _onPeerUpdate() {
      this._onUpdate();
      this._emit('deepUpdate', this);
    }
  }, {
    key: '_hasConnection',
    value: function _hasConnection() {
      var connected = false;
      this.forEach(function (peer) {
        if (!connected && peer.connectionState === CONNECTION_STATE_CONNECTED) {
          connected = true;
        }
      });
      return connected;
    }
  }, {
    key: '_clear',
    value: function _clear() {
      var _this4 = this;

      var updated = this.size !== 0;
      this.forEach(function (peer, peerId) {
        peer._clear();
        _this4._emit('removed', peerId);
      });
      __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_get___default()(ConferencePeers.prototype.__proto__ || __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_get_prototype_of___default()(ConferencePeers.prototype), '_clear', this).call(this);
      if (updated) {
        this._emit('update', this);
        this._emit('deepUpdate', this);
      }
    }
  }, {
    key: '_cleanup',
    value: function _cleanup() {
      this._clear();
      this._clearListeners();
    }
  }]);

  return ConferencePeers;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_9_common_utils__["ReadOnlyMap"]));

/* harmony default export */ __webpack_exports__["a"] = (ConferencePeers);

/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_media_passthrough__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_webrtc_rtcComponent__ = __webpack_require__(160);












var _switcherModeBreakdow;











var TAG = 'conference-switcher';

var VOICE_DETECTION_INTERVAL_MS = 100;
var VOICE_DETECTION_BACKOFF_MS = 2500;

var RelayLinks = function () {
  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(RelayLinks, null, [{
    key: 'parse',
    value: function parse(data) {
      if (!data) {
        return null;
      }
      __WEBPACK_IMPORTED_MODULE_10_common_argCheck__["a" /* default */].array('RelayLinks.parse', 'data', data);
      if (data.length % 2 !== 0) {
        throw new TypeError('relay links array length must be even, was ' + data.length);
      }
      var length = data.length;
      var userIds = data.slice(0, (length - 2) / 2);
      var parents = data.slice((length - 2) / 2, length - 2);
      var speakers = data.slice(length - 2, length);
      return new RelayLinks(userIds, parents, speakers);
    }
  }, {
    key: 'createEmpty',
    value: function createEmpty(memberIds) {
      var userIds = [].concat(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default()(memberIds)).sort();
      var parents = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_common_utils__["fill"])(Array(userIds.length), -1);
      var speakers = [0, 0];
      return new RelayLinks(userIds, parents, speakers);
    }
  }]);

  function RelayLinks(userIds, parents, speakers) {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, RelayLinks);

    // An array of all members, in a determined order
    this._userIds = userIds;
    // An array with the same length as the number of userIds. Each element in the array represents
    // a link from the element to the index of that element in the array. Where the element and index
    // are the indices in the userIds array. An element of -1 means there's no link to that userId.
    // e.g. userIds = [a, b, c], parents = [1, 2, -1], links = b -> a, c -> b,
    this._parents = parents;
    // An array with two elements, the index of the primary and the secondary speakers in the userIds array
    this._speakers = speakers;
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(RelayLinks, [{
    key: 'toString',
    value: function toString() {
      var _this = this;

      var links = [];
      this._parents.forEach(function (sourceIndex, targetIndex) {
        var targetId = _this._userIds[targetIndex];
        if (!links[sourceIndex]) {
          links[sourceIndex] = [targetId];
        } else {
          links[sourceIndex].push(targetId);
        }
      });
      var linkStrs = [];
      this._userIds.forEach(function (sourceId, sourceIndex) {
        if (links[sourceIndex]) {
          linkStrs.push(sourceId + '->[' + links[sourceIndex].join(',') + ']');
        }
      });
      return 'relayLinks{' + linkStrs.join(',') + '}';
    }
  }, {
    key: 'toJSON',
    value: function toJSON() {
      return this._userIds.concat(this._parents).concat(this._speakers);
    }
  }, {
    key: 'insert',
    value: function insert(source, target) {
      var sourceIndex = this._userIds.indexOf(source);
      var targetIndex = this._userIds.indexOf(target);
      this._parents[targetIndex] = sourceIndex;
    }
  }, {
    key: 'setSpeakers',
    value: function setSpeakers(primaryId, secondaryId) {
      this._speakers[0] = this._userIds.indexOf(primaryId);
      this._speakers[1] = this._userIds.indexOf(secondaryId);
    }
  }, {
    key: 'getSpeakers',
    value: function getSpeakers() {
      var _speakers = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(this._speakers, 2),
          primaryIndex = _speakers[0],
          secondaryIndex = _speakers[1];

      return [this._userIds[primaryIndex], this._userIds[secondaryIndex]];
    }
  }, {
    key: 'getParentOf',
    value: function getParentOf(userId) {
      var index = this._userIds.indexOf(userId);
      if (index < 0) {
        return null;
      }
      var parentIndex = this._parents[index];
      return this._userIds[parentIndex];
    }
  }, {
    key: 'getChildrenOf',
    value: function getChildrenOf(userId) {
      var index = this._userIds.indexOf(userId);
      if (index < 0) {
        return [];
      }
      var childIds = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default.a();
      for (var childIndex = 0; childIndex < this._parents.length; childIndex += 1) {
        var parentIndex = this._parents[childIndex];
        if (parentIndex === index) {
          // we are the parent
          var childId = this._userIds[childIndex];
          childIds.add(childId);
        }
      }
      return childIds;
    }
  }, {
    key: 'equals',
    value: function equals(otherLinks) {
      if (!otherLinks) {
        return false;
      }
      if (this === otherLinks) {
        return true;
      }
      var linksA = this._userIds;
      var linksB = otherLinks._userIds;
      if (linksA.length !== linksB.length) {
        return false;
      }

      for (var i = 0; i < linksA.length; i += 1) {
        if (linksA[i] !== linksB[i]) {
          return false;
        }
      }

      var parentsA = this._parents;
      var parentsB = otherLinks._parents;
      for (var _i = 0; _i < parentsA.length; _i += 1) {
        if (parentsA[_i] !== parentsB[_i]) {
          return false;
        }
      }

      return true;
    }
  }]);

  return RelayLinks;
}();

var SwitcherComponent = function (_RtcComponent) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(SwitcherComponent, _RtcComponent);

  function SwitcherComponent() {
    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, SwitcherComponent);

    var _this2 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (SwitcherComponent.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(SwitcherComponent)).call(this, { label: 'cct.conference.switcher' }));

    _this2._input = new __WEBPACK_IMPORTED_MODULE_14_media_passthrough__["a" /* default */]();
    _this2._output = new __WEBPACK_IMPORTED_MODULE_14_media_passthrough__["a" /* default */]();

    _this2._parentId = null;
    _this2._childrenIds = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default.a();
    _this2._primarySpeaker = null;
    return _this2;
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(SwitcherComponent, [{
    key: 'rtcComponentDidReceivePeer',
    value: function rtcComponentDidReceivePeer() {
      this._updateRelayState();
    }
  }, {
    key: 'rtcComponentDidLosePeer',
    value: function rtcComponentDidLosePeer(peer) {
      // TODO: fix TypeError: this._childrenIds.delete is not a function
      this._childrenIds.delete(peer.id);
      this._updateRelayState();
    }
  }, {
    key: 'setRelayState',
    value: function setRelayState(parentId, childrenIds, primarySpeaker) {
      this._parentId = parentId;
      this._childrenIds = childrenIds;
      this._primarySpeaker = primarySpeaker;
      this._updateRelayState();
    }
  }, {
    key: '_updateRelayState',
    value: function _updateRelayState() {
      var _this3 = this;

      var peers = this.attachPoint.peers;

      // Start by clearing all connections, updates are deferred so identical setups will not cause a renegotiation

      if (this._input.output.targets.size) {
        this._input.disconnect();
      }
      this.attachPoint.peers.forEach(function (peer) {
        if (peer.output.targets.size) {
          peer.disconnect();
        }
      });

      if (this._parentId === this.attachPoint.ownId) {
        this._input.connect(this._output);
      } else if (this._parentId) {
        var parent = peers.get(this._parentId);
        if (parent) {
          parent.connect(this._output);
        }
      }

      var relaySource = null;
      if (this._primarySpeaker === this.attachPoint.ownId) {
        // We're the primary speaker, forward our own stream
        relaySource = this._input;
      } else if (this._parentId) {
        // We've got a parent, forward the stream we're receiving from it
        relaySource = peers.get(this._parentId);
      }

      if (!relaySource) {
        // We've got no parent or got ourselves as parent
        return;
      }

      this._childrenIds.forEach(function (targetId) {
        var target = peers.get(targetId);
        if (target) {
          // If the target is the primary speaker we're the secondary speaker and should send our own stream
          // Note that we can't just check if we're the secondary direcly because the secondary speaker
          // might still relay primary streams simultaneously.
          if (_this3._primarySpeaker === targetId) {
            _this3._input.connect(target);
          } else {
            relaySource.connect(target);
          }
        }
      });
    }
  }]);

  return SwitcherComponent;
}(__WEBPACK_IMPORTED_MODULE_15_webrtc_rtcComponent__["a" /* default */]);

/**
 * @typedef {'off'|'manual'|'manual/follow'|'manual/automatic'|'automatic'} ConferenceSwitcherMode
 *
 * A string representing the connection state of a peer connection.
 *
 * - `'off'` - The switching functionality is turned off and will not consume any resources.
 * - `'manual'` - Speaker switching is done manually with {@link ConferenceSwitcher#requestPrimarySpeaker}
 *  and {@link ConferenceSwitcher#requestSecondarySpeaker}. Both speakers are chosen from
 *  {@link ConferenceSwitcher#selectedPrimarySpeaker} and {@link ConferenceSwitcher#selectedSecondarySpeaker}.
 * - `'manual/follow'` - The primary speaker is selected manually, and the secondary speaker will
 *                         always be the previous primary speaker.
 * - `'manual/automatic'` - The primary speaker is selected manually, and the secondary speaker
 *                           is automatically selected using active speaker detection.
 * - `'automatic'` - The primary speaker is automatically selected using active speaker detection,
 *                    and the secondary speaker will always be the previous primary speaker.
 */

var MODE_OFF = 'off';
var MODE_MANUAL = 'manual';
var MODE_MANUAL_FOLLOW = 'manual/follow';
var MODE_MANUAL_AUTOMATIC = 'manual/automatic';
var MODE_AUTOMATIC = 'automatic';

// Modes 'automatic' and 'manual/automatic' are not yet implemented
var MODES = [MODE_OFF, MODE_MANUAL, MODE_MANUAL_FOLLOW, MODE_MANUAL_AUTOMATIC, MODE_AUTOMATIC];

var STATE_KEY_MODE = 'sw-mode';
var STATE_KEY_PRIMARY_SPEAKER = 'sw-speaker-1';
var STATE_KEY_SECONDARY_SPEAKER = 'sw-speaker-2';
var STATE_KEY_LINKS = 'sw-links';

var switcherModeBreakdown = (_switcherModeBreakdow = {}, __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_switcherModeBreakdow, MODE_OFF, null), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_switcherModeBreakdow, MODE_MANUAL, { primaryMode: 'manual', secondaryMode: 'manual' }), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_switcherModeBreakdow, MODE_MANUAL_FOLLOW, { primaryMode: 'manual', secondaryMode: 'follow' }), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_switcherModeBreakdow, MODE_MANUAL_AUTOMATIC, { primaryMode: 'manual', secondaryMode: 'automatic' }), __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_defineProperty___default()(_switcherModeBreakdow, MODE_AUTOMATIC, { primaryMode: 'automatic', secondaryMode: 'follow' }), _switcherModeBreakdow);

/**
 * A media switcher for conferences, with the primary purpose of allowing high-quality
 * video to be sent from one member of the conference to the rest. The video is sent
 * in a way that distributes the bandwidth and processing requirements across all nodes.
 *
 * The switcher can operate in a couple of different modes, with the default one being
 * `'off'`. The modes enable different way of selecting which conference members should
 * be sending video to other members.
 *
 * The distributed nature of the switcher can be a bit confusing, for example, when
 * joining a conference, every participant should set the switcherMode to whetever
 * makes sense in the application. It is up to the application to make sure that
 * the switcherMode configuration is consistent across members, usually by simply
 * setting a default value, but other mechanisms could be used. The way this works
 * under the hood is that whoever joins the conference first gets to choose the
 * switcherMode, while the rest will be ignored.
 *
 * @abstract
 * @class ConferenceSwitcher
 * @extends EventEmitter
 * @extends ConnectMixin
 */

var ConferenceSwitcher = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_inherits___default()(ConferenceSwitcher, _EventEmitter);

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(ConferenceSwitcher, null, [{
    key: 'modeUsesVoiceDetection',

    /**
     * Emitted when the primary speaker of the conference changes.
     *
     * @event ConferenceSwitcher#mode
     * @param {UserId} mode - The new primary speaker.
     */

    /**
     * Emitted when the selected primary speaker of the conference changes.
     *
     * See {@link ConferenceSwitcher#selectedPrimarySpeaker} for more details.
     *
     * @event ConferenceSwitcher#selectedPrimarySpeaker
     * @param {UserId} selectedPrimarySpeaker - The new selected primary speaker.
     */

    /**
     * Emitted when the primary speaker of the conference changes.
     *
     * See {@link ConferenceSwitcher#selectedSecondarySpeaker} for more details.
     *
     * @event ConferenceSwitcher#selectedSecondarySpeaker
     * @param {UserId} selectedSecondarySpeaker - The new selected secondary speaker.
     */

    /**
     * Emitted when the primary speaker of the conference changes.
     *
     * See {@link ConferenceSwitcher#primarySpeaker} for more details.
     *
     * @event ConferenceSwitcher#primarySpeaker
     * @param {UserId} primarySpeaker - The new primary speaker.
     */

    /**
     * Emitted when the primary speaker of the conference changes.
     *
     * See {@link ConferenceSwitcher#secondarySpeaker} for more details.
     *
     * @event ConferenceSwitcher#secondarySpeaker
     * @param {UserId} secondarySpeaker - The new secondary speaker.
     */

    /**
     * Emitted when the primary speaker of the conference changes.
     *
     * See {@link ConferenceSwitcher#speaker} for more details.
     *
     * @event ConferenceSwitcher#speaker
     * @param {UserId} speaker - The new speaker.
     */

    value: function modeUsesVoiceDetection() {
      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MODE_OFF;

      if (mode === MODE_OFF) {
        return false;
      }
      var _switcherModeBreakdow2 = switcherModeBreakdown[mode],
          primaryMode = _switcherModeBreakdow2.primaryMode,
          secondaryMode = _switcherModeBreakdow2.secondaryMode;

      return primaryMode === 'automatic' || secondaryMode === 'automatic';
    }
  }]);

  function ConferenceSwitcher(_ref) {
    var ownId = _ref.ownId,
        raft = _ref.raft,
        mode = _ref.mode;

    __WEBPACK_IMPORTED_MODULE_7_babel_runtime_helpers_classCallCheck___default()(this, ConferenceSwitcher);

    var _this4 = __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ConferenceSwitcher.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(ConferenceSwitcher)).call(this));

    _this4._onTopologyChange = _this4._onTopologyChange.bind(_this4);
    _this4._voiceDetectionTick = _this4._voiceDetectionTick.bind(_this4);

    _this4._ownId = ownId;
    _this4._raft = raft;
    _this4._mode = null;
    _this4._defaultMode = mode || MODE_OFF;
    _this4._meshTopology = raft.log.meshTopology;

    _this4._speaker = null;
    _this4._primarySpeaker = null;
    _this4._secondarySpeaker = null;
    _this4._selectedPrimarySpeaker = null;
    _this4._selectedSecondarySpeaker = null;
    _this4._loudestPeer = null;

    _this4._component = new SwitcherComponent();
    _this4._isLeader = false;
    // A sorted list of conference members, earlier in the list means the member was a more recent speaker
    _this4._memberIds = [];

    _this4._setMode(_this4._defaultMode);
    _this4._meshTopology.addChangeListener(_this4._onTopologyChange);
    return _this4;
  }

  __WEBPACK_IMPORTED_MODULE_8_babel_runtime_helpers_createClass___default()(ConferenceSwitcher, [{
    key: 'toString',
    value: function toString() {
      return 'switcher{ownId=' + this._ownId + ',mode=' + this._mode + ',speaker=' + this._speaker + '}';
    }
  }, {
    key: '_getLocalStreamsForPeer',
    value: function _getLocalStreamsForPeer(peerId) {}
  }, {
    key: '_setMode',
    value: function _setMode(mode) {
      if (mode === this._mode) {
        return;
      }
      this._mode = mode;
      this._emit('mode', mode);

      var useVoice = ConferenceSwitcher.modeUsesVoiceDetection(this._mode);
      this._setVoiceDetectionEnabled(this._isLeader ? useVoice : false);
      this._meshTopology.localTopologyInfo.setVoiceActivityDetectorActive(useVoice);
    }
  }, {
    key: '_setVoiceDetectionEnabled',
    value: function _setVoiceDetectionEnabled(enabled) {
      if (enabled) {
        if (!this._voiceDetectionIntervalId) {
          this._voiceDetectionIntervalId = setInterval(this._voiceDetectionTick, VOICE_DETECTION_INTERVAL_MS);
        }
      } else {
        if (this._voiceDetectionIntervalId) {
          clearInterval(this._voiceDetectionIntervalId);
          this._voiceDetectionIntervalId = null;
        }
        if (this._voiceDetectionTimeoutId) {
          clearTimeout(this._voiceDetectionTimeoutId);
          this._voiceDetectionTimeoutId = null;
        }
      }
    }
  }, {
    key: '_voiceDetectionTick',
    value: function _voiceDetectionTick() {
      var _this5 = this;

      var currentLoudest = this._loudestPeer;
      // Array of [volume, peerId] pairs
      var volumes = [];
      this._meshTopology.topologyInfos.forEach(function (topologyInfo, peerId) {
        volumes.push([topologyInfo.volume, peerId]);
      });
      if (volumes.length === 0) {
        this._loudestPeer = null;
      }
      volumes.sort(function (a, b) {
        return b[0] - a[0]; // descending order
      });
      var loudest = volumes[0][1];
      if (loudest !== currentLoudest) {
        this._loudestPeer = loudest;
        this._refreshRelayTree();

        // Turn off voice switching for a bit after selecting a new speaker
        this._setVoiceDetectionEnabled(false);
        this._voiceDetectionTimeoutId = setTimeout(function () {
          _this5._setVoiceDetectionEnabled(true);
          _this5._voiceDetectionTimeoutId = null;
        }, VOICE_DETECTION_BACKOFF_MS);
      }
    }
  }, {
    key: '_setDefaultMode',
    value: function _setDefaultMode() {
      var defaultMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MODE_OFF;

      __WEBPACK_IMPORTED_MODULE_10_common_argCheck__["a" /* default */].values('ConferenceSwitcher defaultMode', 'mode', defaultMode, MODES);
      this._defaultMode = defaultMode;
      this._setMode(this._defaultMode);
    }
  }, {
    key: '_initializeLeader',
    value: function _initializeLeader() {
      this._raft.set(STATE_KEY_MODE, this._defaultMode);
      this._raft.set(STATE_KEY_LINKS, null);
      this._raft.set(STATE_KEY_PRIMARY_SPEAKER, this._ownId);
      this._raft.set(STATE_KEY_SECONDARY_SPEAKER, this._ownId);
    }

    /**
     * Requests a new switching mode to be used in the conference. Whether this call
     * succeeds depends on the current state of the conference and if other clients
     * are requesting new modes at the same time.
     *
     * It's also not guaranteed that the switcher mode is set to the requested value
     * when this call succeeds, as another conference member might have set another
     * value just afterwards.
     *
     * To get this to work well with a UI, one should rely on this method to do the
     * request and to get feedback about whether it was successfull. If the application
     * displays the current switcher mode somewhere, that should be hooked up to the
     * {@link event:ConferenceSwitcher.mode} event.
     *
     * @param {ConferenceSwitcherMode} mode - The new mode to request a switch to.
     * @returns {Promise} A promise that is resolved if the request is successful, or
     *                      rejected if it fails.
     */

  }, {
    key: 'requestMode',
    value: function requestMode(mode) {
      __WEBPACK_IMPORTED_MODULE_10_common_argCheck__["a" /* default */].values('ConferenceSwitcher.requestMode', 'mode', mode, MODES);
      return this._raft.set(STATE_KEY_MODE, mode);
    }

    /**
     * The current switcher mode of the conference.
     *
     * This could be changed at any point because some other client or oneself request
     * a new switcher mode. One should listen to the {@link event:ConferenceSwitcher.mode}
     * event to get notifications for when it's changed.
     *
     * @readonly
     * @member {ConferenceSwitcherMode} ConferenceSwitcher#mode
     */

  }, {
    key: 'requestPrimarySpeaker',


    /**
     * Requests a new primary speaker of the conference.
     *
     * This behaves similarly to {@link ConferenceSwitcher#requestMode}.
     *
     * @param {UserId} userId - The id of the primary speaker to request.
     * @returns {Promise} A promise that is resolved if the request is successful, or
     *                      rejected if it fails.
     */
    value: function requestPrimarySpeaker(userId) {
      __WEBPACK_IMPORTED_MODULE_10_common_argCheck__["a" /* default */].string('ConferenceSwitcher.requestPrimarySpeaker', userId, userId);
      return this._raft.set(STATE_KEY_PRIMARY_SPEAKER, userId);
    }

    /**
     * The currently selected primary speaker. This is not always the same as the
     * primary speaker, since e.g. in automatic switching mode, the primary speaker
     * will be chosen based on audio level instead of this property.
     *
     * @readonly
     * @member {ConferenceSwitcherMode} ConferenceSwitcher#mode
     */

  }, {
    key: 'requestSecondarySpeaker',


    /**
     * Requests a new secondary speaker of the conference.
     *
     * This behaves similarly to {@link ConferenceSwitcher#requestMode}.
     *
     * @param {UserId} userId - The id of the secondary speaker to request.
     * @returns {Promise} A promise that is resolved if the request is successful, or
     *                      rejected if it fails.
     */
    value: function requestSecondarySpeaker(userId) {
      __WEBPACK_IMPORTED_MODULE_10_common_argCheck__["a" /* default */].string('ConferenceSwitcher.requestSecondarySpeaker', userId, userId);
      return this._raft.set(STATE_KEY_SECONDARY_SPEAKER, userId);
    }

    /**
     * The currently selected secondary speaker. This is not always the same as the
     * secondary speaker, since e.g. in automatic and follow modes, the secondary speaker
     * will be chosen based on who the previous primary speaker was.
     *
     * @readonly
     * @member {ConferenceSwitcherMode} ConferenceSwitcher#mode
     */

  }, {
    key: 'setAudioBroadcaster',


    /**
     * Sets the audio broadcaster to use for voice activated video switching.
     *
     * @private
     * @param {MediaBroadcaster} broadcaster - A broadcaster instance that is used to broadcast audio.
     */
    value: function setAudioBroadcaster(broadcaster) {}
    // TODO: implement


    /**
     * The media input for the switcher.
     *
     * @readonly
     * @member {MediaNodeInput} ConferenceSwitcher#input
     */

  }, {
    key: '_handleLeadershipChange',
    value: function _handleLeadershipChange(isLeader) {
      this._isLeader = isLeader;
      var useVoice = ConferenceSwitcher.modeUsesVoiceDetection(this._mode);
      if (isLeader) {
        __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, this, 'recalculating relay tree due to becoming leader');
        this._refreshRelayTree();
        this._setVoiceDetectionEnabled(useVoice);
      } else {
        this._setVoiceDetectionEnabled(false);
      }
      this._meshTopology.localTopologyInfo.setVoiceActivityDetectorActive(useVoice);
    }
  }, {
    key: '_handleStateChange',
    value: function _handleStateChange() {
      var needUpdate = false;
      var mode = this._raft.get(STATE_KEY_MODE) || this._defaultMode;
      if (mode !== this._mode) {
        this._setMode(mode);
        if (this._isLeader) {
          __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, this, 'recalculating relay tree because of mode change');
          needUpdate = true;
        }
      }
      var primarySpeaker = this._raft.get(STATE_KEY_PRIMARY_SPEAKER);
      if (primarySpeaker !== this._selectedPrimarySpeaker) {
        this._selectedPrimarySpeaker = primarySpeaker;
        this._emit('selectedPrimarySpeaker', primarySpeaker);
        if (this._isLeader) {
          __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, this, 'recalculating relay tree because of primary speaker change');
          needUpdate = true;
        }
      }
      var secondarySpeaker = this._raft.get(STATE_KEY_SECONDARY_SPEAKER);
      if (secondarySpeaker !== this._selectedSecondarySpeaker) {
        this._selectedSecondarySpeaker = secondarySpeaker;
        this._emit('selectedSecondarySpeaker', secondarySpeaker);
        if (this._isLeader) {
          __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, this, 'recalculating relay tree because of secondary speaker change');
          needUpdate = true;
        }
      }

      if (needUpdate) {
        this._refreshRelayTree();
      }

      var relayLinkData = this._raft.get(STATE_KEY_LINKS);
      var relayLinks = RelayLinks.parse(relayLinkData);
      if (relayLinks) {
        var parentId = relayLinks.getParentOf(this._ownId);
        var childrenIds = relayLinks.getChildrenOf(this._ownId);

        var _relayLinks$getSpeake = relayLinks.getSpeakers(),
            _relayLinks$getSpeake2 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_relayLinks$getSpeake, 2),
            primaryId = _relayLinks$getSpeake2[0],
            secondaryId = _relayLinks$getSpeake2[1];

        primarySpeaker = primaryId;

        if (primaryId !== this._primarySpeaker) {
          this._primarySpeaker = primaryId;
          this._emit('primarySpeaker', primaryId);
        }
        if (secondaryId !== this._secondarySpeaker) {
          this._secondarySpeaker = secondaryId;
          this._emit('secondarySpeaker', secondaryId);
        }

        var speaker = this._primarySpeaker;
        if (this._primarySpeaker === this._ownId) {
          speaker = this._secondarySpeaker;
        }
        if (speaker !== this._speaker) {
          this._speaker = speaker;
          this._emit('speaker', speaker);
        }
        this._component.setRelayState(parentId, childrenIds, primaryId);
      } else {
        this._component.setRelayState(null, new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default.a(), null);
      }
      this._emit('_relayLinks');
    }
  }, {
    key: '_setMembers',
    value: function _setMembers(memberIds) {
      var _memberIds;

      var memberIdsCopy = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default.a(memberIds);
      // Filter out ids from priority list that are no longer present, while maintaining pririty order.
      this._memberIds = this._memberIds.filter(function (userId) {
        return memberIdsCopy.delete(userId);
      });
      // We also delete the ids that are present from the copy, so that we end up with a set of IDs
      // that are missing and need to be added to the priority list.
      (_memberIds = this._memberIds).push.apply(_memberIds, __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default()(memberIdsCopy));
      if (this._isLeader) {
        __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, this, 'recalculating relay tree because of members change');
        this._refreshRelayTree();
      }
    }
  }, {
    key: '_onTopologyChange',
    value: function _onTopologyChange(topology) {
      if (this._isLeader) {
        __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, this, 'recalculating relay tree because of topology change');
        this._refreshRelayTree();
      }
    }
  }, {
    key: '_refreshRelayTree',
    value: function _refreshRelayTree() {
      if (this._mode === MODE_OFF) {
        return;
      }

      var _switcherModeBreakdow3 = switcherModeBreakdown[this._mode],
          primaryMode = _switcherModeBreakdow3.primaryMode,
          secondaryMode = _switcherModeBreakdow3.secondaryMode;


      var primaryId = void 0;
      if (primaryMode === 'manual') {
        primaryId = this._selectedPrimarySpeaker;
      } else if (primaryMode === 'automatic') {
        primaryId = this._loudestPeer;
      }

      if (!primaryId) {
        __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].debug(TAG, this, 'skipped relay tree rebuild, no active speaker');
        return;
      }

      {
        var index = this._memberIds.indexOf(primaryId);
        if (index >= 0) {
          this._memberIds.splice(index, 1);
          this._memberIds.unshift(primaryId);
        } else {
          __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].debug(TAG, this, 'active speaker is not a member of the conference, skipping relay tree build');
          return;
        }
      }

      var topologyInfos = this._meshTopology.topologyInfos;

      if (!topologyInfos.get(primaryId)) {
        __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].warning(TAG, this, "doesn't have topology info for active speaker, can't build relay tree yet");
        return;
      }

      var targetIds = new __WEBPACK_IMPORTED_MODULE_4_babel_runtime_core_js_set___default.a(this._memberIds);

      var powers = {};
      targetIds.forEach(function (targetId) {
        var power = 1;
        var targetInfo = topologyInfos.get(targetId);
        if (targetInfo) {
          power = targetInfo.power;
        }
        powers[targetId] = power;
      });

      var secondaryId = primaryId;

      if (secondaryMode === 'manual') {
        if (targetIds.has(this._selectedSecondarySpeaker)) {
          secondaryId = this._selectedSecondarySpeaker;
        }
      } else if (secondaryMode === 'follow') {
        secondaryId = this._memberIds[1] || primaryId;
      } else if (secondaryMode === 'automatic') {
        secondaryId = this._loudestPeer || this._memberIds[1] || primaryId;
      }

      var relayLinks = RelayLinks.createEmpty(targetIds);
      var sourceId = primaryId;
      var sourceQueue = [];

      targetIds.delete(primaryId);

      if (secondaryId) {
        relayLinks.insert(secondaryId, primaryId);
        if (secondaryId !== primaryId) {
          powers[secondaryId] -= 1;
        }
      }

      while (targetIds.size) {
        var sourcePower = powers[sourceId] || 1;

        var _loop = function _loop() {
          // sourceInfo should always be set, because we verify it for active speaker and only push
          // sources with info to the queue
          var sourceInfo = topologyInfos.get(sourceId);
          // go through all targets and figure out the 'best' ones
          var ordered = [].concat(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_toConsumableArray___default()(targetIds)).map(function (targetId) {
            var linkInfo = sourceInfo.links[targetId];
            var rttMs = linkInfo ? linkInfo.rttMs : Infinity;
            if (rttMs < 0) {
              rttMs = Infinity;
            }
            var power = powers[targetId];
            return [power, rttMs, targetId];
          }).sort(function (_ref2, _ref3) {
            var _ref5 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_ref2, 2),
                p1 = _ref5[0],
                r1 = _ref5[1];

            var _ref4 = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_slicedToArray___default()(_ref3, 2),
                p2 = _ref4[0],
                r2 = _ref4[1];

            if (p1 !== p2) {
              return p2 - p1; // high target power is better
            } else {
              return r1 - r2; // lower rtt is better
            }
          });

          var bestTargetId = ordered[0][2];
          targetIds.delete(bestTargetId);
          relayLinks.insert(sourceId, bestTargetId);

          if (topologyInfos.get(bestTargetId)) {
            sourceQueue.push(bestTargetId);
          }
        };

        for (; sourcePower > 0 && targetIds.size; sourcePower -= 1) {
          _loop();
        }

        sourceId = sourceQueue.shift();
        if (!sourceId && targetIds.size) {
          // TODO: To make this less frequent, the algorithm should probably prefer targets that we have
          // topology information for, and also targets with more links. It needs to be weighted properly
          // though, which makes it a bit non-trivial to implement.
          __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].warning(TAG, this, 'ran out of source nodes for relay tree, tree is incomplete');
          break;
        }
      }

      relayLinks.setSpeakers(primaryId, secondaryId);

      var currentLinks = RelayLinks.parse(this._raft.get(STATE_KEY_LINKS));
      if (!relayLinks.equals(currentLinks)) {
        __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].info(TAG, this, 'computed new relay links: ' + relayLinks);

        __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, this, 'built new relay tree based on the following topology:');
        topologyInfos.forEach(function (topologyInfo, userId) {
          __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, '    peer: ' + userId);
          __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, '        power: ' + topologyInfo.power);
          __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, '        links:');
          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_12_common_utils__["forEach"])(topologyInfo.links, function (link, peerId) {
            __WEBPACK_IMPORTED_MODULE_9_common_log__["default"].verbose(TAG, '            ' + peerId + ' => ' + link);
          });
        });
        // toJSON, otherwise local representation will be incorrect
        this._raft.set(STATE_KEY_LINKS, relayLinks.toJSON());
      }
    }
  }, {
    key: '_invalidate',
    value: function _invalidate() {
      this._meshTopology.removeChangeListener(this._onTopologyChange);
    }
  }, {
    key: 'mode',
    get: function get() {
      return this._mode;
    }

    /**
     * The current speaker. This is the user who's video stream is currently available
     * via the output of the switcher.
     *
     * This will usually be the same as the primary speaker. The exception is for the
     * primary speaker itself, for whom the speaker will be set to the secondary speaker.
     *
     * @readonly
     * @member {ConferenceSwitcherMode} ConferenceSwitcher#mode
     */

  }, {
    key: 'speaker',
    get: function get() {
      return this._speaker;
    }

    /**
     * The primary speaker of the conference, all other members of the conference will
     * see this stream sent by this member.
     *
     * @readonly
     * @member {ConferenceSwitcherMode} ConferenceSwitcher#mode
     */

  }, {
    key: 'primarySpeaker',
    get: function get() {
      return this._primarySpeaker;
    }

    /**
     * The secondary speaker of the conference, the primary speaker will receive the
     * stream sent from this member.
     *
     * @readonly
     * @member {ConferenceSwitcherMode} ConferenceSwitcher#mode
     */

  }, {
    key: 'secondarySpeaker',
    get: function get() {
      return this._secondarySpeaker;
    }
  }, {
    key: 'selectedPrimarySpeaker',
    get: function get() {
      return this._selectedPrimarySpeaker;
    }
  }, {
    key: 'selectedSecondarySpeaker',
    get: function get() {
      return this._selectedSecondarySpeaker;
    }
  }, {
    key: 'input',
    get: function get() {
      return this._component._input;
    }

    /**
     * The media output for the switcher. The media stream will belong to whoever
     * is set as the {@link ConferenceSwitcher#speaker}.
     *
     * @readonly
     * @member {MediaNodeOutput} ConferenceSwitcher#output
     */

  }, {
    key: 'output',
    get: function get() {
      return this._component._output;
    }
  }, {
    key: '_relayLinks',
    get: function get() {
      var relayLinksData = this._raft.get(STATE_KEY_LINKS);
      if (relayLinksData) {
        var n2 = (relayLinksData.length - 2) / 2;
        return {
          ids: relayLinksData.slice(0, n2),
          parents: relayLinksData.slice(n2, 2 * n2)
        };
      } else {
        return {
          ids: [],
          parents: []
        };
      }
    }
  }]);

  return ConferenceSwitcher;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_11_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_13_media_mediaNode__["a" /* default */].connectMixin(__WEBPACK_IMPORTED_MODULE_13_media_mediaNode__["a" /* default */])));

/* harmony default export */ __webpack_exports__["a"] = (ConferenceSwitcher);

/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export RmsVolumeAlgorithm */
/* unused harmony export MaxVolumeAlgorithm */
/* unused harmony export AudioProcessorMeter */
/* unused harmony export RtcStatsMeter */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_webrtc_utils__ = __webpack_require__(66);











var TAG = 'voice-detector';

var MODE_STATS = 'stats';
var MODE_MAX = 'max';
var MODE_FFT = 'fft';
var MODE_RMS = 'rms';
var MODES = [MODE_STATS, MODE_MAX, MODE_FFT, MODE_RMS];

var TICK_INTERVAL_MS = 500;

var VOLUME_FILTER_ALPHA = 0.05;
var VOLUME_FILTER_INTERVAL_MS = 100;

var RMS_ALPHA = 0.2;

var RmsVolumeAlgorithm = function () {
  function RmsVolumeAlgorithm() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, RmsVolumeAlgorithm);

    this._filtered = 0;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(RmsVolumeAlgorithm, [{
    key: 'process',
    value: function process(buffer) {
      var count = buffer.length;
      var sumOfSquares = 0;
      for (var i = 0; i < count; i += 1) {
        var val = buffer[i];
        sumOfSquares += val * val;
      }
      var meanOfSquares = sumOfSquares / count;
      var value = Math.sqrt(meanOfSquares);
      this._filtered = this._filtered * (1 - RMS_ALPHA) + value * RMS_ALPHA;
      return this._filtered;
    }
  }]);

  return RmsVolumeAlgorithm;
}();

var MaxVolumeAlgorithm = function () {
  function MaxVolumeAlgorithm() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, MaxVolumeAlgorithm);

    this._max = 0;
    this._volume = 0;
    this._updateTime = 0;

    this._updateFrequencyMs = 100;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(MaxVolumeAlgorithm, [{
    key: 'process',
    value: function process(buffer) {
      var count = buffer.length;
      var localMax = 0;
      for (var i = 0; i < count; i += 1) {
        var val = buffer[i];
        if (val < -localMax) {
          localMax = -val;
        } else if (val > localMax) {
          localMax = val;
        }
      }

      if (localMax > this._max) {
        this._max = localMax;
      }

      var now = Date.now();
      if (now - this._updateTime > this._updateFrequencyMs) {
        this._updateTime = now;

        this._volume = this._max;
        this._max /= 4; // Decay
      }

      return this._volume;
    }
  }]);

  return MaxVolumeAlgorithm;
}();

var AudioProcessorMeter = function () {
  function AudioProcessorMeter(algorithm) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, AudioProcessorMeter);

    this._processAudioData = this._processAudioData.bind(this);

    if (algorithm === MODE_RMS) {
      this._algorithm = new RmsVolumeAlgorithm();
    } else if (algorithm === MODE_MAX) {
      this._algorithm = new MaxVolumeAlgorithm();
    } else {
      throw new TypeError('Unknown volume algorithm: \'' + algorithm + '\'');
    }
    this._stream = null;
    this._volume = 0;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(AudioProcessorMeter, [{
    key: 'toString',
    value: function toString() {
      return 'audioProcessorMeter{mode=' + this._mode + ',volume=' + this.volume + '}';
    }
  }, {
    key: 'tick',
    value: function tick(peerConnection, track, stream) {
      if (stream === this._stream) {
        return;
      }

      if (this._stream) {
        if (this._audioSource) {
          this._audioSource.disconnect();
          this._audioSource = null;
        }
        this._stream = null;

        if (!stream) {
          if (this._processorNode) {
            this._processorNode.disconnect();
            this._processorNode = null;
          }
          if (this._audioContext) {
            __WEBPACK_IMPORTED_MODULE_6_webrtc_utils__["audioContextUtil"].release();
            this._audioContext = null;
            this._destination = null;
          }
        }
      }
      this._stream = stream;
      if (stream) {
        if (!this._audioContext) {
          this._audioContext = __WEBPACK_IMPORTED_MODULE_6_webrtc_utils__["audioContextUtil"].get();
          this._destination = this._audioContext.createMediaStreamDestination();
        }
        if (!this._processorNode) {
          this._processorNode = this._audioContext.createScriptProcessor(2048, 1, 1);
          this._processorNode.connect(this._destination);
          this._processorNode.onaudioprocess = this._processAudioData;
        }

        this._audioSource = this._audioContext.createMediaStreamSource(stream);
        this._audioSource.connect(this._processorNode);
      }
    }
  }, {
    key: '_processAudioData',
    value: function _processAudioData(event) {
      if (!this._stream) {
        this._volume = 0;
        return;
      }
      var buffer = event.inputBuffer.getChannelData(0);
      this._volume = this._algorithm.process(buffer);
    }
  }, {
    key: 'volume',
    get: function get() {
      if (this._volume > 1) {
        return 1;
      }
      return this._volume;
    }
  }]);

  return AudioProcessorMeter;
}();

var RtcStatsMeter = function () {
  function RtcStatsMeter() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, RtcStatsMeter);

    this._processStatsResult = this._processStatsResult.bind(this);
    this._volume = 0;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(RtcStatsMeter, [{
    key: 'toString',
    value: function toString() {
      return 'rtcStatsMeter{volume=' + this.volume + '}';
    }
  }, {
    key: 'tick',
    value: function tick(peerConnection, track, stream) {
      var _this = this;

      if (!peerConnection) {
        return;
      }
      if (__WEBPACK_IMPORTED_MODULE_5_common_utils__["isChrome"]) {
        peerConnection._pc.getStats(this._processStatsResult, track);
      } else {
        peerConnection._pc.getStats(track, this._processStatsResult, function (error) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, _this, 'failed to get stats, ' + error);
        });
      }
    }
  }, {
    key: '_processStatsResult',
    value: function _processStatsResult(result) {
      var maxVolume = 0;
      // We use the legacy Chrome API if available, since we then avoid the conversion to a Map.
      if (typeof result.result === 'function') {
        result.result().filter(function (stat) {
          return stat.type === 'ssrc';
        }).forEach(function (stat) {
          var volume = +stat.stat('audioInputLevel');
          if (volume > maxVolume) {
            maxVolume = volume;
          }
        });
      } else {
        for (var key in result) {
          if (result.hasOwnProperty(key)) {
            var stat = result[key];
            if (stat.type === 'ssrc') {
              var volume = +stat.audioInputLevel;
              if (volume > maxVolume) {
                maxVolume = volume;
              }
            }
          }
        }
      }
      // WebRTC.org uses the absolute value of 16-bit signed intergers when calculating
      // audio levels, so divide by 0x8000
      var normalizedVolume = maxVolume / 0x8000;
      this._volume = normalizedVolume;
    }
  }, {
    key: 'volume',
    get: function get() {
      return this._volume;
    }
  }]);

  return RtcStatsMeter;
}();

var VolumeFilter = function () {
  function VolumeFilter(_ref) {
    var alpha = _ref.alpha,
        intervalMs = _ref.intervalMs,
        volumeSource = _ref.volumeSource;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, VolumeFilter);

    this._tick = this._tick.bind(this);

    this._alpha = alpha;
    this._intervalMs = intervalMs;
    this._volumeSource = volumeSource;

    this._volume = 0;
    this._intervalId = null;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(VolumeFilter, [{
    key: 'start',
    value: function start() {
      this.stop();
      this._intervalId = setInterval(this._tick, this._intervalMs);
    }
  }, {
    key: 'stop',
    value: function stop() {
      this._volume = 0;
      if (this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
    }
  }, {
    key: '_tick',
    value: function _tick() {
      var measuredVolume = this._volumeSource.volume;
      if (measuredVolume > 1) {
        measuredVolume = 1;
      }
      var oldComponent = (1 - this._alpha) * this._volume;
      var newComponent = this._alpha * measuredVolume;
      this._volume = oldComponent + newComponent;
    }
  }, {
    key: 'volume',
    get: function get() {
      return this._volume;
    }
  }]);

  return VolumeFilter;
}();

var VoiceActivityDetector = function () {
  function VoiceActivityDetector() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$mode = _ref2.mode,
        mode = _ref2$mode === undefined ? null : _ref2$mode,
        _ref2$active = _ref2.active,
        active = _ref2$active === undefined ? false : _ref2$active;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, VoiceActivityDetector);

    this._tick = this._tick.bind(this);

    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].optValues(this, 'options.mode', mode, MODES);
    if (!mode) {
      if (__WEBPACK_IMPORTED_MODULE_5_common_utils__["isFirefox"]) {
        mode = MODE_MAX;
      } else {
        mode = MODE_STATS;
      }
    }

    if (mode === MODE_STATS) {
      this._meter = new RtcStatsMeter();
    } else if (mode === MODE_RMS || mode === MODE_MAX) {
      this._meter = new AudioProcessorMeter(mode);
    } else {
      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'VoiceActivityDetector mode \'' + mode + '\' is not implemented');
    }

    this._volumeFilter = new VolumeFilter({
      alpha: VOLUME_FILTER_ALPHA,
      intervalMs: VOLUME_FILTER_INTERVAL_MS,
      volumeSource: this._meter
    });

    this._active = active;

    this._peerConnection = null;
    this._intervalId = null;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(VoiceActivityDetector, [{
    key: 'toString',
    value: function toString() {
      return 'voiceActivityDetector{meter=' + this._meter + '}';
    }
  }, {
    key: 'setActive',
    value: function setActive(active) {
      this._active = active;
      this._maybeStartOrStop();
    }
  }, {
    key: 'setPeerConnection',
    value: function setPeerConnection(peerConnection) {
      this._peerConnection = peerConnection || null;
      this._maybeStartOrStop();
    }
  }, {
    key: '_maybeStartOrStop',
    value: function _maybeStartOrStop() {
      if (this._peerConnection && this._active) {
        if (!this._intervalId) {
          this._intervalId = setInterval(this._tick, TICK_INTERVAL_MS);
          this._tick();
        }
        this._volumeFilter.start();
      } else if (!this._peerConnection && !this._active) {
        this._volumeFilter.stop();
        if (this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = null;
          this._meter.tick(null, null, null);
        }
      }
    }
  }, {
    key: '_findTrack',
    value: function _findTrack() {
      var streams;
      try {
        streams = this._peerConnection.getLocalStreams();
      } catch (error) {
        streams = [];
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, 'Failed to get local streams, ' + error);
      }
      var track = null;
      var stream = null;
      for (var i = streams.length - 1; i >= 0; i -= 1) {
        var tracks = streams[i].getAudioTracks();
        track = tracks[tracks.length - 1];
        if (track) {
          stream = streams[i];
          break;
        }
      }
      return [track, stream];
    }
  }, {
    key: '_tick',
    value: function _tick() {
      var _findTrack2 = this._findTrack(),
          _findTrack3 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_findTrack2, 2),
          track = _findTrack3[0],
          stream = _findTrack3[1];

      this._meter.tick(this._peerConnection, track, stream);
    }
  }, {
    key: 'volume',
    get: function get() {
      return this._volumeFilter.volume;
    }
  }]);

  return VoiceActivityDetector;
}();

/* harmony default export */ __webpack_exports__["a"] = (VoiceActivityDetector);

/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);


// This module provide an activity tracker that helps
// with identifying temporary or permanent connection
// failures.



var ACTIVITY_TIMEOUT_MS = 1500;
// Higher than ice disconnect timeout, which lets us detect if
// it's just the channel haning or the call disconnecing
var DISCONNECT_TIMEOUT_MS = 12000;

/**
 * A class which helps keeping track of the state of
 * a connection. The different states are active, inactive,
 * and disconnected. If the state can transition back and
 * forth between active and inactive, but if it reaches the
 * disconnected state it will stay there until a reset.
 *
 * @class ActivityTracker
 * @private
 */

var ActivityTracker = function () {
  function ActivityTracker() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, ActivityTracker);

    var _options$inactivityTi = options.inactivityTimeoutMs,
        inactivityTimeoutMs = _options$inactivityTi === undefined ? ACTIVITY_TIMEOUT_MS : _options$inactivityTi,
        _options$disconnectTi = options.disconnectTimeoutMs,
        disconnectTimeoutMs = _options$disconnectTi === undefined ? DISCONNECT_TIMEOUT_MS : _options$disconnectTi;


    if (disconnectTimeoutMs <= inactivityTimeoutMs) {
      throw new Error('inactivity timeout must be less than disconnect timeout');
    }

    this._onActivityTimeout = this._onActivityTimeout.bind(this);
    this._onDisconnectTimeout = this._onDisconnectTimeout.bind(this);

    this._inactivityTimeoutMs = inactivityTimeoutMs;
    this._disconnectTimeoutMs = disconnectTimeoutMs - inactivityTimeoutMs;

    this._activityTimeoutId = null;
    this._disconnectTimeoutId = null;

    this._running = false;
    this._active = false;
    this._disconnected = false;
  }

  /**
   * Whether the connection is active or not. Also false
   * before the tracker has been started.
   *
   * @member {boolean}
   */


  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(ActivityTracker, [{
    key: 'start',


    /**
     * Starts tracking activity.
     *
     * @param {Object} options - Options object.
     * @param {Function} options.onActiveStateChange - Called when
     *   the active property of the tracker is changed.
     * @param {Function} options.onDisconnect - Called on disconnect.
     */
    value: function start(_ref) {
      var _ref$onActiveStateCha = _ref.onActiveStateChange,
          onActiveStateChange = _ref$onActiveStateCha === undefined ? null : _ref$onActiveStateCha,
          _ref$onDisconnect = _ref.onDisconnect,
          onDisconnect = _ref$onDisconnect === undefined ? null : _ref$onDisconnect;

      if (this._running) {
        throw new Error('already started');
      }
      this._running = true;
      this._disconnected = false;
      this._activeStateChangeCallback = onActiveStateChange;
      this._disconnectCallback = onDisconnect;

      this._activityTimeoutId = setTimeout(this._onActivityTimeout, this._inactivityTimeoutMs);

      this._active = true;
      this._activeStateChangeCallback && this._activeStateChangeCallback(this._active);
    }

    /**
     * Stop activity tracking and reset to initial state.
     */

  }, {
    key: 'stop',
    value: function stop() {
      if (!this._running) {
        throw new Error('tried to stop without starting');
      }
      var wasActive = this._active;
      this._active = false;
      this._running = false;
      this._disconnected = false;

      if (this._activityTimeoutId) {
        clearTimeout(this._activityTimeoutId);
        this._activityTimeoutId = null;
      }
      if (this._disconnectTimeoutId) {
        clearTimeout(this._disconnectTimeoutId);
        this._disconnectTimeoutId = null;
      }

      if (wasActive) {
        this._activeStateChangeCallback && this._activeStateChangeCallback(this._active);
      }
    }

    /**
     * Mark the connection as active. This will reset
     * the activity timeout and bring the connection
     * back to active if it was inactive.
     *
     * This will not bring the connection back from disconnected.
     */

  }, {
    key: 'registerActivity',
    value: function registerActivity() {
      if (this._disconnected || !this._running) {
        return;
      }
      if (!this._active) {
        this._active = true;
        this._activeStateChangeCallback && this._activeStateChangeCallback(this._active);
      }

      if (this._activityTimeoutId) {
        clearTimeout(this._activityTimeoutId);
        this._activityTimeoutId = setTimeout(this._onActivityTimeout, this._inactivityTimeoutMs);
      }
      if (this._disconnectTimeoutId) {
        clearTimeout(this._disconnectTimeoutId);
        this._disconnectTimeoutId = null;
      }
    }
  }, {
    key: '_onActivityTimeout',
    value: function _onActivityTimeout() {
      this._activityTimeoutId = null;

      if (this._disconnectTimeoutId) {
        clearTimeout(this._disconnectTimeoutId);
      }
      this._disconnectTimeoutId = setTimeout(this._onDisconnectTimeout, this._disconnectTimeoutMs);
      this._active = false;
      this._activeStateChangeCallback && this._activeStateChangeCallback(this._active);
    }
  }, {
    key: '_onDisconnectTimeout',
    value: function _onDisconnectTimeout() {
      this._disconnectTimeoutId = null;

      this._disconnected = true;
      this._disconnectCallback && this._disconnectCallback();
    }
  }, {
    key: 'active',
    get: function get() {
      return this._active;
    }

    /**
     * Whether the connection is disconnected.
     *
     * @member {boolean}
     */

  }, {
    key: 'disconnected',
    get: function get() {
      return this._disconnected;
    }

    /**
     * Whether the activity tracker is running.
     *
     * @member {boolean}
     */

  }, {
    key: 'running',
    get: function get() {
      return this._running;
    }
  }]);

  return ActivityTracker;
}();

/* harmony default export */ __webpack_exports__["a"] = (ActivityTracker);

/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BandwidthEstimator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);


// This module contains utilities for measuring and estimating
// the available bandwidth.

// Starting off with 200kBkps for 2s gives us an initial burst
// of 400kB,



var DEFAULT_INITIAL_TARGET_KBPS = 400;
var DEFAULT_INITIAL_SEND_WINDOW_SIZE_MS = 1000;

// How long we should wait before trying to send again if
// we have been limited by bandwidth. This is divided by the
// target bandwidth in kbps to yield the time in ms.
// bytes / kB/s = kB / kB/ms = kB * ms / kB = ms
var DEFAULT_RETRY_SIZE_BYTES = 4096;

/**
 * Estimates the available bandwidth and how many bytes
 * can be sent without causing excessive congestion.
 */
var BandwidthEstimator = function () {
  function BandwidthEstimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, BandwidthEstimator);

    var _options$timeSource = options.timeSource,
        timeSource = _options$timeSource === undefined ? Date : _options$timeSource,
        _options$initialTarge = options.initialTargetKbps,
        initialTargetKbps = _options$initialTarge === undefined ? DEFAULT_INITIAL_TARGET_KBPS : _options$initialTarge,
        _options$initialSendW = options.initialSendWindowSizeMs,
        initialSendWindowSizeMs = _options$initialSendW === undefined ? DEFAULT_INITIAL_SEND_WINDOW_SIZE_MS : _options$initialSendW;


    this._timeSource = timeSource;
    this._initialTargetKbps = initialTargetKbps;
    this._initialSendWindowSizeMs = initialSendWindowSizeMs;

    // kB/s == B/ms, which is conventient since we're measuing time in ms.
    this._targetKbps = 0;
    this._sendWindowSizeMs = 0;
    // The send marker keeps track of how much time we have
    // used up by sending data. Sent bytes are converted to
    // time according to the current target bandwith.
    // When sending data, the marker is pushed into the future
    // according to the target bandwidth and current position.
    // The marker should not extend further into the future than
    // the send window size, which is how the available send bytes
    // are calculated.
    // If the marker is in the past when sending data, it will
    // first be set to the current time, and then pushed forward.
    //
    //               send marker
    //      current time |   send window size
    //          v        v          v
    // time ---->--------*----------<------
    //          |-------| |---------|
    //              ^            ^
    //     send window consumed  |
    //                   send window available
    //
    this._sendMarkerMs = 0;

    this.reset();
  }

  // resets all moving values back to initial values


  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(BandwidthEstimator, [{
    key: 'reset',
    value: function reset() {
      this._targetKbps = this._initialTargetKbps;
      this._sendWindowSizeMs = this._initialSendWindowSizeMs;
      this._sendMarkerMs = this._timeSource.now();
    }

    // Returns the distance from the send marker to the
    // end of the send window.

  }, {
    key: 'calculateRetryTimeoutMs',
    value: function calculateRetryTimeoutMs() {
      var retrySizeBytes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_RETRY_SIZE_BYTES;

      var retryTimeoutMs = retrySizeBytes / this._targetKbps;
      // This is unlikely, but would be a waste if we didn't consider
      if (this._sendWindowSizeMs / 2 < retryTimeoutMs) {
        return this._sendWindowSizeMs / 2 | 0;
      } else {
        return retryTimeoutMs | 0;
      }
    }

    // Pushes the send marker into the future based on bytes
    // sent and target bandwith.

  }, {
    key: 'consumeSendBytes',
    value: function consumeSendBytes(bytes) {
      var currentTimeMs = this._timeSource.now();
      if (this._sendMarkerMs < currentTimeMs) {
        this._sendMarkerMs = currentTimeMs;
      }

      var timeEquivalentMs = bytes / this._targetKbps;

      this._sendMarkerMs += timeEquivalentMs;
    }
  }, {
    key: 'bytesAvailable',
    get: function get() {
      // This check is eneded, otherwise we'd end up with (Infinity | 0), which, in JS, is 0
      if (this._targetKbps === Infinity) {
        return Infinity;
      }
      var currentTimeMs = this._timeSource.now();
      if (this._sendMarkerMs < currentTimeMs) {
        this._sendMarkerMs = currentTimeMs;
      }
      var availableMs = currentTimeMs + this._sendWindowSizeMs - this._sendMarkerMs;
      if (availableMs < 0) {
        return 0;
      }

      return availableMs * this._targetKbps | 0;
    }
  }]);

  return BandwidthEstimator;
}();

/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SendBuffer */
/* unused harmony export TransferBuffer */
/* unused harmony export MessageBuffer */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PrioritizedBuffer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_datamux_constants__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_datamux_transfer__ = __webpack_require__(228);


// This modules contains different implementation
// of push/pull send buffers. Messages are added
// directly to the buffer, but a separate implmentation
// is needed to move the data data channels.









/**
 * @class SendBuffer
 * @private
 */
var SendBuffer = function () {
  function SendBuffer() {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, SendBuffer);

    this._listener = null;
  }

  /**
   * @returns {boolean} Whether the buffer is empty.
   */


  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(SendBuffer, [{
    key: 'notify',


    /**
     * Called to notify the listener that there is new data available.
     */
    value: function notify() {
      if (this._listener) {
        this._listener();
      }
    }

    /**
     * @param {Function} listener - Callback that will be called when data is available.
     */

  }, {
    key: 'setNotificationListener',
    value: function setNotificationListener(listener) {
      this._listener = listener;
    }

    /**
     * @param {byteLength} byteLength - Maximum number of bytes to read.
     * @returns {(String|BufferView)?} - A single message to send, or null
     *   if empty or next message doesn't fit.
     */

  }, {
    key: 'read',
    value: function read(byteLength) {
      return null;
    }
  }, {
    key: 'empty',
    get: function get() {
      return true;
    }
  }]);

  return SendBuffer;
}();

var TransferBuffer = function (_SendBuffer) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(TransferBuffer, _SendBuffer);

  function TransferBuffer() {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, TransferBuffer);

    var _this = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (TransferBuffer.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(TransferBuffer)).call(this));

    _this._items = [];
    _this._currentItem = null;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(TransferBuffer, [{
    key: 'toString',
    value: function toString() {
      return 'transferBuffer{size=' + (this._items.length + (this._currentItem ? 1 : 0)) + '}';
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._items.length = 0;
      this._currentItem = null;
    }
  }, {
    key: 'push',
    value: function push(transferItem) {
      this._items.push(transferItem);
      this.notify();
    }
  }, {
    key: 'read',
    value: function read(byteLength) /* or 'base64' */{
      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'binary';

      if (!this._currentItem) {
        if (this._items.length) {
          this._currentItem = this._items.shift();
        } else {
          return null;
        }
      }

      if (this._currentItem instanceof __WEBPACK_IMPORTED_MODULE_6_datamux_transfer__["b" /* TransferItem */]) {
        var message = null;

        if (encoding === 'base64') {
          message = this._currentItem.readBase64(byteLength);
          if (message) {
            var lengthStr = message.length.toString(__WEBPACK_IMPORTED_MODULE_5_datamux_constants__["e" /* ID_BASE */]);
            message = __WEBPACK_IMPORTED_MODULE_5_datamux_constants__["l" /* MT_TRANSFER_BINARY_DATA */] + lengthStr + __WEBPACK_IMPORTED_MODULE_5_datamux_constants__["d" /* M_SEP */] + message;
          }
        } else {
          message = this._currentItem.read(byteLength);
        }

        if (this._currentItem.empty) {
          this._currentItem = null;
        }

        return message;
      } else {
        // Plain messages can be sent as well, but won't be split.
        // This will so far only be used for sending transfer headers.
        var _message = this._currentItem;
        if (_message.length < byteLength) {
          this._currentItem = null;
          return _message;
        } else {
          return null;
        }
      }
    }
  }, {
    key: 'empty',
    get: function get() {
      if (this._currentItem) {
        return false;
      }
      return this._items.length === 0;
    }
  }]);

  return TransferBuffer;
}(SendBuffer);

var MessageBuffer = function (_SendBuffer2) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(MessageBuffer, _SendBuffer2);

  function MessageBuffer() {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, MessageBuffer);

    var _this2 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (MessageBuffer.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(MessageBuffer)).call(this));

    _this2._messages = [];
    return _this2;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(MessageBuffer, [{
    key: 'toString',
    value: function toString() {
      return 'messageBuffer{size=' + this._messages.length + '}';
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._messages.length = 0;
    }
  }, {
    key: 'push',
    value: function push(message) {
      this._messages.push(message);
      this.notify();
    }
  }, {
    key: 'read',
    value: function read(byteLength) {
      if (!this._messages.length) {
        return null;
      }

      var first = this._messages[0];
      if (first.length > byteLength) {
        return;
      }

      return this._messages.shift();
    }
  }, {
    key: 'empty',
    get: function get() {
      return this._messages.length === 0;
    }
  }]);

  return MessageBuffer;
}(SendBuffer);

var PrioritizedBuffer = function (_SendBuffer3) {
  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_inherits___default()(PrioritizedBuffer, _SendBuffer3);

  function PrioritizedBuffer() {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, PrioritizedBuffer);

    var _this3 = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_possibleConstructorReturn___default()(this, (PrioritizedBuffer.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(PrioritizedBuffer)).call(this));

    _this3._messageBuffer = new MessageBuffer();
    _this3._transferBuffer = new TransferBuffer();
    return _this3;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(PrioritizedBuffer, [{
    key: 'toString',
    value: function toString() {
      return 'prioBuffer{' + this._messageBuffer + ',' + this._transferBuffer + '}';
    }
  }, {
    key: 'setNotificationListener',
    value: function setNotificationListener(listener) {
      this._messageBuffer.setNotificationListener(listener);
      this._transferBuffer.setNotificationListener(listener);
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._messageBuffer.clear();
      this._transferBuffer.clear();
    }

    // Queue a high-priority message.

  }, {
    key: 'pushMessage',
    value: function pushMessage(message) {
      this._messageBuffer.push(message);
    }

    // Queue a low-priority transfer item.

  }, {
    key: 'pushTransfer',
    value: function pushTransfer(transfer) {
      this._transferBuffer.push(transfer);
    }
  }, {
    key: 'read',
    value: function read(byteLength, encoding) {
      var message = this._messageBuffer.read(byteLength, encoding);
      if (message) {
        return message;
      }
      // There are messages, but we don't have send bytes available yet.
      if (!this._messageBuffer.empty) {
        return null;
      }

      var data = this._transferBuffer.read(byteLength, encoding);
      if (data) {
        return data;
      }

      return null;
    }
  }, {
    key: 'empty',
    get: function get() {
      return this._messageBuffer.empty && this._transferBuffer.empty;
    }
  }]);

  return PrioritizedBuffer;
}(SendBuffer);

/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ReceiveQueue */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_webrtc_errors__ = __webpack_require__(161);


// This module contains the implementation of the public
// channel API, the end result of the datamux system.















var TAG = 'datamux';

var MUX_CHANNEL_READY_STATE_OPENING = 'opening';
var MUX_CHANNEL_READY_STATE_OPEN = 'open';
var MUX_CHANNEL_READY_STATE_CLOSED = 'closed';

/**
 * Types that can be sent and received over {@link DataChannel}s.
 *
 * JSON serialization is handled by `JSON.stringify`, which means that
 * circular references are not allowed, and `toJSON` methods will be used.
 *
 * As opposed to {@link JsonTypes} this includes some binary types,
 * e.g. ArrayBuffer and Blob. These binary types may also be embedded within
 * objects and arrays.
 *
 * @typedef DataChannel.DataChannelTypes {string|number|boolean|null|ArrayBuffer|Blob
 * |ArrayBufferView|Array<DataChannelTypes>|Object<DataChannelTypes>}
 */

/**
 * The channel ready state.
 *
 * All channels start off in the `'opening'` state, they then
 * move to `'open'`, and finally `'closed'``. The state transitions
 * always happen in this order, although `'open'` might be skipped
 * if the channel fails to open.
 *
 * @typedef DataChannel.ReadyState {'opening'|'open'|'close'}
 */

/**
 * A data channel class that functions a lot like normal WebRTC data channels,
 * but provides a number of abstractions and improvements, while taking care
 * of browser incompatability issues.
 *
 * Data channels are created with {@link RtcPeer#createChannel}. Each channel
 * is created for it's own specific peer in an attached {@link RtcComponent},
 * and they may not, and can not, interact across these boundaries.
 * i.e. channels are only visible to matching components.
 *
 * As opposed to normal WebRTC data channels, these channels are always reliable
 * and ordered. They also support much more complex and larger messages. Objects
 * and arrays that are sent will be serialized as JSON, but they may contain
 * some binary types that will be transmitted separately in an efficient way.
 *
 * @abstract
 * @class DataChannel
 * @extends EmitterMixin
 */

var DataChannel = function (_EventEmitter) {
  __WEBPACK_IMPORTED_MODULE_6_babel_runtime_helpers_inherits___default()(DataChannel, _EventEmitter);

  /**
   * Emitted when the channel is opened, i.e. when the
   * {@link DataChannel#readyState} has reached 'open'.
   *
   * This may not always be emitted for a channel, as it might
   * go directly to closed.
   *
   * @event DataChannel#open
   * @param {DataChannel} channel - The channel that was opened.
   */

  /**
   * Emitted when the channel is closed, i.e. when the
   * {@link DataChannel#readyState} has reached 'closed'.
   *
   * This will always be emitted for every channel.
   *
   * After the channel is closed, all event listeners will removed.
   *
   * @event DataChannel#close
   * @param {DataChannel} channel - The channel that was closed.
   */

  /**
   * Emitted when the {@link DataChannel#readyState} is changed.
   *
   * @event DataChannel#readyState
   * @param {string} readyState - The new readyState of the channel.
   */

  /**
   * Emitted when a message is received.
   *
   * @event DataChannel#message
   * @param {DataChannelTypes} message - The received message.
   */

  function DataChannel(config) {
    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, DataChannel);

    var _this = __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_possibleConstructorReturn___default()(this, (DataChannel.__proto__ || __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_object_get_prototype_of___default()(DataChannel)).call(this));

    _this.send = _this.send.bind(_this);

    _this._localId = config.localId;
    _this._isLocal = config.isLocal;
    _this._label = config.label;
    _this._protocol = config.protocol || '';
    _this._namespaceId = config.namespaceId || '';
    _this._pairingId = config.pairingId || null;
    _this._builtin = config.builtin;
    _this._onSendMessage = config.onMessage;
    _this._onClose = config.onClose;

    _this._readyState = MUX_CHANNEL_READY_STATE_OPENING;
    _this._startupQueue = [];
    _this._receiveQueue = null;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(DataChannel, [{
    key: 'toString',
    value: function toString() {
      return 'dataChannel{' + this.readyState + ',' + this._localId + '->' + (this._remoteId || '?') + (',ns=' + this._namespaceId + ',label=' + this.label + ',protocol=' + this.protocol + '}');
    }

    /**
     * @readonly
     * @member {string} DataChannel#label
     */

  }, {
    key: 'send',


    /**
     * Send a message on the channel. Will throw an error if the
     * channel is closed.
     *
     * @function DataChannel#send
     * @param {DataChannelTypes} message - The message to send.
     * @returns {Promise} A promise that will be resolved once the message has been
     * handed off to the WebRTC send buffer.
     */
    value: function send(message) {
      if (this._readyState === MUX_CHANNEL_READY_STATE_CLOSED) {
        throw new Error('tried to send when channel was closed');
      }
      if (!this._onSendMessage) {
        return;
      }
      if (this._readyState === MUX_CHANNEL_READY_STATE_OPENING) {
        var deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_common_utils__["defer"])();
        this._startupQueue.push([deferred, message]);
        return deferred.promise;
      } else {
        return this._onSendMessage(message);
      }
    }

    /**
     * Closes the channel.
     *
     * Only requested (non-paired) channels may be closed.
     *
     * @function DataChannel#close
     */

  }, {
    key: 'close',
    value: function close() {
      var _this2 = this;

      if (this._pairingId) {
        throw new Error('paired channels can not be closed');
      }
      this._onClose(this);
      __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject().catch(function () {
        _this2._close(null);
      });
    }

    // eslint-disable-next-line jsdoc/require-description-complete-sentence
    /**
     * Waits for the channel to open.
     *
     * If the channels goes directly to closed, the returned promise will be
     * rejected.
     *
     * ##### Errors:
     * - {@link ChannelClosedError} - The channel was closed.
     *
     * @function DataChannel#waitForOpen
     * @returns {Promise} A Promise that is resolved once the channel has connected.
     */

  }, {
    key: 'waitForOpen',
    value: function waitForOpen() {
      var _this3 = this;

      return new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        switch (_this3._readyState) {
          case MUX_CHANNEL_READY_STATE_OPEN:
            return resolve(_this3);
          case MUX_CHANNEL_READY_STATE_CLOSED:
            return reject(new __WEBPACK_IMPORTED_MODULE_11_webrtc_errors__["d" /* ChannelClosedError */]('channel was already closed'));
          case MUX_CHANNEL_READY_STATE_OPENING:
            _this3.once('readyState', function (readyState) {
              if (readyState === MUX_CHANNEL_READY_STATE_OPEN) {
                resolve(_this3);
              } else {
                reject(new __WEBPACK_IMPORTED_MODULE_11_webrtc_errors__["d" /* ChannelClosedError */]('channel was closed'));
              }
            });
        }
      });
    }

    // eslint-disable-next-line jsdoc/require-description-complete-sentence
    /**
     * Receive messages using an ES6 generator function. Every time a
     * message is received the generator will continue to run, with
     * yield returning the message that was received.
     *
     * ##### Errors:
     * - {@link ChannelClosedError} - The channel was closed.
     *
     * @example
     * channel.receiveWithGenerator(function *() {
     *   while (true) {
     *     let message = yield
     *     console.log('got message:', message)
     *   }
     * }).catch(error => {
     *   console.log('channel closed:', error)
     * })
     *
     * @function DataChannel#receiveWithGenerator
     * @param {Function} generator - An ES6 generator (`function * () {}`).
     * @returns {Promise} A promise that is resolved when the generator returns,
     * or is rejected when the channel is closed.
     */

  }, {
    key: 'receiveWithGenerator',
    value: function receiveWithGenerator(generator) {
      var _this4 = this;

      return this.waitForOpen().then(function () {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, _this4, 'beginning to receive with iterator');
        return new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
          var iterator = generator();

          var onMessage = function onMessage(message) {
            try {
              next = iterator.next(message);
              if (next.done) {
                resolve(next.value);
                end();
              }
            } catch (error) {
              reject(error);
              end();
            }
          };

          var onClose = function onClose() {
            reject(new __WEBPACK_IMPORTED_MODULE_11_webrtc_errors__["d" /* ChannelClosedError */]('receive was interrupted by channel closing'));
            end();
          };

          var end = function end() {
            if (next && !next.done) {
              iterator.return();
            }
            resolve();
            _this4.off('message', onMessage);
            _this4.off('close', onClose);
          };

          _this4.on('message', onMessage);
          _this4.on('close', onClose);

          var next = iterator.next(); // run iterator up until first yield
        });
      });
    }

    /**
     * Send messages using an ES6 generator function. Every yielded value that
     * is not a promise (has a `.then` method) will be sent as a message to the peer.
     *
     * When a promise is yielded, sending will be paused until the promise is resolved.
     * The generator will then continue, with yield returning the resolved value.
     * If the promise is rejected, execution will continue by yield throwing the error.
     * The resolved value of the promise will not be sent over the channel,
     * but if that is desired it can be yielded directly afterwards.
     *
     * The handling of promises allows the generator to easily mix async tasks
     * with sending messages, which can otherwise be quite tricky to implement.
     *
     * @example
     * channel.sendWithGenerator(function * () {
     *   while (true) {
     *     // downloadNextFile() downloads a file and returns a promise
     *     let file = yield downloadNextFile()
     *     // send the file to a peer
     *     yield file
     *   }
     * })
     *
     * @function DataChannel#sendWithGenerator
     * @param {Function} generator - An ES6 generator (`function * () {}`).
     * @returns {Promise} A promise that is resolved when the generator returns,
     * or is rejected when the channel is closed.
     */

  }, {
    key: 'sendWithGenerator',
    value: function sendWithGenerator(generator) {
      return this.sendWithIterator(generator());
    }
  }, {
    key: 'sendWithIterator',
    value: function sendWithIterator(iterator) {
      var _this5 = this;

      return this.waitForOpen().then(function () {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, _this5, 'beginning to send with iterator');
        return new __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
          var onDone = function onDone(error) {
            if (error) {
              __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, _this5, 'send iterator ended with error, ' + error);
              reject(error);
              if (next && !next.done) {
                iterator.return();
              }
            } else {
              __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, _this5, 'send iterator ended successfully');
            }

            _this5.off('close', onClosed);
          };

          var onClosed = function onClosed() {
            onDone(new __WEBPACK_IMPORTED_MODULE_11_webrtc_errors__["d" /* ChannelClosedError */]('Send was interrupted by channel closing'));
          };

          var next = null;
          var doSend = function doSend() {
            if (!next) {
              try {
                next = iterator.next();
              } catch (error) {
                onDone(error);
                return;
              }
            }

            if (next.done) {
              onDone();
              resolve(next.value);
              return;
            }

            var _next = next,
                value = _next.value;

            next = null;

            if (value && value.then) {
              value.then(function (result) {
                next = iterator.next(result);
                doSend();
              }).catch(onDone);
            } else {
              try {
                if (_this5.closed) {
                  onClosed();
                } else {
                  _this5.send(value).then(function () {
                    next = iterator.next();
                    doSend();
                  }).catch(onDone);
                }
              } catch (error) {
                onDone(error);
              }
            }
          };

          _this5.on('close', onClosed);

          __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_promise___default.a.reject().catch(doSend);
        });
      });
    }
  }, {
    key: '_setRemoteId',
    value: function _setRemoteId(remoteId) {
      var _this6 = this;

      __WEBPACK_IMPORTED_MODULE_8_common_argCheck__["a" /* default */].number('DataChannel._setRemoteId', 'remoteId', remoteId);
      if (remoteId <= this._remoteId) {
        throw new Error('Could not set remote id to ' + remoteId + ', already have ' + this._remoteId);
      } else {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].info(TAG, this, 'switching remoteId from ' + this._remoteId + ' to ' + remoteId);
      }

      this._remoteId = remoteId;

      if (this._readyState === MUX_CHANNEL_READY_STATE_OPEN) {
        return; // channel was already open, just updated ID, so we're done
      } else {
        this._readyState = MUX_CHANNEL_READY_STATE_OPEN;
      }

      if (this._startupQueue) {
        this._startupQueue.forEach(function (_ref) {
          var _ref2 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_ref, 2),
              deferred = _ref2[0],
              message = _ref2[1];

          _this6._onSendMessage(message).then(deferred.resolve).catch(deferred.reject);
        });
        this._startupQueue = null;
      }

      this._receiveQueue = new ReceiveQueue({
        onMessage: function onMessage(message) {
          return _this6._emit('message', message);
        }
      });

      this._emit('open', this);
      this._emit('readyState', this._readyState);
    }
  }, {
    key: '_close',
    value: function _close() {
      if (this._readyState === MUX_CHANNEL_READY_STATE_CLOSED) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].debug(TAG, this, 'was already closed');
        return;
      }
      if (this._startupQueue) {
        this._startupQueue.forEach(function (_ref3) {
          var _ref4 = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_slicedToArray___default()(_ref3, 1),
              deferred = _ref4[0];

          deferred.reject(new __WEBPACK_IMPORTED_MODULE_11_webrtc_errors__["d" /* ChannelClosedError */]('Early send was interrupted by channel closing'));
        });
        this._startupQueue = null;
      }
      if (this._receiveQueue) {
        this._receiveQueue.reset();
        this._receiveQueue = null;
      }
      this._readyState = MUX_CHANNEL_READY_STATE_CLOSED;
      this._emit('close', this);
      this._emit('readyState', this._readyState);
      if (this._builtin) {
        this._remoteId = null;
      } else {
        this._clearListeners();
      }
    }
  }, {
    key: '_handleRecievedMessagePromise',
    value: function _handleRecievedMessagePromise(messagePromise) {
      this._receiveQueue.handleMessagePromise(messagePromise);
    }
  }, {
    key: 'label',
    get: function get() {
      return this._label;
    }

    /**
     * @readonly
     * @member {string} DataChannel#protocol
     */

  }, {
    key: 'protocol',
    get: function get() {
      return this._protocol;
    }

    /**
     * The current state of the channel.
     *
     * @readonly
     * @member {DataChannel.ReadyState} DataChannel#readyState
     */

  }, {
    key: 'readyState',
    get: function get() {
      return this._readyState;
    }
  }]);

  return DataChannel;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9_common_emitter__["a" /* default */])(null));

/**
 * A queue that makes sure that message are handled in order.
 *
 * This is close to a generic promise queue, but since it has special
 * handling of rejected promises we keep it here.
 */


/* harmony default export */ __webpack_exports__["a"] = (DataChannel);
var ReceiveQueue = function () {
  function ReceiveQueue(_ref5) {
    var onMessage = _ref5.onMessage;

    __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_classCallCheck___default()(this, ReceiveQueue);

    this._onMessage = onMessage;

    this._queue = [];
    this._currentPromise = null;
    this._epoch = 0; // for cancelling existing promise
  }

  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_createClass___default()(ReceiveQueue, [{
    key: 'reset',
    value: function reset() {
      this._queue.length = 0;
      this._currentPromise = null;
      this._epoch += 1;
    }
  }, {
    key: 'handleMessagePromise',
    value: function handleMessagePromise(promise) {
      this._queue.push(promise);
      this._process();
    }
  }, {
    key: '_process',
    value: function _process() {
      var _this7 = this;

      if (this._currentPromise) {
        return;
      }
      var promise = this._queue.shift();
      if (!promise) {
        return;
      }
      var epoch = this._epoch;
      this._currentPromise = promise;
      promise.then(function (message) {
        _this7._currentPromise = null;
        if (epoch === _this7._epoch) {
          _this7._onMessage(message);
          _this7._process();
        }
      }).catch(function (error) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'failed to receive message, ' + error);
        _this7._currentPromise = null;
        if (epoch === _this7._epoch) {
          _this7._process();
        }
      });
    }
  }]);

  return ReceiveQueue;
}();

/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Base64Reader */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_datamux_constants__ = __webpack_require__(182);


// This modules contains classes used to move data from
// send buffers to a the concrete data channel.









var TAG = 'datamux';

var MTU = 1024 * 64;

var INITIAL_RTT_MS = 250;
var DEFAULT_PING_INTERVAL_MS = 500;

var Base64Reader = function () {
  function Base64Reader() {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, Base64Reader);

    this.reset();
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(Base64Reader, [{
    key: 'toString',
    value: function toString() {
      return 'base64Reader{offset=' + this._base64.length + ',size=' + this._size + '}';
    }
  }, {
    key: 'reset',
    value: function reset() {
      this._size = -1;
      this._base64 = '';
    }
  }, {
    key: 'begin',
    value: function begin(size) {
      this._size = size;
      this._base64 = '';
    }
  }, {
    key: 'write',
    value: function write(str) {
      this._base64 += str;

      if (this._base64.length < this._size) {
        return;
      } else if (this._base64.length === this._size) {
        var binaryString = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_common_utils__["base64ToUtf8"])(this._base64);
        var buffer = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3_common_utils__["binaryStringToArrayBuffer"])(binaryString);
        var result = new Uint8Array(buffer);

        this.reset();
        return result;
      } else {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, this, 'length mismatch when receiving base64 encoded message');
        this.reset();
      }
    }
  }, {
    key: 'reading',
    get: function get() {
      return this._size !== -1;
    }
  }]);

  return Base64Reader;
}();

/**
 * This class manages the sending of data on a data channel. It keeps track of the
 * total amount of buffered data, and makes sure that data is sent at a suitable pace.
 */

var ChannelController = function () {
  function ChannelController() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, ChannelController);

    var buffer = options.buffer,
        channelDriver = options.channelDriver,
        _options$activityTrac = options.activityTracker,
        activityTracker = _options$activityTrac === undefined ? null : _options$activityTrac,
        _options$bandwidthEst = options.bandwidthEstimator,
        bandwidthEstimator = _options$bandwidthEst === undefined ? null : _options$bandwidthEst,
        _options$mtu = options.mtu,
        mtu = _options$mtu === undefined ? MTU : _options$mtu,
        _options$transferEnco = options.transferEncoding,
        transferEncoding = _options$transferEnco === undefined ? 'binary' : _options$transferEnco,
        _options$pingInterval = options.pingIntervalMs,
        pingIntervalMs = _options$pingInterval === undefined ? DEFAULT_PING_INTERVAL_MS : _options$pingInterval;


    __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].options(this, 'options', options).object('buffer').object('channelDriver');

    this._onMessage = this._onMessage.bind(this);
    this._onSendAttempt = this._onSendAttempt.bind(this);
    this._sendPing = this._sendPing.bind(this);

    this._buffer = buffer;
    this._channelDriver = channelDriver;
    this._activityTracker = activityTracker;
    this._bandwidthEstimator = bandwidthEstimator;
    this._mtu = mtu;
    this._transferEncoding = transferEncoding;
    this._pingIntervalMs = pingIntervalMs;
    this._base64Reader = new Base64Reader();

    this._rttMs = INITIAL_RTT_MS;
    this._running = false;
    this._receivedPong = false;
    this._messageCallback = null;
    this._rttChangeCallback = null;
    this._pingTimeoutId = null;
    this._bandwidthTimeoutId = null;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(ChannelController, [{
    key: 'toString',
    value: function toString() {
      return 'channelController{' + (this._running ? 'started' : 'stopped') + ',rtt=' + this._rttMs + ',buffer=' + this._buffer + '}';
    }
  }, {
    key: 'start',
    value: function start(_ref) {
      var channel = _ref.channel,
          onMessage = _ref.onMessage,
          onRttChange = _ref.onRttChange,
          _ref$disablePinging = _ref.disablePinging,
          disablePinging = _ref$disablePinging === undefined ? false : _ref$disablePinging;

      if (this._running) {
        throw new Error('already started');
      }
      this._running = true;
      this._buffer.setNotificationListener(this._onSendAttempt);
      this._base64Reader.reset();

      this._messageCallback = onMessage;
      this._rttChangeCallback = onRttChange;
      if (this._bandwidthEstimator) {
        this._bandwidthEstimator.reset();
      }
      this._channelDriver.start({
        channel: channel,
        onMessage: this._onMessage,
        onSendAttempt: this._onSendAttempt
      });

      if (!disablePinging) {
        this._receivedPong = false;
        this._sendPing();
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      if (!this._running) {
        throw new Error('already stopped');
      }
      this._running = false;
      this._buffer.setNotificationListener(null);
      this._channelDriver.stop();
      this._messageCallback = null;
      this._base64Reader.reset();

      this._receivedPong = false;
      clearInterval(this._pingTimeoutId);
      this._pingTimeoutId = null;
      if (this._bandwidthTimeoutId) {
        clearTimeout(this._bandwidthTimeoutId);
        this._bandwidthTimeoutId = null;
      }
    }

    /**
     * Immediately sends a message.
     *
     * @param {string} message - Message to send.
     */

  }, {
    key: 'sendImmediateMessage',
    value: function sendImmediateMessage(message) {
      this._sendData(message);
    }
  }, {
    key: '_onMessage',
    value: function _onMessage(data) {
      if (this._activityTracker) {
        this._activityTracker.registerActivity();
      }
      if (typeof data !== 'string') {
        this._messageCallback(data);
        return;
      }

      if (this._base64Reader.reading) {
        var message = this._base64Reader.write(data);
        if (message) {
          this._messageCallback(message);
        }
        return;
      }

      var messageType = data[0];

      switch (messageType) {
        case __WEBPACK_IMPORTED_MODULE_5_datamux_constants__["j" /* MT_PING */]:
          this._handlePing(data.slice(1));
          return;
        case __WEBPACK_IMPORTED_MODULE_5_datamux_constants__["k" /* MT_PONG */]:
          this._handlePong(data.slice(1));
          return;
        case __WEBPACK_IMPORTED_MODULE_5_datamux_constants__["l" /* MT_TRANSFER_BINARY_DATA */]:
          {
            var sepIndex = data.indexOf(__WEBPACK_IMPORTED_MODULE_5_datamux_constants__["d" /* M_SEP */]);
            var lengthStr = data.slice(1, sepIndex < 0 ? undefined : sepIndex);
            var length = parseInt(lengthStr, __WEBPACK_IMPORTED_MODULE_5_datamux_constants__["e" /* ID_BASE */]);
            this._base64Reader.begin(length);

            var chunk = data.slice(sepIndex + __WEBPACK_IMPORTED_MODULE_5_datamux_constants__["d" /* M_SEP */].length);
            var _message = this._base64Reader.write(chunk);
            if (_message) {
              this._messageCallback(_message);
            }
            return;
          }
      }

      this._messageCallback(data);
    }
  }, {
    key: '_handlePing',
    value: function _handlePing(message) {
      // some input validation so we don't echo back anything we receive
      var pingTime = parseInt(message, 36);
      if (!pingTime) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'received invalid ping message: \'' + message + '\'');
        return;
      }
      this._sendData(__WEBPACK_IMPORTED_MODULE_5_datamux_constants__["k" /* MT_PONG */] + pingTime.toString(36));
    }
  }, {
    key: '_handlePong',
    value: function _handlePong(message) {
      this._receivedPong = true;

      var pingSendTime = parseInt(message, 36);
      if (!pingSendTime) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].error(TAG, 'received invalid pong message: \'' + message + '\'');
        return;
      }
      var rttMs = Date.now() - pingSendTime;

      // we are heavily biased towards minimum ping, with a = 3/4, otherwise a = 1/8
      if (rttMs <= this._rttMs) {
        this._rttMs = this._rttMs / 4 + 3 * (rttMs / 4);
      } else {
        this._rttMs = 7 * (this._rttMs / 8) + rttMs / 8;
      }
      this._rttChangeCallback && this._rttChangeCallback(this._rttMs);

      // When the ping timeout expires we only send a new ping if we have
      // received a pong. This is true if the timeout expired before a pong,
      // so we can send a new ping straight away.
      if (!this._pingTimeoutId) {
        __WEBPACK_IMPORTED_MODULE_2_common_log__["default"].debug(TAG, 'received pong after ping timeout had expired');
        this._sendPing();
      }
    }
  }, {
    key: '_sendPing',
    value: function _sendPing() {
      this._sendData(__WEBPACK_IMPORTED_MODULE_5_datamux_constants__["j" /* MT_PING */] + Date.now().toString(36));
      this._startPingTimeout();
    }
  }, {
    key: '_startPingTimeout',
    value: function _startPingTimeout() {
      var _this = this;

      this._pingTimeoutId = setTimeout(function () {
        if (_this._receivedPong) {
          _this._sendPing();
        } else {
          _this._pingTimeoutId = null;
        }
      }, this._pingIntervalMs);
    }
  }, {
    key: '_onSendAttempt',
    value: function _onSendAttempt() {
      if (this._bandwidthTimeoutId) {
        clearTimeout(this._bandwidthTimeoutId);
        this._bandwidthTimeoutId = null;
      }
      var bytesToSend = this._channelDriver.bytesToSend;

      var bytesAvailable = this._bandwidthEstimator ? this._bandwidthEstimator.bytesAvailable : Infinity;
      if (bytesAvailable < bytesToSend) {
        bytesToSend = bytesAvailable;
      }
      while (bytesToSend > 0) {
        var messageSize = bytesToSend;
        if (messageSize > this._mtu) {
          messageSize = this._mtu;
        }

        var data = this._buffer.read(messageSize, this._transferEncoding);
        if (data) {
          var sentBytes = this._sendData(data);
          bytesToSend -= sentBytes;
        } else {
          break;
        }
      }
      // If the buffer isn't empty and the channel driver is able to send more
      // data, it means that we've been limited by the bandwidth estiamtor.
      // If that's the case, we schedule a timeout for when there should
      // be more bandwidth available to use.
      if (!this._buffer.empty && this._channelDriver.bytesToSend > 0) {
        var retryTimeoutMs = this._bandwidthEstimator.calculateRetryTimeoutMs();
        this._bandwidthTimeoutId = setTimeout(this._onSendAttempt, retryTimeoutMs);
      }
    }
  }, {
    key: '_sendData',
    value: function _sendData(data) {
      var dataSize = data.byteLength || data.length || 0;
      this._channelDriver.send(data);
      if (this._bandwidthEstimator) {
        this._bandwidthEstimator.consumeSendBytes(dataSize);
      }
      return dataSize;
    }
  }, {
    key: 'rttMs',
    get: function get() {
      return this._rttMs;
    }
  }, {
    key: 'running',
    get: function get() {
      return this._running;
    }
  }]);

  return ChannelController;
}();

/* harmony default export */ __webpack_exports__["a"] = (ChannelController);

/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DEFAULT_LOW_THRESHOLD */
/* unused harmony export DEFAULT_HIGH_THRESHOLD */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_argCheck__ = __webpack_require__(12);


// This module contains the ChannelDriver class, which
// is used to notify when the underlying data channel
// implementation wants to send more data.







var TAG = 'datamux';

var DEFAULT_LOW_THRESHOLD = 0x10000;
var DEFAULT_HIGH_THRESHOLD = 0x20000;
var DEFAULT_FALLBACK_PROCESS_INTERVAL_MS = 100;

var ChannelDriver = function () {
  function ChannelDriver() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ChannelDriver);

    var _options$lowThreshold = options.lowThreshold,
        lowThreshold = _options$lowThreshold === undefined ? DEFAULT_LOW_THRESHOLD : _options$lowThreshold,
        _options$highThreshol = options.highThreshold,
        highThreshold = _options$highThreshol === undefined ? DEFAULT_HIGH_THRESHOLD : _options$highThreshol,
        _options$fallbackInte = options.fallbackIntervalMs,
        fallbackIntervalMs = _options$fallbackInte === undefined ? DEFAULT_FALLBACK_PROCESS_INTERVAL_MS : _options$fallbackInte;


    if (highThreshold < lowThreshold) {
      __WEBPACK_IMPORTED_MODULE_4_common_argCheck__["a" /* default */].error(this, 'options.highThreshold', 'be lower than options.lowThreshold');
    }

    this._lowThreshold = lowThreshold;
    this._highThreshold = highThreshold;
    this._fallbackIntervalMs = fallbackIntervalMs;

    // To make sure we don't handle old events, see datamux.js
    this._eventEpoch = 1;

    this._channel = null;
    this._messageCallback = null;
    this._sendAttemptCallback = null;
    this._processIntervalId = null;
  }

  // The number of bytes available until the high-watermark
  // is reached.


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(ChannelDriver, [{
    key: 'start',


    // Call to start sending and receiving data on a channel.
    // Each time a message is received, the onMessage callback
    // will be called. Each time it's worthwhile checking the state
    // of the send buffer, the onSendAttempt callback is called.
    value: function start(_ref) {
      var channel = _ref.channel,
          onMessage = _ref.onMessage,
          onSendAttempt = _ref.onSendAttempt;

      if (this._channel) {
        throw new Error('Tried to start sender while already started');
      }
      this._channel = channel;
      this._messageCallback = onMessage;
      this._sendAttemptCallback = onSendAttempt;

      var _onMessage = this._onMessage.bind(this, this._eventEpoch);
      var _onSendAttempt = this._onSendAttempt.bind(this, this._eventEpoch);

      this._channel.onmessage = _onMessage;

      this._hasBufferedAmountLowEvent = typeof channel.bufferedAmountLowThreshold === 'number';
      if (this._hasBufferedAmountLowEvent) {
        this._channel.bufferedAmountLowThreshold = this._lowThreshold;
        this._channel.onbufferedamountlow = _onSendAttempt;
        __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.reject().catch(_onSendAttempt);
      } else {
        this._processIntervalId = setInterval(_onSendAttempt, this._fallbackIntervalMs);
      }
    }

    // Stops the processing of the current channel. As soon as
    // this message has been called it is possible to call
    // start with a new or the same channel.

  }, {
    key: 'stop',
    value: function stop() {
      if (!this._channel) {
        throw new Error('Tried to stop sender while already stopped');
      }

      this._eventEpoch += 1;

      if (this._hasBufferedAmountLowEvent) {
        this._channel.onbufferedamountlow = null;
      } else {
        clearInterval(this._processIntervalId);
        this._processIntervalId = null;
      }

      this._channel.onmessage = null;
      this._channel = null;
      this._sendAttemptCallback = null;
    }
  }, {
    key: 'send',
    value: function send(data) {
      if (!this._channel) {
        throw new Error('channelDriver.send() called while stopped');
      }
      if (this._channel.readyState === 'open') {
        try {
          this._channel.send(data);
          return true;
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].info(TAG, this, 'failed to send data on channel, ' + error);
        }
      }
      return false;
    }
  }, {
    key: '_onMessage',
    value: function _onMessage(eventEpoch, event) {
      if (eventEpoch !== this._eventEpoch) {
        return;
      }
      var data = event.data;

      if (this._messageCallback) {
        this._messageCallback(data);
      }
    }
  }, {
    key: '_onSendAttempt',
    value: function _onSendAttempt(eventEpoch) {
      if (eventEpoch !== this._eventEpoch) {
        return;
      }
      if (this._sendAttemptCallback) {
        this._sendAttemptCallback();
      }
    }
  }, {
    key: 'bytesToSend',
    get: function get() {
      var bytes = this._highThreshold - this._channel.bufferedAmount;
      if (bytes < 0) {
        return 0;
      }
      return bytes;
    }
  }]);

  return ChannelDriver;
}();

/* harmony default export */ __webpack_exports__["a"] = (ChannelDriver);

/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export PairingNamespace */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);


// This module contains the channel registry, which
// is used to keep track of local and remote channels
// of different types, in different namespaces.






var TAG = 'datamux';

/**
 * Keeps track of pairing channels within a namespace and pairs them up.
 * Non-pairing channels also have a namespaceId, but we don't bother
 * tracking them here.
 */
var PairingNamespace = function () {
  function PairingNamespace() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, PairingNamespace);

    this._byPairingId = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
    this._remoteInfos = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(PairingNamespace, [{
    key: 'cleanup',
    value: function cleanup() {
      this._byPairingId.clear();
      this._byPairingId = null;
      this._remoteInfos.clear();
      this._remoteInfos = null;
    }
  }, {
    key: 'clearRemoteInfos',
    value: function clearRemoteInfos() {
      this._remoteInfos.clear();
      this._byPairingId.clear();
    }
  }, {
    key: 'clearLocalChannels',
    value: function clearLocalChannels() {
      this._byPairingId.clear();
    }
  }, {
    key: 'trimByRemoteId',
    value: function trimByRemoteId(minimumRemoteId) {
      var _this = this;

      this._remoteInfos.forEach(function (remoteInfo, key) {
        if (remoteInfo.remoteId < minimumRemoteId) {
          _this._remoteInfos.delete(key);
        }
      });
    }
  }, {
    key: 'add',
    value: function add(channel) {
      var pairingId = channel._pairingId;
      if (!pairingId) {
        throw new Error('Tried to add channel without pairingId to pairing namespace');
      }
      var remoteInfo = this._remoteInfos.get(pairingId);
      if (remoteInfo) {
        channel._setRemoteId(remoteInfo.remoteId);
        this._remoteInfos.delete(pairingId);
      }
      this._byPairingId.set(pairingId, channel);
    }
  }, {
    key: 'addPairingInfo',
    value: function addPairingInfo(_ref) {
      var remoteId = _ref.remoteId,
          label = _ref.label,
          protocol = _ref.protocol,
          pairingId = _ref.pairingId;

      var channel = this._byPairingId.get(pairingId);
      if (channel) {
        if (channel.label !== label) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'label mismatch for pairing channel \'' + pairingId + '\', ' + channel.label + ' != \'' + label + '\'');
          return;
        }
        if (channel.protocol !== protocol) {
          var values = '\'' + pairingId + '\', ' + channel.protocol + ' != \'' + protocol + '\'';
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'protocol mismatch for pairing channel ' + values);
          return;
        }
        return channel;
      } else {
        this._remoteInfos.set(pairingId, { remoteId: remoteId, label: label, protocol: protocol });
      }
    }
  }, {
    key: 'validateConfig',
    value: function validateConfig(_ref2) {
      var label = _ref2.label,
          protocol = _ref2.protocol,
          pairingId = _ref2.pairingId;

      if (this._byPairingId.has(pairingId)) {
        throw new Error('Pairing channel id ' + pairingId + ' already exists');
      }
      var remoteInfo = this._remoteInfos.get(pairingId);
      if (remoteInfo) {
        if (remoteInfo.label !== label) {
          throw new Error('Pairing channel label does not match remote label, ' + (remoteInfo.label + ' != ' + label));
        }
        if (remoteInfo.protocol !== protocol) {
          throw new Error('Pairing channel protocol does not match remote protocol, ' + (remoteInfo.protocol + ' != ' + protocol));
        }
      }
    }
  }]);

  return PairingNamespace;
}();

/**
 * Stores all channels and makes it possible to look them up by different IDs.
 *
 * Also responsible for linking local and remote channels.
 */

var MuxChannelRegistry = function () {
  function MuxChannelRegistry() {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, MuxChannelRegistry);

    this._channelIdCounter = 1;

    // Any non-builtin channel which has or receives a remote id below
    // this number will be instantly closed
    this._minimumRemoteId = 0;
    // Any channel below this ID may not be linked to a remote id
    this._minimumLocalId = 0;

    // Builtin channels are created inside the library in a deterministic order
    // that should not change between protocol versions. The are used for internal
    // communication, and the purpose is to reduce setup time and bandwidth usage.
    this._builtinChannels = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();

    // Keeps track of local channels
    this._localChannels = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();

    // Tracks all channels, but resets on disconnect
    this._byRemoteId = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
    this._namespaces = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_map___default.a();
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(MuxChannelRegistry, [{
    key: 'toString',
    value: function toString() {
      return 'channelRegistry{local=' + this._localChannels.size + ',remote=' + this._byRemoteId.size + '}';
    }
  }, {
    key: 'cleanup',
    value: function cleanup() {
      this.clearConnections();
      this._builtinChannels.clear();
      this._builtinChannels = null;
      this._localChannels.clear();
      this._localChannels = null;
      this._byRemoteId = null;
      this._namespaces.forEach(function (namespace) {
        return namespace.cleanup();
      });
      this._namespaces.clear();
      this._namespaces = null;
    }
  }, {
    key: 'clearConnections',
    value: function clearConnections() {
      this._builtinChannels.forEach(function (channel) {
        return channel._close();
      });
      this._localChannels.forEach(function (channel) {
        return channel._close();
      });
      this._localChannels.clear();
      this._namespaces.forEach(function (namespace) {
        return namespace.clearRemoteInfos();
      });
      this._namespaces.clear();
      this._byRemoteId.clear();
    }

    // Clears all paired and normal channels, but keeps builtin ones
    // Returns a channel id to use as the minimum id by the peer.

  }, {
    key: 'clearAppConnections',
    value: function clearAppConnections() {
      var _this2 = this;

      this._localChannels.forEach(function (channel) {
        return channel._close();
      });
      this._localChannels.clear();
      this._namespaces.forEach(function (namespace) {
        return namespace.clearLocalChannels();
      });

      this._byRemoteId.forEach(function (channel) {
        if (!channel._builtin) {
          channel._close();
        }
      });
      // We clear everything and then add back the buildin ones
      this._byRemoteId.clear();
      this._builtinChannels.forEach(function (channel) {
        if (channel._remoteId) {
          _this2._byRemoteId.set(channel._remoteId, channel);
        }
      });

      this._minimumLocalId = this._channelIdCounter;

      return this._channelIdCounter;
    }
  }, {
    key: 'clearNamespace',
    value: function clearNamespace(namespaceId) {
      var _this3 = this;

      var namespace = this._namespaces.get(namespaceId);
      if (namespace) {
        namespace.cleanup();
        this._namespaces.delete(namespaceId);
      }
      var removeChannel = function removeChannel(channel) {
        if (channel._namespaceId === namespaceId) {
          _this3.remove(channel);
          if (channel._remoteId) {
            _this3._byRemoteId.delete(channel._remoteId);
          }
          _this3._localChannels.delete(channel._localId);
          channel._close();
        }
      };
      this._localChannels.forEach(removeChannel);
      this._byRemoteId.forEach(removeChannel);
    }
  }, {
    key: 'setMinimumRemoteId',
    value: function setMinimumRemoteId(minimumRemoteId) {
      var _this4 = this;

      this._minimumRemoteId = minimumRemoteId;

      this._byRemoteId.forEach(function (channel, remoteId) {
        if (channel._builtin) {
          return;
        }
        if (channel._remoteId && channel._remoteId < minimumRemoteId) {
          channel._close();
          _this4._byRemoteId.delete(remoteId);
        }
      });

      this._namespaces.forEach(function (namespace) {
        return namespace.trimByRemoteId(minimumRemoteId);
      });
    }
  }, {
    key: 'getNextId',
    value: function getNextId() {
      var channelId = this._channelIdCounter;
      this._channelIdCounter += 1;
      return channelId;
    }
  }, {
    key: 'getByRemoteId',
    value: function getByRemoteId(id) {
      return this._byRemoteId.get(id);
    }
  }, {
    key: 'forEachLocalChannel',
    value: function forEachLocalChannel(func, thisArg) {
      this._localChannels.forEach(func, thisArg);
    }
  }, {
    key: 'connectBuiltins',
    value: function connectBuiltins() {
      var _this5 = this;

      this._builtinChannels.forEach(function (channel) {
        _this5._byRemoteId.set(channel._localId, channel);
        channel._setRemoteId(channel._localId);
      });
    }
  }, {
    key: 'addBuiltin',
    value: function addBuiltin(channel) {
      this._builtinChannels.set(channel._localId, channel);
    }
  }, {
    key: 'addLocal',
    value: function addLocal(channel) {
      this._localChannels.set(channel._localId, channel);
      if (channel._pairingId) {
        this._getPairingNamespace(channel._namespaceId).add(channel);
      }
      if (channel._remoteId) {
        // might be set in namespace if pairing
        this._byRemoteId.set(channel._remoteId, channel);
      }
    }
  }, {
    key: 'addRemote',
    value: function addRemote(_ref3) {
      var channel = _ref3.channel,
          remoteId = _ref3.remoteId;

      if (remoteId < this._minimumRemoteId) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].info(TAG, 'won\'t add channel with remote id ' + remoteId + ', minimum is ' + this._minimumRemoteId);
        return;
      }
      var oldRemoteId = channel._remoteId;
      channel._setRemoteId(remoteId);
      if (oldRemoteId) {
        this._byRemoteId.delete(oldRemoteId);
      }
      this._byRemoteId.set(channel._remoteId, channel);
    }
  }, {
    key: 'remove',
    value: function remove(channel) {
      if (channel._remoteId) {
        if (!this._byRemoteId.delete(channel._remoteId)) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'could not find channel to remove with remote id \'' + channel._remoteId + '\'');
        }
      }
      if (channel._isLocal) {
        this._localChannels.delete(channel._localId);
      }
    }
  }, {
    key: 'link',
    value: function link(_ref4) {
      var localId = _ref4.localId,
          remoteId = _ref4.remoteId;

      if (remoteId < this._minimumRemoteId) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].info(TAG, 'won\'t link channel with remote id ' + remoteId + ', minimum is ' + this._minimumRemoteId);
        return;
      }
      if (localId < this._minimumLocalId) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].info(TAG, 'won\'t link channel with local id ' + localId + ', minimum is ' + this._minimumLocalId);
        return;
      }
      var channel = this._localChannels.get(localId);
      if (channel) {
        channel._setRemoteId(remoteId);
        this._byRemoteId.set(remoteId, channel);
      } else {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].warning(TAG, 'link channel with local id \'' + localId + '\' not found for remote id ' + remoteId);
      }
    }
  }, {
    key: 'validateConfig',
    value: function validateConfig(_ref5) {
      var label = _ref5.label,
          protocol = _ref5.protocol,
          namespaceId = _ref5.namespaceId,
          pairingId = _ref5.pairingId;

      if (pairingId) {
        this._getPairingNamespace(namespaceId).validateConfig({ label: label, protocol: protocol, pairingId: pairingId });
      }
    }
  }, {
    key: 'addPairingInfo',
    value: function addPairingInfo(_ref6) {
      var remoteId = _ref6.remoteId,
          namespaceId = _ref6.namespaceId,
          label = _ref6.label,
          protocol = _ref6.protocol,
          pairingId = _ref6.pairingId;

      if (remoteId < this._minimumRemoteId) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].info(TAG, 'won\'t add pairing info with remote id ' + remoteId + ', minimum is ' + this._minimumRemoteId);
        return;
      }
      var channel = this._getPairingNamespace(namespaceId).addPairingInfo({ remoteId: remoteId, label: label, protocol: protocol, pairingId: pairingId });
      if (channel) {
        var oldRemoteId = channel._remoteId;
        channel._setRemoteId(remoteId);
        if (oldRemoteId) {
          this._byRemoteId.delete(oldRemoteId);
        }
        this._byRemoteId.set(channel._remoteId, channel);
      }
    }
  }, {
    key: '_getPairingNamespace',
    value: function _getPairingNamespace(namespaceId) {
      var namespace = this._namespaces.get(namespaceId);
      if (!namespace) {
        namespace = new PairingNamespace(namespaceId);
        this._namespaces.set(namespaceId, namespace);
      }
      return namespace;
    }
  }]);

  return MuxChannelRegistry;
}();

/* harmony default export */ __webpack_exports__["a"] = (MuxChannelRegistry);

/***/ }),
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CallStore */
/* harmony export (immutable) */ __webpack_exports__["a"] = CallRegistry;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_keys__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_keys___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_keys__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_utils__ = __webpack_require__(13);









var Call;
var Conference;
var StatsFormatter;

if (true) {
  /* global require:false */
  Call = __webpack_require__(224).default;
  StatsFormatter = __webpack_require__(200).default;

  Conference = __webpack_require__(212).default;
}

var TAG = 'call-registry';

var CONFERENCE_SIGNALING_VERSION = 1;

function CallStore() {
  this._rooms = {};
  this._passiveCalls = {};
}

CallStore.prototype = {
  constructor: CallStore,
  toString: function toString() {
    return 'callStore{}';
  },
  getCallsInRoom: function getCallsInRoom(room) {
    return this._rooms[room.id] || {};
  },
  getCallInRoomToPeer: function getCallInRoomToPeer(room, peer) {
    var callsInRoom = this._rooms[room.id];
    return callsInRoom && callsInRoom[peer.id];
  },
  getPassiveCallInRoom: function getPassiveCallInRoom(room) {
    return this._passiveCalls[room.id];
  },
  putPassiveCall: function putPassiveCall(call) {
    this._passiveCalls[call.room.id] = call;
  },
  putCall: function putCall(call) {
    var roomId = call.room.id;
    var peerId = call.peerId;
    var callsInRoom = this._rooms[roomId] = this._rooms[roomId] || {};
    callsInRoom[peerId] = call;
  },
  removeCall: function removeCall(call) {
    if (call._isPassive) {
      delete this._passiveCalls[call.room.id];
    } else {
      var callsInRoom = this._rooms[call.room.id];
      delete callsInRoom[call.peerId];
      if (__WEBPACK_IMPORTED_MODULE_3_babel_runtime_core_js_object_keys___default()(callsInRoom).length === 0) {
        delete this._rooms[call.room.id];
      }
    }
  },
  clear: function clear() {
    this._rooms = {};
    this._passiveCalls = {};
  }
};

function CallRegistry(dependencies) {
  this._userRegistry = dependencies.userRegistry;
  this._delegate = dependencies.delegate;
  this._dependencies = null;
  this._callStore = new CallStore();
  this._conferences = new __WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_map___default.a();
}

CallRegistry.prototype = {
  constructor: CallRegistry,
  toString: function toString() {
    return 'callRegistry{}';
  },

  // peer is falsy if it's a passive call
  startCall: function startCall(room, peer) {
    var currentCall = null;
    if (peer) {
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, 'starting call to ' + peer + ' in ' + room);
      currentCall = this._callStore.getCallInRoomToPeer(room, peer);

      if (currentCall) {
        if (currentCall.stopped) {
          currentCall.start();
        }
        return currentCall;
      }
      return this._createCall(room, peer, null);
    }

    __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, 'starting passive call in ' + room);
    currentCall = this._callStore.getPassiveCallInRoom(room);
    if (currentCall) {
      throw new Error('Tried to start passive call with an ongoing passive call');
    }

    // If there are incoming calls we hijack the most recent one when starting a passive call
    var calls = this._callStore.getCallsInRoom(room);
    var incomingCalls = [];
    for (var index in calls) {
      currentCall = calls[index];
      if (currentCall._signaler._receivedOffer) {
        incomingCalls.push(currentCall);
      } else {
        throw new Error('Tried to start passive call in room with active calls.');
      }
    }
    incomingCalls.sort(function (a, b) {
      return b._signaler._receivedOffer.timestamp - a._signaler._receivedOffer.timestamp;
    });
    __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, 'have ' + incomingCalls.length + ' incoming calls when starting passive call');
    // hang up old calls and close the most recent one, then reuse the offer.
    incomingCalls.slice(1).forEach(function (call) {
      call.hangup();
    });

    var call = this._createCall(room, null);
    if (incomingCalls[0]) {
      var peerId = incomingCalls[0].peerId;
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].info(TAG, 'hijacking offer from ' + peerId + ' to start passive call');
      var hijackedOffer = incomingCalls[0]._signaler._receivedOffer;
      incomingCalls[0].close();
      call._setPeerId(peerId);
      call.handleSignalingMessage(hijackedOffer);
    }
    return call;
  },

  startConference: function startConference(room, options) {
    __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, 'starting conference call in ' + room);
    var conference = this._conferences.get(room.id);
    if (!conference) {
      conference = this._createConference(room, options);
      this._conferences.set(room.id, conference);
    }
    if (conference.stopped) {
      conference.start(options);
    }
    return conference;
  },
  getConferenceInRoom: function getConferenceInRoom(room) {
    return this._conferences.get(room.id) || null;
  },


  closeCallsInRoom: function closeCallsInRoom(room) {
    var calls = this._callStore.getCallsInRoom(room);
    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_common_utils__["forEach"])(calls, function (call) {
      call.close();
    });
  },

  getCallsInRoom: function getCallsInRoom(room) {
    return this._callStore.getCallsInRoom(room);
  },

  getPassiveCallInRoom: function getPassiveCallInRoom(room) {
    return this._callStore.getPassiveCallInRoom(room) || null;
  },

  // dependencies.ownUser
  // dependencies.reporter
  // dependencies.baseRequest
  // dependencies.iceServers
  init: function init(dependencies) {
    this._ownUser = dependencies.ownUser;
    this._reporter = dependencies.reporter;
    this._sendEvent = dependencies.baseRequest.path('rooms', '{roomId}', 'send');
    this._iceServers = dependencies.iceServers;
    this._iceCandidateFilter = dependencies.iceCandidateFilter;
    return this;
  },
  clear: function clear() {
    this._ownUser = null;
    this._reporter = null;
    this._sendEvent = null;
    this._iceServers = null;
    this._iceCandidateFilter = null;
    this._callStore.clear();
  },

  // handle event after it's been converted by room
  _handleEvent: function _handleEvent(event) {
    if (event.sender === this._ownUser) {
      return;
    }
    if (event.isPastEvent) {
      return;
    }
    if (event.type === 'cct.call.message') {
      this._handleCallEvent(event);
    } else if (event.type === 'cct.conference.messages') {
      this._handleConferenceEvent(event);
    }
  },

  _handleCallEvent: function _handleCallEvent(event) {
    if (event.room.membership !== 'member') {
      return __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].error('call-registry', 'received call event, but was not a member of ' + event.room);
    }

    var _event$content = event.content,
        recipient = _event$content.recipient,
        message = _event$content.message;

    if (recipient && recipient !== this._ownUser._matrixId) {
      return;
    }

    if (message.offer) {
      this._handleCallOffer(event);
    } else {
      var call = this._callStore.getCallInRoomToPeer(event.room, event.sender);
      if (!call) {
        call = this._callStore.getPassiveCallInRoom(event.room);
      }
      if (!call) {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].warning(TAG, this._ownUser + ' got unknown call event from ' + event.sender + ': ' + __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify___default()(message));
        return;
      }
      call.handleSignalingMessage(message);
    }
  },


  _handleCallOffer: function _handleCallOffer(_ref) {
    var room = _ref.room,
        sender = _ref.sender,
        content = _ref.content;

    __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, 'incoming call from peer ' + sender + ': ' + __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify___default()(content.message));

    var activeCall = this._callStore.getCallInRoomToPeer(room, sender);
    if (activeCall) {
      activeCall.handleSignalingMessage(content.message);
      return;
    }
    var passiveCall = this._callStore.getPassiveCallInRoom(room);
    if (passiveCall) {
      var peerId = sender.id;
      if (peerId && passiveCall._setPeerId(peerId)) {
        Object.defineProperty(passiveCall, 'peer', {
          configurable: true,
          enumerable: true,
          value: sender
        });
        passiveCall._emit('peer', sender);
        passiveCall.handleSignalingMessage(content.message);
      }
      return;
    }

    var incomingCall = this._createCall(room, sender, content.message);
    this._delegate._onIncomingCall(incomingCall);
    room._emit('call', incomingCall);
    room._emit('calls', this._callStore.getCallsInRoom(room));
  },

  _handleConferenceEvent: function _handleConferenceEvent(_ref2) {
    var _this = this;

    var room = _ref2.room,
        sender = _ref2.sender,
        content = _ref2.content;

    if (content.version !== CONFERENCE_SIGNALING_VERSION) {
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].warning(TAG, 'got conference signaling with wrong version, ' + content.version + ', make sure all ' + 'conference participants are using the same version of libcct');
      return;
    }
    var conference = this._conferences.get(room.id);
    content.messages.forEach(function (message) {
      if (conference) {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].verbose(TAG, 'forwarding conference message:', message);
        conference.handleSignalingMessage(sender.id, message);
      } else if (message.type === 'search') {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].verbose(TAG, 'got first conference join:', message);
        conference = _this._createConference(room);
        _this._delegate._onIncomingConference();
        room._emit('conference', conference);
        conference.handleSignalingMessage(sender.id, message);
      } else {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].verbose(TAG, 'dropped conference message:', message);
      }
    });
  },


  // peer is falsy if it's a passive call
  _createCall: function _createCall(room, peer, offer) {
    var peerId = peer ? peer.id : null;
    var statsFormatter = this._reporter && new StatsFormatter({
      'userId': this._ownUser.id,
      'roomId': room.id,
      'peerId': peerId
    }, this._reporter);

    var call = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_common_utils__["priv"])(Call, {
      peerId: peerId,
      offer: offer,
      userId: this._ownUser.id,
      onSignalingMessage: this._onCallMessage.bind(this, room, peer && peer._matrixId),
      onClosed: this._onCallClosed.bind(this, room),
      iceServers: this._iceServers,
      iceCandidateFilter: this._iceCandidateFilter,
      statsFormatter: statsFormatter
    });

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties___default()(call, {
      room: {
        configurable: true,
        enumerable: true,
        value: room
      },
      peer: {
        configurable: true,
        enumerable: true,
        value: peer
      }
    });

    if (peerId) {
      this._callStore.putCall(call);
    } else {
      this._callStore.putPassiveCall(call);
    }
    if (peerId && !offer) {
      // outgoing non-passive call
      call.start();
    }
    return call;
  },

  _onCallMessage: function _onCallMessage(room, recipient, message) {
    room.send('cct.call.message', { message: message, recipient: recipient }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].warning(TAG, 'failed to send call signaling message, ' + error);
    });
  },

  _onCallClosed: function _onCallClosed(room, call) {
    this._callStore.removeCall(call);
    room._emit('calls', this._callStore.getCallsInRoom(room));
  },

  _createConference: function _createConference(room) {
    var _this2 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var statsFormatterFactory = null;
    if (this._reporter) {
      statsFormatterFactory = function statsFormatterFactory(peerId) {
        return new StatsFormatter({
          peerId: peerId,
          roomId: room.id,
          userId: _this2._ownUser.id
        }, _this2._reporter);
      };
    }

    var switcherMode = options.switcherMode;


    var conference = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_common_utils__["priv"])(Conference, {
      userId: this._ownUser.id,
      statsFormatterFactory: statsFormatterFactory,
      switcherMode: switcherMode,
      onSignalingMessage: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5_common_utils__["createTimedBuffer"])(50, this._onConferenceMessages.bind(this, room)),
      onClosed: this._onConferenceClosed.bind(this, room),
      iceServers: this._iceServers,
      iceCandidateFilter: this._iceCandidateFilter
    });

    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_define_properties___default()(conference, {
      room: {
        configurable: true,
        enumerable: true,
        value: room
      }
    });

    this._conferences.set(room.id, conference);

    return conference;
  },

  _onConferenceMessages: function _onConferenceMessages(room, messages) {
    room.send('cct.conference.messages', {
      messages: messages,
      version: CONFERENCE_SIGNALING_VERSION
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].warning(TAG, 'failed to send conference signaling message: ' + error);
    });
  },

  _onConferenceClosed: function _onConferenceClosed(room) {
    this._conferences.delete(room.id);
    room._emit('conference', null);
  }
};

/***/ }),
/* 276 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_matrix_room__ = __webpack_require__(187);











// How long we'll wait for the initial m.room.create
var ROOM_CREATE_TIMEOUT = 20000;
// How long we'll wait after the initial m.room.create until all events are received
var ROOM_PREPARE_TIMEOUT = 30000;

var TAG = 'room-registry';

// dependencies.delegate._onRoomEvent
// dependencies.delegate._onRoomCreated

var RoomRegistry = function () {
  function RoomRegistry(dependencies) {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, RoomRegistry);

    this._roomMap = {};
    this._roomArray = [];
    this._deferredRooms = {};
    this._roomDependencies = null;
    this._delegate = dependencies.delegate;
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(RoomRegistry, [{
    key: 'toString',
    value: function toString() {
      var serverName = this._roomDependencies ? this._roomDependencies.serverName : '';
      return 'roomRegistry{serverName=' + serverName + '}';
    }
  }, {
    key: 'getRooms',
    value: function getRooms() {
      return this._roomArray;
    }
  }, {
    key: 'getRoom',
    value: function getRoom(matrixId) {
      return this._roomMap[matrixId];
    }
  }, {
    key: 'getOrCreateEmptyRoom',
    value: function getOrCreateEmptyRoom(matrixId) {
      var room = this._roomMap[matrixId];
      if (room) {
        return room;
      }
      return this._createRoom(matrixId);
    }
  }, {
    key: 'waitForRoom',
    value: function waitForRoom(matrixId, lastState, invitedUserIds) {
      var _this = this;

      var lastStateStr = __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_json_stringify___default()(lastState);
      var invitesStr = invitedUserIds.join(',');
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, this + ' waiting for ' + matrixId + ' lastState=' + lastStateStr + ' invites=' + invitesStr);

      return this._waitForRoomCreation(matrixId).then(function (room) {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, _this + ' got room ' + matrixId + ', now waiting for state');
        var roomReady = __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.all([_this._waitForRoomState(room, lastState.type, lastState.stateKey), _this._waitForRoomInvites(room, invitedUserIds)]);
        var readyTimeout = new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
          setTimeout(function () {
            reject(new Error('timed out after ' + ROOM_CREATE_TIMEOUT + 'ms while waiting for ' + room + ' to be prepared'));
          }, ROOM_PREPARE_TIMEOUT);
        });
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.race([roomReady, readyTimeout]).then(function () {
          return room;
        });
      });
    }
  }, {
    key: '_waitForRoomCreation',
    value: function _waitForRoomCreation(matrixId) {
      var room = this._roomMap[matrixId];
      if (room) {
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve(room);
      }
      var deferred = this._deferredRooms[matrixId] = this._deferredRooms[matrixId] || [];
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {
        setTimeout(function () {
          reject(new Error('timed out after ' + ROOM_CREATE_TIMEOUT + 'ms while waiting for room, ' + matrixId));
        }, ROOM_CREATE_TIMEOUT);
        deferred.push(resolve);
      });
    }
  }, {
    key: '_waitForRoomState',
    value: function _waitForRoomState(room, type, stateKey) {
      var state = room.state(type);
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, this + ' waiting for room state ' + type + '/' + (stateKey || '') + ' in ' + room);

      if (type === 'm.room.aliases') {
        // Aliases state key is the server name, which can get tricky, so we
        // just check for any alias state instead.
        if (state.keys.length) {
          return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve();
        }

        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, this + ' room alias was not set, waiting for any update in ' + room);
        return state.once('update');
      }

      if (state.has(stateKey)) {
        return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a.resolve();
      }
      if (stateKey) {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, this + ' state was not set, waiting for state key update in ' + room);
        return state.once('update:' + stateKey);
      } else {
        __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, this + ' state was not set, waiting for default value update in ' + room);
        return state.once('value');
      }
    }
  }, {
    key: '_waitForRoomInvites',
    value: function _waitForRoomInvites(room, invitedUserIds) {
      var _this2 = this;

      var deferred = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_utils__["defer"])();
      var waitForInvite = (invitedUserIds || []).slice();
      __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, this + ' waiting for invited users in ' + room + ': ' + waitForInvite.join(','));

      var consumeEvent = function consumeEvent(event) {
        if (event.type === 'm.room.member' && event.content.membership === 'invited') {
          var index = waitForInvite.indexOf(event.stateKey);
          if (index !== -1) {
            waitForInvite.splice(index, 1);
          }
        }
        if (!waitForInvite.length) {
          __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, _this2 + ' has now seen all invites for invited users in ' + room);
          room.off('event', consumeEvent);
          deferred.resolve();
        } else {
          __WEBPACK_IMPORTED_MODULE_4_common_log__["default"].debug(TAG, _this2 + ' waiting for remaining invites in ' + room + ': ' + waitForInvite.join(','));
        }
      };

      room.on('event', consumeEvent);
      room.events.forEach(consumeEvent);

      return deferred.promise;
    }
  }, {
    key: 'init',
    value: function init(roomDependencies) {
      this._roomDependencies = roomDependencies;
      return this;
    }
  }, {
    key: 'clear',
    value: function clear() {
      for (var i in this._roomArray) {
        this._roomArray[i]._close();
      }
      this._roomArray = [];
      this._roomMap = {};
      this._roomDependencies = null;
    }
  }, {
    key: '_handleRoomSync',
    value: function _handleRoomSync(roomId, membership, roomData, isFirstSync) {
      var room = this.getOrCreateEmptyRoom(roomId);
      room._handleRoomSync(roomData, membership, isFirstSync);
    }
  }, {
    key: '_createRoom',
    value: function _createRoom(matrixId) {
      if (this._roomMap[matrixId]) {
        __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].error('RoomRegistry._createRoom', 'matrixId', 'room already exists');
      }
      var room = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_utils__["priv"])(__WEBPACK_IMPORTED_MODULE_7_matrix_room__["a" /* default */], { matrixId: matrixId }, this._roomDependencies);
      this._roomMap[matrixId] = room;
      this._roomArray.push(room);

      var deferred = this._deferredRooms[matrixId];
      if (deferred) {
        for (var i in deferred) {
          deferred[i](room);
        }
        delete this._deferredRooms[matrixId];
      }
      this._delegate._onRoomCreated(room);

      return room;
    }
  }]);

  return RoomRegistry;
}();

/* harmony default export */ __webpack_exports__["a"] = (RoomRegistry);

/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = SyncStream;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_request__ = __webpack_require__(166);






// deps.delegate._handleAccountDataSync
// deps.delegate._didChangeSyncStreamState
// deps.userRegistry
// deps.roomRegistry
function SyncStream(deps) {
  this._request = null;
  this._state = null;
  this._syncToken = null;

  this._retryCount = 0;
  this._retryTimeout = this.INITIAL_RETRY_TIMEOUT;

  this._delegate = deps.delegate;
  this._userRegistry = deps.userRegistry;
  this._roomRegistry = deps.roomRegistry;

  this._poll = this._poll.bind(this);
  this._retry = this._retry.bind(this);
  this._onPollError = this._onPollError.bind(this);
  this._onPollResponse = this._onPollResponse.bind(this);
  this._onFirstSyncResponse = this._onFirstSyncResponse.bind(this);
}

SyncStream.prototype = {
  constructor: SyncStream,
  tag: 'sync-stream',

  SYNC_POLL_TIMEOUT: 10000,
  SYNC_POLL_TIMEOUT_GRACE_PERIOD: 5000,
  INITIAL_RETRY_TIMEOUT: 1000,
  MAX_RETRY_TIMEOUT: 1000 * 60,
  RETRY_ADD: 1000,
  RETRY_MULT: 1.2,
  RETRY_DISCONNECT_LIMIT: 2,

  toString: function toString() {
    return 'syncStream{token=' + this._syncToken + ',state=' + this._state + '}';
  },

  // deps.authedRequest
  // [deps.startToken]
  start: function start(deps) {
    this._state = 'connecting';
    this._delegate._didChangeSyncStreamState(this._state);
    this._request = deps.authedRequest.path('sync').config('timeout', this.SYNC_POLL_TIMEOUT + this.SYNC_POLL_TIMEOUT_GRACE_PERIOD);
    return this._request.query({
      since: deps.startToken,
      filter: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()({ room: { timeline: { limit: 0 } } })
    }).get().then(this._onFirstSyncResponse);
  },

  stop: function stop() {
    this._state = null;
    this._delegate._didChangeSyncStreamState(this._state);
    this._baseRequest = null;
  },

  get state() {
    return this._state;
  },

  _poll: function _poll() {
    this._request.client(new __WEBPACK_IMPORTED_MODULE_2_common_request__["a" /* SerializedJsonRetryClient */]()).query({
      since: this._syncToken,
      timeout: this.SYNC_POLL_TIMEOUT
    }).get().then(this._onPollResponse).catch(this._onPollError);
  },

  _onFirstSyncResponse: function _onFirstSyncResponse(res) {
    this._onPollResponse(res, true);
    this._state = 'connected';
    this._delegate._didChangeSyncStreamState(this._state);
  },

  _onPollResponse: function _onPollResponse(res, isFirstSync) {
    this._retryTimeout = this.INITIAL_RETRY_TIMEOUT;
    this._retryCount = 0;

    var body = res.body;
    if (!this._state) {
      return;
    } else if (this._state === 'disconnected') {
      this._state = 'connected';
      this._delegate._didChangeSyncStreamState(this._state);
    }

    this._syncToken = body.next_batch;
    try {
      this._handleReponseEvents(body, isFirstSync);
    } catch (error) {
      __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].error(this.tag, this + ', error handling poll response, ' + error);
    } finally {
      this._poll();
    }
  },

  _onPollError: function _onPollError(error) {
    if (!this._state) {
      return;
    }
    __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].error(this.tag, this + ', poll failed, ' + error);
    __WEBPACK_IMPORTED_MODULE_1_common_log__["default"].error(this.tag, this + ', scheduling retry in ' + this._retryTimeout + 'ms with ' + this._retryCount + ' made');

    if (this._retryCount === this.RETRY_DISCONNECT_LIMIT) {
      this._state = 'disconnected';
      this._delegate._didChangeSyncStreamState(this._state);
    }
    this._retryCount += 1;
    setTimeout(this._retry, this._retryTimeout);
  },

  _retry: function _retry() {
    if (!this._state) {
      return;
    }
    this._retryTimeout *= this.RETRY_MULT;
    this._retryTimeout += this.RETRY_ADD;
    this._retryTimeout = Math.round(this._retryTimeout);
    if (this._retryTimeout > this.MAX_RETRY_TIMEOUT) {
      this._retryTimeout = this.MAX_RETRY_TIMEOUT;
    }
    this._poll();
  },

  _handleReponseEvents: function _handleReponseEvents(body, isFirstSync) {
    var accountDataEvents = body.account_data.events;
    var presenceEvents = body.presence.events;

    this._delegate._handleAccountDataSync(accountDataEvents);
    this._userRegistry._handlePresenceSync(presenceEvents);

    var rooms = body.rooms;
    for (var membership in rooms) {
      var membershipRooms = rooms[membership];
      for (var roomId in membershipRooms) {
        var roomData = membershipRooms[roomId];
        this._roomRegistry._handleRoomSync(roomId, membership, roomData, isFirstSync);
      }
    }
  }
};

/***/ }),
/* 278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_common__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_media_htmlSink__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_media_mediaNode__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_media_canvasSource__ = __webpack_require__(279);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_media_streamSplitter__ = __webpack_require__(191);
















var TAG = 'canvas-filter';

/**
 * A sink that can be used to take snapshots of a video stream that are
 * exported as either blobs or a data URIs.
 *
 * @class VideoFrameCapture
 */

var CanvasFilter = function (_MediaNode$connectMix) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(CanvasFilter, _MediaNode$connectMix);

  function CanvasFilter(options) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, CanvasFilter);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (CanvasFilter.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(CanvasFilter)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7_media_common__["e" /* doesntSupportPlugin */])(_this);
    __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].optOptions('CanvasFilter constructor', 'options', options).optInstance('canvas', HTMLCanvasElement).optNumber('videoFrameRate').optFunc('renderFunction');

    var _ref = options || {},
        render = _ref.render,
        canvas = _ref.canvas,
        _ref$videoFrameRate = _ref.videoFrameRate,
        videoFrameRate = _ref$videoFrameRate === undefined ? 24 : _ref$videoFrameRate;

    if (videoFrameRate <= 0) {
      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].error('CanvasFilter constructor', 'options.videoFrameRate', 'a positive number');
    }

    _this._videoFrameRate = videoFrameRate;
    _this._renderFunction = render;

    _this._renderInterval = null;

    _this._video = document.createElement('video');

    _this._splitter = new __WEBPACK_IMPORTED_MODULE_11_media_streamSplitter__["a" /* default */]();
    _this._htmlSink = new __WEBPACK_IMPORTED_MODULE_8_media_htmlSink__["default"]({ target: _this._video });
    _this._canvasSource = new __WEBPACK_IMPORTED_MODULE_10_media_canvasSource__["a" /* default */]({ canvas: canvas, videoFrameRate: videoFrameRate });
    _this._canvas = _this._canvasSource.canvas;

    _this._splitter.videoOutput.connect(_this._htmlSink);

    _this._render = _this._render.bind(_this);

    _this.startRender = _this.startRender.bind(_this);
    _this.stopRender = _this.stopRender.bind(_this);
    _this._video.addEventListener('loadeddata', _this.startRender);
    _this._video.addEventListener('emptied', _this.stopRender);
    return _this;
  }

  /**
   * The input from which the video will be captured.
   *
   * @member {MediaNodeInput} CanvasFilter#input
   */


  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(CanvasFilter, [{
    key: 'startRender',
    value: function startRender() {
      var _video = this._video,
          videoWidth = _video.videoWidth,
          videoHeight = _video.videoHeight;

      this._canvas.width = videoWidth;
      this._canvas.height = videoHeight;
      this._fpsInterval = 1000 / this._videoFrameRate;
      this._then = Date.now();
      this._startTime = this._then;
      this._render();
    }
  }, {
    key: 'stopRender',
    value: function stopRender() {
      clearInterval(this._renderInterval);
      this._renderInterval = null;
    }
  }, {
    key: '_render',
    value: function _render() {
      var now = Date.now();
      var elapsed = now - this._then;
      if (elapsed > this._fpsInterval) {
        this._then = now - elapsed % this._fpsInterval;

        try {
          this.render(this._video, this._canvas);
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(TAG, 'error thrown in render function, ' + error);
        }
      }

      requestAnimationFrame(this._render);
    }
  }, {
    key: 'render',
    value: function render(video, canvas) {
      if (this._renderFunction) {
        this._renderFunction(video, canvas);
      }
    }
  }, {
    key: 'input',
    get: function get() {
      return this._splitter;
    }
  }, {
    key: 'output',
    get: function get() {
      return this._canvasSource;
    }
  }]);

  return CanvasFilter;
}(__WEBPACK_IMPORTED_MODULE_9_media_mediaNode__["a" /* default */].connectMixin());

/* harmony default export */ __webpack_exports__["a"] = (CanvasFilter);

/***/ }),
/* 279 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_media_common__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_mediaSource__ = __webpack_require__(144);












var CanvasSource = function (_MediaSource) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(CanvasSource, _MediaSource);

  function CanvasSource(options) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, CanvasSource);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (CanvasSource.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(CanvasSource)).call(this));

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_media_common__["e" /* doesntSupportPlugin */])(_this);
    __WEBPACK_IMPORTED_MODULE_5_common_argCheck__["a" /* default */].options('CanvasSource constructor', 'options', options).optInstance('canvas', HTMLCanvasElement).optNumber('videoFrameRate');
    var canvas = options.canvas,
        _options$videoFrameRa = options.videoFrameRate,
        videoFrameRate = _options$videoFrameRa === undefined ? 24 : _options$videoFrameRa;


    if (canvas) {
      _this._canvas = canvas;
    } else {
      _this._canvas = document.createElement('canvas');
      _this._canvas.style.position = 'absolute';
      _this._canvas.style.right = '0';

      _this._canvasContainer = document.createElement('div');
      _this._canvasContainer.style.zIndex = -1e10;
      _this._canvasContainer.style.position = 'fixed';
      _this._canvasContainer.style.left = '0';
      _this._canvasContainer.style.width = '0';
      _this._canvasContainer.style.height = '0';
      _this._canvasContainer.style.overflow = 'hidden';
      _this._canvasContainer.appendChild(_this._canvas);

      document.body.appendChild(_this._canvasContainer);
    }

    _this._canvas.getContext('2d'); /* initialize context or the below line will fail in Firefox */
    _this.setStream(_this._canvas.captureStream(videoFrameRate));
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(CanvasSource, [{
    key: 'stop',
    value: function stop() {
      if (this._canvasContainer) {
        document.body.removeChild(this._canvasContainer);
        this._canvasContainer = null;
      }
      this._canvas = null;
      this.stream.stop();
    }
  }, {
    key: 'canvas',
    get: function get() {
      return this._canvas;
    }
  }]);

  return CanvasSource;
}(__WEBPACK_IMPORTED_MODULE_7_media_mediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (CanvasSource);

/***/ }),
/* 280 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_canvasFilter__ = __webpack_require__(278);











var TAG = 'scaled-canvas-filter';

/**
 * A sink that can be used to make scaled down streams of existing
 * camera streams
 *
 * @class ScaledCanvasFilter
 */

var ScaledCanvasFilter = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(ScaledCanvasFilter, _EmitterMixin);

  function ScaledCanvasFilter(options) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, ScaledCanvasFilter);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (ScaledCanvasFilter.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(ScaledCanvasFilter)).call(this, options));

    var projectionConfiguration = options.projectionConfiguration,
        imageFrameRate = options.imageFrameRate;


    _this._projectionConfiguration = projectionConfiguration;
    _this._context = _this._canvas.getContext('2d');
    _this._imageFrameRate = imageFrameRate;
    _this._grabStillPicture = _this._grabStillPicture.bind(_this);
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(ScaledCanvasFilter, [{
    key: '_calcProjection',
    value: function _calcProjection() {
      var _video = this._video,
          videoWidth = _video.videoWidth,
          videoHeight = _video.videoHeight;
      var _projectionConfigurat = this._projectionConfiguration,
          width = _projectionConfigurat.width,
          _projectionConfigurat2 = _projectionConfigurat.aspectRatio,
          aspectRatio = _projectionConfigurat2 === undefined ? 16 / 9 : _projectionConfigurat2,
          _projectionConfigurat3 = _projectionConfigurat.contentMode,
          contentMode = _projectionConfigurat3 === undefined ? 'aspectFill' : _projectionConfigurat3;


      var height = width / aspectRatio;
      this._canvas.width = width;
      this._canvas.height = height;

      var videoAspectRatio = videoWidth / videoHeight;

      if (contentMode === 'aspectFill') {
        if (videoAspectRatio < aspectRatio) {
          var delta = width / videoAspectRatio - height;

          return {
            width: width,
            height: height + delta,
            deltaY: -delta / 2,
            deltaX: 0
          };
        } else {
          var _delta = height * videoAspectRatio - width;

          return {
            height: height,
            width: width + _delta,
            deltaY: 0,
            deltaX: -_delta / 2
          };
        }
      }

      if (contentMode === 'scaleToFill') {
        return {
          height: height,
          width: width,
          deltaY: 0,
          deltaX: 0
        };
      }
    }
  }, {
    key: 'startRender',
    value: function startRender() {
      var _video2 = this._video,
          videoWidth = _video2.videoWidth,
          videoHeight = _video2.videoHeight;

      __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, 'video resolution: ' + videoWidth + 'x' + videoHeight);
      this._projection = this._calcProjection();

      if (this._imageFrameRate > 0) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, 'starting interval for still pictures: frameRate = ' + 1000 / this._imageFrameRate);
        this._stillPictureInterval = setInterval(this._grabStillPicture, 1000 / this._imageFrameRate);
      } else {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].info(TAG, 'not starting picture grab loop');
      }

      this._fpsInterval = 1000 / this._videoFrameRate;
      this._then = Date.now();
      this._startTime = this._then;
      this._render();
    }
  }, {
    key: '_grabStillPicture',
    value: function _grabStillPicture() {
      var dataUrl = this._canvas.toDataURL('image/joeg');
      this._emit('stillPictureCaptured', dataUrl);
    }
  }, {
    key: 'render',
    value: function render(video, canvas) {
      var _video3 = this._video,
          videoWidth = _video3.videoWidth,
          videoHeight = _video3.videoHeight;


      var ctx = this._context;
      ctx.drawImage(video, 0, 0, videoWidth, videoHeight, this._projection.deltaX, this._projection.deltaY, this._projection.width, this._projection.height);
    }
  }]);

  return ScaledCanvasFilter;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_emitter__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_7_media_canvasFilter__["a" /* default */]));

/* harmony default export */ __webpack_exports__["a"] = (ScaledCanvasFilter);

/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_common_utils__ = __webpack_require__(13);






var ScreenSourceInfo = function () {
  function ScreenSourceInfo(priv, info) {
    __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_classCallCheck___default()(this, ScreenSourceInfo);

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_common_utils__["assertPriv"])('ScreenSourceInfo', priv);
    this.type = info.type;
    this.label = info.label;
  }

  __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_createClass___default()(ScreenSourceInfo, [{
    key: 'toString',
    value: function toString() {
      return 'screenSourceInfo{type=' + this.type + ',label="' + this.label + '"}';
    }

    /**
     * The screen sharing type of this source.
     *
     * @member {ScreenSharingType} ScreenSourceInfo#type
     */

    /**
     * A human-readable description of the source, e.g. "Screen 1", or the title of a window.
     *
     * @member {'string'} ScreenSourceInfo#label
     */

  }]);

  return ScreenSourceInfo;
}();

/* harmony default export */ __webpack_exports__["a"] = (ScreenSourceInfo);

/***/ }),
/* 282 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_emitter__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_media_htmlSink__ = __webpack_require__(146);











var TAG = 'temasys-canvas-filter';

/**
 * A sink that can be used to make scaled down streams of existing
 * camera streams
 *
 * @class TemasysCanvasFilter
 */

var TemasysCanvasFilter = function (_EmitterMixin) {
  __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_inherits___default()(TemasysCanvasFilter, _EmitterMixin);

  function TemasysCanvasFilter(options) {
    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, TemasysCanvasFilter);

    var _this = __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_possibleConstructorReturn___default()(this, (TemasysCanvasFilter.__proto__ || __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_object_get_prototype_of___default()(TemasysCanvasFilter)).call(this));

    var projectionConfiguration = options.projectionConfiguration,
        _options$imageFrameRa = options.imageFrameRate,
        imageFrameRate = _options$imageFrameRa === undefined ? 0.5 : _options$imageFrameRa;


    _this._video = document.createElement('video');
    _this._htmlSink = new __WEBPACK_IMPORTED_MODULE_7_media_htmlSink__["default"]({ target: _this._video });

    _this._canvas = document.createElement('canvas');
    _this._canvas.style.position = 'absolute';
    _this._canvas.style.right = '0';

    _this._canvasContainer = document.createElement('div');
    _this._canvasContainer.style.zIndex = -1e10;
    _this._canvasContainer.style.position = 'fixed';
    _this._canvasContainer.style.left = '0';
    _this._canvasContainer.style.width = '0';
    _this._canvasContainer.style.height = '0';
    _this._canvasContainer.style.overflow = 'hidden';
    _this._canvasContainer.appendChild(_this._canvas);

    document.body.appendChild(_this._canvasContainer);
    _this._canvasContainer.appendChild(_this._video);

    _this._projectionConfiguration = projectionConfiguration;
    _this._imageFrameRate = imageFrameRate;
    _this._render = _this._render.bind(_this);
    _this.startRender = _this.startRender.bind(_this);
    _this.stopRender = _this.stopRender.bind(_this);
    _this.render = _this.render.bind(_this);

    setTimeout(_this.startRender, 1000); // TODO: How to start rendering properly?
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(TemasysCanvasFilter, [{
    key: 'startRender',
    value: function startRender() {
      var _htmlSink$target = this._htmlSink.target,
          videoWidth = _htmlSink$target.videoWidth,
          videoHeight = _htmlSink$target.videoHeight;

      this._canvas.width = videoWidth;
      this._canvas.height = videoHeight;
      this._renderInterval = setInterval(this._render, 1000 / this._imageFrameRate);
    }
  }, {
    key: 'stopRender',
    value: function stopRender() {
      clearInterval(this._renderInterval);
      this._renderInterval = null;
    }
  }, {
    key: '_render',
    value: function _render() {
      try {
        this.render(this._video, this._canvas);
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_5_common_log__["default"].error(TAG, 'error thrown in render function, ' + error);
      }
    }
  }, {
    key: '_calcProjection',
    value: function _calcProjection() {
      var _htmlSink$target2 = this._htmlSink.target,
          videoWidth = _htmlSink$target2.videoWidth,
          videoHeight = _htmlSink$target2.videoHeight;
      var _projectionConfigurat = this._projectionConfiguration,
          width = _projectionConfigurat.width,
          _projectionConfigurat2 = _projectionConfigurat.aspectRatio,
          aspectRatio = _projectionConfigurat2 === undefined ? 16 / 9 : _projectionConfigurat2,
          _projectionConfigurat3 = _projectionConfigurat.contentMode,
          contentMode = _projectionConfigurat3 === undefined ? 'aspectFill' : _projectionConfigurat3;


      var height = width / aspectRatio;
      this._canvas.width = width;
      this._canvas.height = height;

      var videoAspectRatio = videoWidth / videoHeight;

      if (contentMode === 'aspectFill') {
        if (videoAspectRatio < aspectRatio) {
          var delta = width / videoAspectRatio - height;

          return {
            width: width,
            height: height + delta,
            deltaY: -delta / 2,
            deltaX: 0
          };
        } else {
          var _delta = height * videoAspectRatio - width;

          return {
            height: height,
            width: width + _delta,
            deltaY: 0,
            deltaX: -_delta / 2
          };
        }
      }

      if (contentMode === 'scaleToFill') {
        return {
          height: height,
          width: width,
          deltaY: 0,
          deltaX: 0
        };
      }
    }
  }, {
    key: 'render',
    value: function render(video, canvas) {
      var _this2 = this;

      var _htmlSink$target3 = this._htmlSink.target,
          videoWidth = _htmlSink$target3.videoWidth,
          videoHeight = _htmlSink$target3.videoHeight;

      if (!this._projection) {
        this._projection = this._calcProjection();
      }

      var base64img = this._htmlSink.target.getFrame();
      var image = new Image();
      image.onload = function () {
        var ctx = _this2._canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, videoWidth, videoHeight, _this2._projection.deltaX, _this2._projection.deltaY, _this2._projection.width, _this2._projection.height);

        var dataUrl = _this2._canvas.toDataURL('image/jpeg');
        _this2._emit('stillPictureCaptured', dataUrl);
      };

      image.setAttribute('src', 'data:image/png;base64,' + base64img);
    }
  }, {
    key: 'input',
    get: function get() {
      return this._htmlSink;
    }
  }]);

  return TemasysCanvasFilter;
}(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6_common_emitter__["a" /* default */])(null));

/* harmony default export */ __webpack_exports__["a"] = (TemasysCanvasFilter);

/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_common_argCheck__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_common_utils__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_webrtc_utils__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_media_common__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_media_concreteMediaSource__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_media_screenSourceInfo__ = __webpack_require__(281);













var WebRTCPlugin = __WEBPACK_IMPORTED_MODULE_9_webrtc_utils__["AdapterJS"].WebRTCPlugin;






var TAG = 'temasys-screen-source';

var TemasysScreenSourceInfo = function (_ScreenSourceInfo) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(TemasysScreenSourceInfo, _ScreenSourceInfo);

  function TemasysScreenSourceInfo(priv, info) {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, TemasysScreenSourceInfo);

    var _this = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (TemasysScreenSourceInfo.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(TemasysScreenSourceInfo)).call(this, priv, {
      type: info.kind,
      label: info.label
    }));

    _this._id = info.id;
    return _this;
  }

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(TemasysScreenSourceInfo, [{
    key: 'toString',
    value: function toString() {
      return 'temasysScreenSourceInfo{type=' + this.type + ',id=' + this._id + ',label="' + this.label + '"}';
    }
  }]);

  return TemasysScreenSourceInfo;
}(__WEBPACK_IMPORTED_MODULE_12_media_screenSourceInfo__["a" /* default */]);

/**
 * Internal media node for acquiring a Temasys screen sharing stream.
 *
 * @private
 * @class TemasysScreenSource
 * @extends ConcreteMediaSource
 * @param {Object} [options] - Optional options object.
 * @param {ScreenSharingType|null} [options.type=null] - The screen sharing type to use. Specifying
 *   null will let the user choose either screen or window.
 * @param {boolean} [options.audio=false] - Whether audio should be requested as well.
 * @param {Object} [options.video] - Constraints for the video, defaults to max resolution and no
 *   framerate limit.
 */


var TemasysScreenSource = function (_ConcreteMediaSource) {
  __WEBPACK_IMPORTED_MODULE_5_babel_runtime_helpers_inherits___default()(TemasysScreenSource, _ConcreteMediaSource);

  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(TemasysScreenSource, null, [{
    key: 'enumerateSources',
    value: function enumerateSources() {
      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve) {
        WebRTCPlugin.plugin.getScreensharingSources(function (list) {
          resolve(list.map(function (info) {
            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8_common_utils__["priv"])(TemasysScreenSourceInfo, info);
          }));
        });
      });
    }
  }, {
    key: 'canEnumerateSources',
    get: function get() {
      return true;
    }
  }]);

  function TemasysScreenSource(options) {
    __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_classCallCheck___default()(this, TemasysScreenSource);

    var _this2 = __WEBPACK_IMPORTED_MODULE_4_babel_runtime_helpers_possibleConstructorReturn___default()(this, (TemasysScreenSource.__proto__ || __WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_get_prototype_of___default()(TemasysScreenSource)).call(this));

    __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].optOptions('TemasysScreenSource constructor', 'options', options).optObject('video');

    var video = options.video || {};
    var type = options.type || 'screensharing';

    if (!video.mediaSource) {
      video.mediaSource = type;
    }

    if (options.type && !WebRTCPlugin.plugin.screensharingKeys) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].warning(TAG, 'this version of the temasys plugin does not support screen sharing type selection');
    }
    video.optional = [{
      sourceId: WebRTCPlugin.plugin.screensharingKey || 'Screensharing'
    }];

    if (video.source) {
      var source = video.source;
      if (source.exact) {
        throw new TypeError('Constaint video.source.exact is not supported');
      } else if (source.ideal) {
        source = source.ideal;
      }
      __WEBPACK_IMPORTED_MODULE_6_common_argCheck__["a" /* default */].instance(_this2, 'source', video.source, TemasysScreenSourceInfo);
      video.optional.push({
        screenId: video.source._id
      });
      delete video.source;
    }

    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_10_media_common__["f" /* getUserMedia */])({
      video: video,
      audio: false
    }).then(function (stream) {
      _this2.setStream(stream);
      stream.onended = function () {
        if (stream) stream.stop();
        _this2.setStream(null);
      };
    }, function (error) {
      return _this2.setError(error);
    }).catch(function (error) {
      __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'unexpected error in TemasysScreenSource: ' + error);
    });
    return _this2;
  }

  // track.stop() for screen sharing streams is broken at least up until 0.8.892


  __WEBPACK_IMPORTED_MODULE_3_babel_runtime_helpers_createClass___default()(TemasysScreenSource, [{
    key: '_stopStream',
    value: function _stopStream(stream) {
      try {
        stream.stop();
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_7_common_log__["default"].error(TAG, 'failed to stop media stream:', error);
      }
    }
  }]);

  return TemasysScreenSource;
}(__WEBPACK_IMPORTED_MODULE_11_media_concreteMediaSource__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (TemasysScreenSource);

/***/ }),
/* 284 */,
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_common_log__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_common_utils__ = __webpack_require__(13);








var TAG = 'renegotiator';

var Renegotiator = function () {
  function Renegotiator(_ref) {
    var label = _ref.label,
        channel = _ref.channel,
        onError = _ref.onError;

    __WEBPACK_IMPORTED_MODULE_1_babel_runtime_helpers_classCallCheck___default()(this, Renegotiator);

    this._label = label;
    this._peerConnection = null;
    this._isInitiator = null;
    this._needRenegotiation = false;
    this._doingRenegotiation = false;
    this._renegotiationTime = 1;
    this._renegotiationOfferQueue = [];

    this._onError = onError;

    this._channel = channel;
    this._channel.on('message', this._onMessage.bind(this));

    this._onSignalingStateChange = this._onSignalingStateChange.bind(this);
    this._onNegotiationNeeded = this._onNegotiationNeeded.bind(this);
  }

  __WEBPACK_IMPORTED_MODULE_2_babel_runtime_helpers_createClass___default()(Renegotiator, [{
    key: 'toString',
    value: function toString() {
      return 'renegotiator{"' + this._label + '",initiator=' + this._isInitiator + ',' + this._peerConnection + '}';
    }
  }, {
    key: 'setPeerConnection',
    value: function setPeerConnection(peerConnection) {
      this.reset();
      this._peerConnection = peerConnection;
      this._peerConnection.addEventListener('negotiationneeded', this._onNegotiationNeeded);
      this._peerConnection.addEventListener('signalingstatechange', this._onSignalingStateChange);
    }
  }, {
    key: 'start',
    value: function start(isInitiator) {
      this._isInitiator = isInitiator;

      if (this._needRenegotiation) {
        this._onNegotiationNeeded();
      }
    }
  }, {
    key: 'reset',
    value: function reset() {
      if (this._peerConnection) {
        this._peerConnection.removeEventListener('negotiationneeded', this._onNegotiationNeeded);
        this._peerConnection.removeEventListener('signalingstatechange', this._onSignalingStateChange);
      }
      this._peerConnection = null;
      this._isInitiator = null;
      this._needRenegotiation = false;
      this._doingRenegotiation = false;
      this._renegotiationTime = 1;
      this._renegotiationOfferQueue = [];
    }
  }, {
    key: '_onNegotiationNeeded',
    value: function _onNegotiationNeeded() {
      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, this._peerConnection + ' needs negotiation');
      if (this._isInitiator === true) {
        if (this._doingRenegotiation) {
          this._needRenegotiation = true;
        } else {
          this._sendRenegotiationOffer();
        }
      } else if (this._isInitiator === false) {
        this._sendRenegotiationRequest();
      } else {
        this._needRenegotiation = true;
      }
    }
  }, {
    key: '_sendRenegotiationRequest',
    value: function _sendRenegotiationRequest() {
      this._renegotiationTime += 1;
      var audioCount = 0;
      var videoCount = 0;
      this._peerConnection.getLocalStreams().forEach(function (stream) {
        audioCount += stream.getAudioTracks().length;
        videoCount += stream.getVideoTracks().length;
      });
      var time = this._renegotiationTime;
      this._sendMessage('negotiationRequest', { audioCount: audioCount, videoCount: videoCount, time: time });
      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, 'sent negotiation request {time=' + time + ',audio=' + audioCount + ',video=' + videoCount + '}');
    }
  }, {
    key: '_handleRenegotiationRequest',
    value: function _handleRenegotiationRequest(content) {
      var time = content.time;
      if (time < this._renegotiationTime) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'invalid renegotiation time: ' + time);
        return;
      }
      if (__WEBPACK_IMPORTED_MODULE_4_common_utils__["isChrome"]) {
        this._requestedConstraints = {
          mandatory: {
            OfferToReceiveAudio: !!content.audioCount,
            OfferToReceiveVideo: !!content.videoCount
          }
        };
      } else {
        this._requestedConstraints = {
          offerToReceiveVideo: content.videoCount || 0,
          offerToReceiveAudio: content.audioCount || 0
        };
      }
      this._renegotiationTime = content.time;
      if (!this._doingRenegotiation) {
        this._sendRenegotiationOffer();
      } else {
        this._needRenegotiation = true;
      }
    }
  }, {
    key: '_sendRenegotiationOffer',
    value: function _sendRenegotiationOffer(offerConstraints) {
      var _this = this;

      this._doingRenegotiation = true;
      this._needRenegotiation = false;
      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].verbose(TAG, 'preparing to send renegotiation offer with constraints: ' + __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_json_stringify___default()(this._requestedConstraints));
      return this._peerConnection.performOffer({
        constraints: this._requestedConstraints
      }).then(function (description) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, 'sending offer:', description);

        return _this._sendMessage('offer', {
          type: description.type,
          sdp: description.sdp,
          unifiedPlanSdp: description.unifiedPlanSdp
        });
      }).catch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["errorForwarder"])(this._onError, '_sendRenegotiationOffer'));
    }
  }, {
    key: '_handleRenegotiationOffer',
    value: function _handleRenegotiationOffer(offer) {
      var _this2 = this;

      if (this._doingRenegotiation) {
        this._renegotiationOfferQueue.push(offer);
        return __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].info(TAG, 'got early offer, queued:', offer);
      }

      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].verbose(TAG, 'got offer', offer);
      this._doingRenegotiation = true;
      return this._peerConnection.performAnswer({ offer: offer }).then(function (description) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, 'sending answer:', description);
        return _this2._sendMessage('answer', {
          type: description.type,
          sdp: description.sdp,
          unifiedPlanSdp: description.unifiedPlanSdp,
          time: _this2._renegotiationTime
        });
      }).catch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["errorForwarder"])(this._onError, '_handleRenegotiationOffer')).then(function () {
        _this2._doingRenegotiation = false;
        if (_this2._renegotiationOfferQueue.length) {
          _this2._handleRenegotiationOffer(_this2._renegotiationOfferQueue.pop());
        }
      });
    }
  }, {
    key: '_handleRenegotiationAnswer',
    value: function _handleRenegotiationAnswer(answer) {
      var _this3 = this;

      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, 'got answer:', answer);
      return this._peerConnection.handleAnswer({ answer: answer }).catch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4_common_utils__["errorForwarder"])(this._onError, '_handleRenegotiationAnswer')).then(function () {
        if (_this3._renegotiationTime > answer.time) {
          _this3._needRenegotiation = true;
        } else {
          _this3._renegotiationTime = answer.time;
        }
        _this3._doingRenegotiation = _this3._needRenegotiation;
        if (_this3._needRenegotiation) {
          return _this3._sendRenegotiationOffer();
        }
      });
    }
  }, {
    key: '_onSignalingStateChange',
    value: function _onSignalingStateChange() {
      var signalingState = this._peerConnection.signalingState;

      __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, this + ' changed signaling state: ' + signalingState);
    }
  }, {
    key: '_onMessage',
    value: function _onMessage(message) {
      if (!this._peerConnection) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'got signaling message without peer connection');
        return false;
      }
      try {
        var type = message.type,
            content = message.content;

        switch (type) {
          case 'negotiationRequest':
            this._handleRenegotiationRequest(content);
            break;
          case 'answer':
            this._handleRenegotiationAnswer(content);
            break;
          case 'offer':
            this._handleRenegotiationOffer(content);
            break;
          default:
            __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].warning(TAG, 'got unknown message: \'' + type + '\'');
            break;
        }
      } catch (error) {
        __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].error(TAG, 'error processing message (', event.data, '):', error, error.stack);
      }
    }
  }, {
    key: '_sendMessage',
    value: function _sendMessage(type, content) {
      var _this4 = this;

      if (this._channel.readyState === 'open') {
        this._channel.send({ type: type, content: content }).catch(function (error) {
          __WEBPACK_IMPORTED_MODULE_3_common_log__["default"].debug(TAG, _this4, 'failed to send \'' + type + '\' message, ' + error);
        });
      }
    }
  }]);

  return Renegotiator;
}();

/* harmony default export */ __webpack_exports__["a"] = (Renegotiator);

/***/ }),
/* 286 */,
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(292), __esModule: true };

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(293), __esModule: true };

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(295), __esModule: true };

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _assign = __webpack_require__(163);

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(303);


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(297);
module.exports = __webpack_require__(0).Math.log2;

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(298);
module.exports = __webpack_require__(0).Math.sign;

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(299);
module.exports = __webpack_require__(0).Object.entries;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(300);
module.exports = __webpack_require__(0).Object.values;

/***/ }),
/* 296 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(6);

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(6);

$export($export.S, 'Math', {sign: __webpack_require__(296)});

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export  = __webpack_require__(6)
  , $entries = __webpack_require__(235)(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(6)
  , $values = __webpack_require__(235)(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});

/***/ }),
/* 301 */,
/* 302 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g =
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this;

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(304);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(236)))

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = arg;

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(236), __webpack_require__(302)))

/***/ })
/******/ ]);
});
//# sourceMappingURL=cct.js.map